
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>3. Propositional Logic &#8212; Sireum Logika</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sireum.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../_static/logika.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="4. The Predicate-Logic Quantifiers" href="../04-predicate-logic/index.html" />
    <link rel="prev" title="2. Circuits and Truth Tables" href="../02-circuits-truth-tables/index.html" />
  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          Logika</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../doc/01-getting-started/index.html">Download</a></li>
                <li><a href="../../doc/index.html">Documentation</a></li>
                <li><a href="../index.html">Course Notes</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html"> <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#"> <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">3. Propositional Logic</a><ul>
<li><a class="reference internal" href="#propositions">3.1. Propositions</a></li>
<li><a class="reference internal" href="#the-sequent">3.2. The Sequent</a><ul>
<li><a class="reference internal" href="#validity-of-a-sequent">3.2.1. Validity of a Sequent</a></li>
<li><a class="reference internal" href="#logika-truth-table-example">3.2.2. Logika Truth Table example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#inference-rules">3.3. Inference Rules</a></li>
<li><a class="reference internal" href="#logika-proof-syntax">3.4. Logika Proof Syntax</a><ul>
<li><a class="reference internal" href="#the-two-column-proof">3.4.1. The Two-Column Proof</a></li>
<li><a class="reference internal" href="#scope-and-use-of-subproofs">3.4.2. Scope and Use of Subproofs</a><ul>
<li><a class="reference internal" href="#scope">Scope</a></li>
<li><a class="reference internal" href="#use">Use</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#the-premise-justification">3.5. The premise Justification</a></li>
<li><a class="reference internal" href="#the-assume-justification">3.6. The assume Justification</a></li>
<li><a class="reference internal" href="#logical-operator-based-justifications">3.7. Logical Operator Based Justifications</a><ul>
<li><a class="reference internal" href="#syntax">3.7.1. Syntax</a></li>
</ul>
</li>
<li><a class="reference internal" href="#and-introduction-and-and-elimination">3.8. And-Introduction and And-Elimination</a><ul>
<li><a class="reference internal" href="#rules">3.8.1. Rules</a></li>
<li><a class="reference internal" href="#examples">3.8.2. Examples</a></li>
<li><a class="reference internal" href="#tactics">3.8.3. Tactics</a></li>
<li><a class="reference internal" href="#logika-tips">3.8.4. Logika Tips</a></li>
</ul>
</li>
<li><a class="reference internal" href="#or-introduction-and-or-elimination">3.9. Or-Introduction and Or-Elimination</a><ul>
<li><a class="reference internal" href="#id4">3.9.1. Rules</a></li>
<li><a class="reference internal" href="#id5">3.9.2. Examples</a></li>
<li><a class="reference internal" href="#id6">3.9.3. Tactics</a></li>
<li><a class="reference internal" href="#id7">3.9.4. Logika Tips</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implies-introduction-and-implies-elimination">3.10. Implies-Introduction and Implies-Elimination</a><ul>
<li><a class="reference internal" href="#id8">3.10.1. Rules</a></li>
<li><a class="reference internal" href="#id9">3.10.2. Examples</a></li>
<li><a class="reference internal" href="#id10">3.10.3. Tactics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#negation">3.11. Negation</a><ul>
<li><a class="reference internal" href="#id11">3.11.1. Rules</a></li>
<li><a class="reference internal" href="#id12">3.11.2. Examples</a></li>
<li><a class="reference internal" href="#tactic">3.11.3. Tactic</a></li>
</ul>
</li>
<li><a class="reference internal" href="#negation-introduction">3.12. Negation Introduction</a><ul>
<li><a class="reference internal" href="#rule">3.12.1. Rule</a></li>
<li><a class="reference internal" href="#id13">3.12.2. Examples</a></li>
<li><a class="reference internal" href="#id14">3.12.3. Tactic</a></li>
</ul>
</li>
<li><a class="reference internal" href="#proof-by-contradiction">3.13. Proof by Contradiction</a><ul>
<li><a class="reference internal" href="#id15">3.13.1. Rule</a></li>
<li><a class="reference internal" href="#id16">3.13.2. Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#important-equivalences">3.14. Important Equivalences</a></li>
<li><a class="reference internal" href="#models-of-propositional-logic-soundness-and-completeness">3.15. Models of Propositional Logic: Soundness and Completeness</a></li>
<li><a class="reference internal" href="#summary-of-rules-and-tactics">3.16. Summary of Rules and Tactics</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <br/>
<font color="darkgray">
<big><big><b>
Logika: Programming Logics
</b></big></big>
</font>
<br/>
<font color="black">
<big><big><big><big><b>
3. Propositional Logic
</b></big></big></big></big>
</font><div class="section" id="propositional-logic">
<span id="id1"></span><h1>3. Propositional Logic<a class="headerlink" href="#propositional-logic" title="Permalink to this headline">¶</a></h1>
<p>Symbolic logic is the study of assertions (declarative statements) using the
connectives, <em>and</em>, <em>or</em>, <em>not</em>, <em>implies</em>, <em>for all</em>, <em>there exists</em>.
It is a “starter language” for stating laws for other areas.
(Example: in algebra, we use symbolic logic to declare, “for all (every)
integer(s), <code class="docutils literal"><span class="pre">i</span></code>, there exists an integer <code class="docutils literal"><span class="pre">j</span></code> such that <code class="docutils literal"><span class="pre">j</span> <span class="pre">&gt;</span> <span class="pre">i</span></code>.)
Without symbolic logic, modern math, physics, philosophy, computing, and
electronics simply would not exist.</p>
<p>Anyone who works in one of the above-stated technical areas must be competent in
using symbolic logic, and in particular, in performing <em>deduction</em>.</p>
<p>Deduction is the synthesis of new facts — consequences — from known facts.
An example: a cases analysis of the assertion that <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">0</span> <span class="pre">v</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> lets us
deduce that <code class="docutils literal"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">0</span></code> and that <code class="docutils literal"><span class="pre">1.0/x</span></code> is a non-erroneous, floating-point
number.
Another example, stated in almost every logic text written in the last 50 years,
goes</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>All humans are mortal
 and
Socrates is a human.

 Therefore,
Socrates is mortal.
</pre></div>
</div>
<p>These examples of deduction go beyond what we can do with mere truth tables
alone, and the purpose of this chapter is to provide a set of <em>deduction rules</em>
(also known as <em>inference rules</em>) that you can use to deduce new facts.
The rules will be written so that they can be used in math, physics, computing,
etc.</p>
<p>We will develop the symbolic-logic rules in detail. This will allow us to start
with a set of known facts (<em>premises</em>), apply a series of rules (operations) to
them, leading to new facts, with the final fact referred to as the <em>consequence</em>.</p>
<p>We will be using Logika in manual (technically not-Auto) mode.  This will require
you to understand and apply the logic deduction rules in a proper order to
reach the proper consequence.  Part of this is to ensure you develop a proof
technique and deep understanding of the logical connectives.  It also helps you
learn to “think like a computer”, which will assist you in programming and
algorithm development.</p>
<p>Keep in mind that ours is a course in Formal Logic,
as such <strong>the obvious is the enemy of the provable.</strong>  You may become frustrated
with Logika and disappointed in your grade if your proofs rely on obvious but
unstated (or unproven) facts.</p>
<div class="section" id="propositions">
<h2>3.1. Propositions<a class="headerlink" href="#propositions" title="Permalink to this headline">¶</a></h2>
<p>Symbolic logic manipulates <em>propositions</em>, which are assertions – declarative
statements that can be understood as “true” (it’s a fact) or “false”
(it is not a fact).</p>
<p>Examples of propositions from algebra are</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>x &gt; 0
y == 2*x + 1
2 &gt; 4
</pre></div>
</div>
<p>The third proposition is always understood as false, whereas the first two might
be true or false, depending on the values of <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code>.</p>
<p>Examples of propositions written in English are</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>Socrates is a human.
The sun is shining.
I have a million bucks in my pocket.
</pre></div>
</div>
<p>In English, we can also write sentences that are not propositions:
“Will it rain tomorrow?” is a question and not a true-false proposition.
We will always stay within algebra and form true-false propositions from
arithmetic operators like <code class="docutils literal"><span class="pre">+</span></code> and <code class="docutils literal"><span class="pre">/</span></code> and comparison operators like <code class="docutils literal"><span class="pre">==</span></code>
and <code class="docutils literal"><span class="pre">&gt;</span></code>.
The operators,
<code class="docutils literal"><span class="pre">∧</span></code> (AND),
<code class="docutils literal"><span class="pre">V</span></code> (OR),
<code class="docutils literal"><span class="pre">→</span></code> (IMPLY),
<code class="docutils literal"><span class="pre">¬</span></code> (NOT),
are called <em>propositional connectives</em> because they connect together
propositions to make new propositions.
(Example: <code class="docutils literal"><span class="pre">(x</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">∨</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">0)</span> <span class="pre">→</span> <span class="pre">¬</span> <span class="pre">(2x</span> <span class="pre">=</span> <span class="pre">0)</span></code> is a proposition that connects
together <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>, and <code class="docutils literal"><span class="pre">2x</span> <span class="pre">=</span> <span class="pre">0</span></code> with <code class="docutils literal"><span class="pre">¬</span></code>, <code class="docutils literal"><span class="pre">∨</span></code>, and <code class="docutils literal"><span class="pre">→</span></code>.)</p>
<p>Later we will study <code class="docutils literal"><span class="pre">FORALL</span></code> (∀) and
<code class="docutils literal"><span class="pre">EXIST</span></code> (∃), which are more delicate than the
propositional connectives and are called <em>quantifiers</em>.</p>
</div>
<div class="section" id="the-sequent">
<h2>3.2. The Sequent<a class="headerlink" href="#the-sequent" title="Permalink to this headline">¶</a></h2>
<p>Sequent is a mathematical/logical term for assertion.  The notation, <script type="math/tex">p_0, p_1, \ldots, p_m ⊢ q</script></script>
<a href="#id2"><span class="problematic" id="id3">|</span></a>(read as, “<code class="docutils literal"><span class="pre">p0</span></code>, <code class="docutils literal"><span class="pre">p1</span></code>, …, <code class="docutils literal"><span class="pre">pm</span></code> <em>entails</em> <code class="docutils literal"><span class="pre">q</span></code>”) is
a sequent which asserts propositions <code class="docutils literal"><span class="pre">pi</span></code> let us deduce <code class="docutils literal"><span class="pre">q</span></code>.
The <code class="docutils literal"><span class="pre">pi</span></code> are called <em>premises</em> and <code class="docutils literal"><span class="pre">q</span></code> is called the <em>consequent</em>.
For example, <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y,</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">z</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">⊢</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">z</span></code>.
It says, “when premises <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code> and <code class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">z</span> <span class="pre">+</span> <span class="pre">1</span></code> are accepted as facts
(true propositions), then consequent <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> is guaranteed to be a fact as
well.  The <code class="docutils literal"><span class="pre">⊢</span></code> is commonly called the “turnstile” and is read as satisfies,
proves or entails.  It separates what we know to be true from what we
assert can be proven.</p>
<p>Other nomenclatures for sequents include</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>antecedents ⊢ consequences
premises    ⊢ conclusions
P1, ... Pn  ⊢ C1, ... Cm
</pre></div>
</div>
<div class="section" id="validity-of-a-sequent">
<h3>3.2.1. Validity of a Sequent<a class="headerlink" href="#validity-of-a-sequent" title="Permalink to this headline">¶</a></h3>
<p>When multiple premises and conclusions are present they
are treated as a conjunction.  A sequent is said to be <strong>valid</strong> if, for every truth
assignment which make the premises true, the conclusion is also true.</p>
<p>So for the sequent <code class="docutils literal"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span> <span class="pre">,</span> <span class="pre">¬</span> <span class="pre">q</span>&#160; <span class="pre">⊢</span>&#160; <span class="pre">¬</span> <span class="pre">p</span></code>, we can construct a table like this:</p>
<a class="reference internal image-reference" href="../../_images/03-image-10.png"><img alt="../../_images/03-image-10.png" src="../../_images/03-image-10.png" style="width: 354px; height: 157px;" /></a>
<p>where we see that when both premises are true the conclusion is also true.</p>
</div>
<div class="section" id="logika-truth-table-example">
<h3>3.2.2. Logika Truth Table example<a class="headerlink" href="#logika-truth-table-example" title="Permalink to this headline">¶</a></h3>
<p>Logika will not support this type of proof syntax. However, with what was covered
in the natural language to propositional logic lectures and the logic gates of
chapter 2, we can see that this is an application of implication.  We can say the
sequent  <code class="docutils literal"><span class="pre">P1,</span> <span class="pre">P2,</span> <span class="pre">...,</span> <span class="pre">Pn</span>&#160; <span class="pre">⊢</span> <span class="pre">C1,</span> <span class="pre">C2,</span> <span class="pre">...</span> <span class="pre">Cm</span></code> is valid
if the logical formula <code class="docutils literal"><span class="pre">(P1</span> <span class="pre">∧</span> <span class="pre">P2</span> <span class="pre">∧</span> <span class="pre">...</span> <span class="pre">Pn</span> <span class="pre">)</span> <span class="pre">→</span> <span class="pre">(C1</span> <span class="pre">∧</span> <span class="pre">C2</span> <span class="pre">∧</span> <span class="pre">...</span> <span class="pre">Cm</span> <span class="pre">)</span></code> is a tautology.
Re-phrased, IF all the premises are true, THEN all consequences are true.</p>
<div class="highlight-default"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span>                      *
----------------------------
p q | ((p → q) ∧ ¬ q) → ¬p
----------------------------
T T |     T    F F    T F
T F |     F    F T    T F
F T |     T    F F    T T
F F |     T    T T    T T
----------------------------
Tautology
</pre></div>
</td></tr></table></div>
<p>This is discussed in more depth in the section on Soundness and Completeness, which
comes later in this chapter.</p>
<p>Next consider the sequent <code class="docutils literal"><span class="pre">((p</span> <span class="pre">∧</span> <span class="pre">q)</span> <span class="pre">∧</span> <span class="pre">r)</span> <span class="pre">,</span> <span class="pre">s</span> <span class="pre">∧</span> <span class="pre">t</span> <span class="pre">⊢</span> <span class="pre">q</span> <span class="pre">∧</span> <span class="pre">t</span></code>.  Converted to a logic
formula it is  <code class="docutils literal"><span class="pre">(((p</span> <span class="pre">∧</span> <span class="pre">q)</span> <span class="pre">∧</span> <span class="pre">r)</span> <span class="pre">∧</span> <span class="pre">(s</span> <span class="pre">∧</span> <span class="pre">t))</span> <span class="pre">→</span> <span class="pre">(q</span> <span class="pre">∧</span> <span class="pre">t)</span></code>, but this will require 32
rows of truth assignments.  Using inferences rules will allow us to convert this
32-line truth table proof into a 6-line proof.</p>
</div>
</div>
<div class="section" id="inference-rules">
<h2>3.3. Inference Rules<a class="headerlink" href="#inference-rules" title="Permalink to this headline">¶</a></h2>
<p>The propositional connectives are a kind of data-structure language for building
propositional-data-structures from basic, primitive propositions.
For this reason, we must have laws for constructing the propositions and for
disassembling them.
These laws are called <em>inference rules</em> or <em>deduction rules</em>, and a <em>natural
deduction system</em> is a set of inference rules, such that for each connective,
there is a rule for constructing a proposition with a connective (this is called
an <em>introduction rule</em>) and there is a rule for disassembling a proposition with
the connective (this is called an <em>elimination rule</em>).</p>
<p>For the sections that follow, we will review the introduction and elimination
rules for each propositional connective, give examples of their use in proofs,
and describe strategies for applying to rules.
When we present the rules, we will use the letters, <code class="docutils literal"><span class="pre">p</span></code>, <code class="docutils literal"><span class="pre">q</span></code>, <code class="docutils literal"><span class="pre">r</span></code>, …,
to represent propositions (rather than use <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, etc., as propositions).</p>
<p>To prove a sequent is valid,  we must supply a <em>proof</em> to support
the claim using any relevant premises, the inference rules and deduction to
write a formal proof.</p>
</div>
<div class="section" id="logika-proof-syntax">
<h2>3.4. Logika Proof Syntax<a class="headerlink" href="#logika-proof-syntax" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-two-column-proof">
<h3>3.4.1. The Two-Column Proof<a class="headerlink" href="#the-two-column-proof" title="Permalink to this headline">¶</a></h3>
<p>Sequents in Logika have the following form, where premises are separated by commas.</p>
<p><code class="docutils literal"><span class="pre">&lt;0</span> <span class="pre">or</span> <span class="pre">more</span> <span class="pre">premises&gt;</span> <span class="pre">⊢</span> <span class="pre">&lt;</span> <span class="pre">1</span> <span class="pre">consequence&gt;</span></code></p>
<p>Proofs are structured in 2-columns, with facts on the left and their supporting
justificaiton on the right.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>premises ⊢ consequent
{
    1. claim_a     justification_a
    2. claim_b     justification_b
       ...          ...
  736. consequent  justification_ef
}
</pre></div>
</div>
<p>Each fact is given a number, and these claim numbers are generally in order. However, the
only rule is that claim numbers be unique (they may be out of order and/or
non-consecutive).  Also, by convention the consequence is proven on the last
line, but again this is
not strictly required.</p>
<p>Justifications are either:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">type</th>
<th class="head">cases</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>blank</td>
<td>{, }, variable introduction</td>
</tr>
<tr class="row-odd"><td>one-word</td>
<td>“assume”, “premise”</td>
</tr>
<tr class="row-even"><td>rule + claim nos</td>
<td>ex: <code class="docutils literal"><span class="pre">∧i</span> <span class="pre">1</span> <span class="pre">2</span></code>  AND-intro using claims 1 and 2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="scope-and-use-of-subproofs">
<h3>3.4.2. Scope and Use of Subproofs<a class="headerlink" href="#scope-and-use-of-subproofs" title="Permalink to this headline">¶</a></h3>
<p>Sub-proofs are tools for case analysis or what-if excursions, used to support
justification for later claims.  In propositional logic, they will always contain
one assumption. <em>(In prepositional logic, their use will be expanded)</em> This assumption
is a proposition which is “local” to the sub-proof.</p>
<p>As a general rule,  you cannot prove at the end of a sub proof the fact you
assumed at the start.  Assumed facts should be chosen, so that when combined
with existing facts and rules, some other claim can be made at the conclusion
of the sub-proof.</p>
<div class="section" id="scope">
<h4>Scope<a class="headerlink" href="#scope" title="Permalink to this headline">¶</a></h4>
<p>Opening and closing braces (<code class="docutils literal"><span class="pre">{}</span></code>) define the scope of claims.  Other than the
first <code class="docutils literal"><span class="pre">{</span></code> which goes directly under the sequent, the opening brace is given
a claim number, but no justification.  Closing braces are not given claim numbers.
The use of braces is analogous to their use to define scope in Java, C# and C.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>premises ⊢ consequent
{
   1. fact_A     justification_1
       ...          ...
   17. {
            18. fact_ D  assumption
               ...           ...
            25. fact_G   some_rule  using claim 1 // this is ok
               ...           ...
       }
       ...          ...
   45. fact_R    some_rule using claim 25   // this is not ok
}
</pre></div>
</div>
<p>In the example above, the sub-proof starting on line 17, creates an environment
where fact_D is true.  The justification used on claim number 25, which uses claim 1,
is valid.  The scope of claim 1 encloses (includes) sub-proof 17.</p>
<p>However,
the justification for line number 45 is invalid.  Fact_G on line number 25,
was proven true in an environment where fact_D is true (ie sub-proof 17).  That
environment ends, falls out of scope,  when the closing brace for
the sub-proof is reached.  This happens before line 45.</p>
<p>Only specific justifications, or inference rules, allow you to close a scope
and create a new claim based on that sub proof in the enclosing (outer) scope.
These justifications always take a sub-proof (i.e “17”) as justification.</p>
</div>
<div class="section" id="use">
<h4>Use<a class="headerlink" href="#use" title="Permalink to this headline">¶</a></h4>
<p>When a justification requires a sub-proof, the sub-proof is referred to by the
line number of its opening brace (<code class="docutils literal"><span class="pre">{</span></code>), not the line number of the
sub-proof’s concluding claim.</p>
</div>
</div>
</div>
<div class="section" id="the-premise-justification">
<h2>3.5. The premise Justification<a class="headerlink" href="#the-premise-justification" title="Permalink to this headline">¶</a></h2>
<p>Now we will begin introducing inference rules/justifications which allow you to prove a
sequent’s validity through a series of truth preserving operations.  The
most basic is the statement of premises in your proof so they can be used.</p>
<p>As shown below, the claim is just the fact with “premise” as the justification.
All, some or none of the premises can be introduced at any time in any order.
Please note that only one premise may be entered per claim.</p>
<div class="highlight-default"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span>//This is ok
p, q, ¬ r ⊢ p
{
   7. q      premise
   2. p      premise
   4. p      premise
   11. ¬ r   premise
}

//This is also ok
p, q, ¬ r ⊢ p
{
   11. ¬ r   premise
}

// This is wrong
p, q, ¬ r ⊢ p
{
   11.p, q, ¬ r   premise
}
</pre></div>
</td></tr></table></div>
<p>Occasionally you may wish (or need) to restate a claim from an outer proof in a
sub proof.  If the claim you wish to restate is in scope, you may restate the
claim using “premise” as the justification.  This may make your proof more
human readable.</p>
</div>
<div class="section" id="the-assume-justification">
<h2>3.6. The assume Justification<a class="headerlink" href="#the-assume-justification" title="Permalink to this headline">¶</a></h2>
<p>To make an assumption, you must start a new sub-proof and the assumption must
be the first claim in the sub-proof. Any proposition can be assumed. The
propositions <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">¬</span> <span class="pre">q</span> <span class="pre">∨</span> <span class="pre">p</span> <span class="pre">∧</span> <span class="pre">t→</span> <span class="pre">p</span></code> are both valid assumptions. Inside
the sub-proof, the assumed proposition can be treated as a fact.</p>
</div>
<div class="section" id="logical-operator-based-justifications">
<h2>3.7. Logical Operator Based Justifications<a class="headerlink" href="#logical-operator-based-justifications" title="Permalink to this headline">¶</a></h2>
<div class="section" id="syntax">
<h3>3.7.1. Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline">¶</a></h3>
<p>It is a tradition to draw the rules as a kind of “arithmetic sum-up expression”:
when we have proof of the propositions above the horizontal bar, then we deduce
the proposition below the bar.</p>
<p>The less complex rules do not include sub-proofs and have this general format.</p>
<a class="reference internal image-reference" href="../../_images/03-image-20.png"><img alt="../../_images/03-image-20.png" src="../../_images/03-image-20.png" style="width: 697.2px; height: 357.20000000000005px;" /></a>
<p>More complicated rules will involve sub-proofs and typically follow this pattern.
Placeholders will be used to guide you on what must be assumed for each sub-proof.</p>
<a class="reference internal image-reference" href="../../_images/03-image-30.png"><img alt="../../_images/03-image-30.png" src="../../_images/03-image-30.png" style="width: 697.2px; height: 376.40000000000003px;" /></a>
<p>Some important things to keep in mind are:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Capital letters in arithmetic representations are PLACEHOLDERS not variable names.</li>
<li>Only certain rules (those with sub-proofs) let you exit a sub-proof and prove
a new fact based on the sub-proof in the enclosing scope.</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="and-introduction-and-and-elimination">
<h2>3.8. And-Introduction and And-Elimination<a class="headerlink" href="#and-introduction-and-and-elimination" title="Permalink to this headline">¶</a></h2>
<p>It is easy to work with the conjunction connective, <code class="docutils literal"><span class="pre">∧</span></code>.
Clearly, <code class="docutils literal"><span class="pre">p,</span> <span class="pre">q</span> <span class="pre">⊢</span> <span class="pre">p</span> <span class="pre">∧</span> <span class="pre">q</span></code>, that is, when both <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">q</span></code> are facts, then
so is the proposition, <code class="docutils literal"><span class="pre">p</span> <span class="pre">∧</span> <span class="pre">q</span></code>.
Dually, we accept that <code class="docutils literal"><span class="pre">p</span> <span class="pre">∧</span> <span class="pre">q</span> <span class="pre">⊢</span> <span class="pre">p</span></code> as well as <code class="docutils literal"><span class="pre">p</span> <span class="pre">∧</span> <span class="pre">q</span> <span class="pre">⊢</span> <span class="pre">q</span></code>.
Here are the deduction rules that formalize these intuitions:</p>
<div class="section" id="rules">
<h3>3.8.1. Rules<a class="headerlink" href="#rules" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none"><div class="highlight"><pre><span></span>           P
           Q                P ∧ Q              P ∧ Q
∧i :  ---------     ∧e1 : ---------    ∧e2 : ---------
        P ∧ Q                 P                  Q
</pre></div>
</div>
<p>The rules are used to build <em>proofs</em> of new facts from starting facts
(premises).  The examples will explain the exact syntax.</p>
</div>
<div class="section" id="examples">
<h3>3.8.2. Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none"><div class="highlight"><pre><span></span>p, q, r ⊢ r ∧ (q ∧ p)
{
  1. p                    premise
  2. q                    premise
  3. r                    premise
  4. q ∧ p                ∧i 2 1
  5. r ∧ (q ∧ p)          ∧i 3 4
}
</pre></div>
</div>
<p>Read line 4 like this: “from the fact stated on line 2 and the fact stated on
line 1, we deduce <code class="docutils literal"><span class="pre">q</span> <span class="pre">∧</span> <span class="pre">p</span></code> by applying the <code class="docutils literal"><span class="pre">∧i</span></code> law”.
Lines 4 and 5 construct new facts from the starting facts (premises) on
lines 1-3.
A proof generates new knowledge from existing knowledge by using deduction
rules.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>p ∧ (q ∧ r) ⊢  r ∧ p
{
  1. p ∧ (q ∧ r)        premise
  2. p                  ∧e1 1
  3. q ∧ r              ∧e2 1
  4. r                  ∧e2 3
  5. r ∧ p              ∧i 4 2
}
</pre></div>
</div>
<p>The two examples seen so far suggest that a proposition like <code class="docutils literal"><span class="pre">r</span> <span class="pre">∧</span> <span class="pre">p</span></code> is like
a list, <code class="docutils literal"><span class="pre">(r,</span> <span class="pre">p)</span></code>, in C# that we can disassemble by indexing.
The <code class="docutils literal"><span class="pre">∧e</span></code> rule does the indexing, and the <code class="docutils literal"><span class="pre">∧i</span></code>-does the list-building.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>p ⊢ p ∧ p
{
  1. p            premise
  2. p ∧ p        ∧i 1 1
}
</pre></div>
</div>
<p>This example shows you can use a premise multiple times in a proof.</p>
<p>It is easy to prove <code class="docutils literal"><span class="pre">p</span> <span class="pre">∧</span> <span class="pre">q</span> <span class="pre">⊢</span> <span class="pre">p</span></code> (use <code class="docutils literal"><span class="pre">∧e1</span></code>), but we cannot prove
<code class="docutils literal"><span class="pre">p</span> <span class="pre">⊢</span> <span class="pre">p</span> <span class="pre">∧</span> <span class="pre">q</span></code>.
This reminds us that deduction rules develop new knowledge, but the knowledge
might be weaker than the starting facts used to deduce the knowledge.
When we have propositions <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">q</span></code> and we prove both
<code class="docutils literal"><span class="pre">p</span> <span class="pre">⊢</span> <span class="pre">q</span></code> and also <code class="docutils literal"><span class="pre">q</span> <span class="pre">⊢</span> <span class="pre">p</span></code>, we write
<code class="docutils literal"><span class="pre">p</span> <span class="pre">⇔</span> <span class="pre">q</span></code> and say that <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">q</span></code> are equivalent – they hold the
“same amounts of knowledge”.</p>
</div>
<div class="section" id="tactics">
<h3>3.8.3. Tactics<a class="headerlink" href="#tactics" title="Permalink to this headline">¶</a></h3>
<p>A <em>tactic</em> is a useful step towards proving a goal.
The rules for conjunction come with these two tactics, which we rate from
(*) to (***) based on their utility:</p>
<ul>
<li><p class="first">(***) <code class="docutils literal"><span class="pre">∧i</span></code>-tactic: If your task is to prove <code class="docutils literal"><span class="pre">premises</span> <span class="pre">⊢</span> <span class="pre">p</span> <span class="pre">∧</span> <span class="pre">q</span></code>, then</p>
<ol class="arabic simple">
<li>prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">p</span></code></li>
<li>prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">q</span></code></li>
<li>use <code class="docutils literal"><span class="pre">∧i</span></code>.</li>
</ol>
<p>The proof you are building looks like this</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>1. Premises     premise
     (fill in)
i. p
     (fill in)
j. q
k. p ∧  q       ∧i i j
</pre></div>
</div>
</li>
<li><p class="first">(**) <code class="docutils literal"><span class="pre">∧e</span></code>-tactic: If your task is to prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">r</span></code> and you have as
a premise or proved fact in your partial proof, <code class="docutils literal"><span class="pre">p</span> <span class="pre">∧</span> <span class="pre">q</span></code>, then apply <code class="docutils literal"><span class="pre">∧e</span></code>
to extract <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">q</span></code> to use in the proof</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>1. Premises     premise
    . . .
i.   p ∧ q      premise
i+1. p          ∧e1 i
i+2. q          ∧e2 i
      (fill in)
j.   r
</pre></div>
</div>
</li>
</ul>
<p>Let’s apply the tactics to one of the previous examples:</p>
<ol class="arabic">
<li><p class="first">prove <code class="docutils literal"><span class="pre">p</span> <span class="pre">∧</span> <span class="pre">(q</span> <span class="pre">∧</span> <span class="pre">r)</span> <span class="pre">⊢</span> <span class="pre">r∧</span> <span class="pre">p</span></code>: Use the (***)-<code class="docutils literal"><span class="pre">∧i</span></code> tactic to generate two
subgoals, <code class="docutils literal"><span class="pre">p</span> <span class="pre">∧</span> <span class="pre">(q</span> <span class="pre">∧</span> <span class="pre">r)</span> <span class="pre">⊢</span> <span class="pre">r</span></code> and also <code class="docutils literal"><span class="pre">p</span> <span class="pre">∧</span> <span class="pre">(q</span> <span class="pre">∧</span> <span class="pre">r)</span> <span class="pre">⊢</span> <span class="pre">p</span></code></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>1.   p ∧ (q ∧ r)   premises
       (fill in)
i.   r
       (fill in)
j.   P
j+1. r∧ p         ∧i i j
</pre></div>
</div>
</li>
<li><p class="first">Since the (***)-tactic can’t be used on either subgoal, apply the (**)-<code class="docutils literal"><span class="pre">∧e</span></code>-tactic to the premise</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>1.   p ∧ (q ∧ r)   premise
2.   p             ∧e1 1     // (succeeded in proving subgoal, P)
3.   q ∧ r         ∧e2 1
      (fill in)
i.   r
i+1. r∧ p          ∧i i 2
</pre></div>
</div>
</li>
<li><p class="first">We can prove the remaining subgoal by applying the <code class="docutils literal"><span class="pre">∧e</span></code>-tactic once more</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>1.   p ∧ (q ∧ r)   premises
2.   p             ∧e1 1     // (succeeded in proving subgoal, P)
3.   q ∧ r         ∧e2 1
4.   r             ∧e2 3     // (succeeded in proving subgoal, r)
5.   r∧ p          ∧i 4 2
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="logika-tips">
<h3>3.8.4. Logika Tips<a class="headerlink" href="#logika-tips" title="Permalink to this headline">¶</a></h3>
<p>You have to understand the order of precedence for operations.  A former GTA
described is as “seeing the invisible parentheses”.  Consider:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>p ∧ q ∧ r ⊢ r                  p ∧ q ∧ r ⊢ r
{                              {
    1. p ∧ q ∧ r premise          1. p ∧ q ∧ r premise
    2. p  ∧e1 1                   2. r  ∧e2 1
}                              }
// does not work               // works
</pre></div>
</div>
<p>The fact that Logika will not accept line 2 is can be irritating.  One must recall
that <code class="docutils literal"><span class="pre">p</span> <span class="pre">∧</span> <span class="pre">q</span> <span class="pre">∧</span> <span class="pre">r</span></code> is really <code class="docutils literal"><span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">q)</span> <span class="pre">∧</span> <span class="pre">r</span></code> (from the order of precedence), and
thus can be split into <code class="docutils literal"><span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">q)</span> <span class="pre">∧e1</span></code> or <code class="docutils literal"><span class="pre">r</span> <span class="pre">∧e2</span></code>.</p>
</div>
</div>
<div class="section" id="or-introduction-and-or-elimination">
<h2>3.9. Or-Introduction and Or-Elimination<a class="headerlink" href="#or-introduction-and-or-elimination" title="Permalink to this headline">¶</a></h2>
<p>It is a bit trickier reasoning about disjunction, <code class="docutils literal"><span class="pre">∨</span></code>,
because there are multiple meanings of the word in English.
We use the meaning “one or the other or both”.
This causes us to accept the entailments, <code class="docutils literal"><span class="pre">p</span> <span class="pre">⊢</span> <span class="pre">p</span> <span class="pre">∨</span> <span class="pre">q</span></code> and <code class="docutils literal"><span class="pre">q</span> <span class="pre">⊢</span> <span class="pre">p</span> <span class="pre">∨</span> <span class="pre">q</span></code>
(as well as <code class="docutils literal"><span class="pre">p</span> <span class="pre">⊢</span> <span class="pre">p</span> <span class="pre">∨</span> <span class="pre">p</span></code>), which give us the two versions of the <code class="docutils literal"><span class="pre">∨i</span></code>
deduction rule, seen below.</p>
<p>There must also be a rule for applying a fact of form, <code class="docutils literal"><span class="pre">p</span> <span class="pre">∨</span> <span class="pre">q</span></code>, to deduce new
knowledge.
In real life, we call the rule “case analysis”.
For example, say that you have either 4 quarters in your pocket or 10 dimes in
your pocket.
In either case, you can buy a one-dollar coffee.
Why?
You do a case analysis:</p>
<ol class="arabic simple">
<li>In the case you have 4 quarters, that totals a dollar, and you can buy the
coffee;</li>
<li>In the case you have 10 dimes, that totals a dollar, and you can buy the
coffee.</li>
</ol>
<p>So, in both cases, you can buy the coffee. (Actually, the cheapest coffee in
the student union is more like $2.)</p>
<p>This pattern of deduction is formalized in the <code class="docutils literal"><span class="pre">∨e</span></code>-rule below.</p>
<div class="section" id="id4">
<h3>3.9.1. Rules<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none"><div class="highlight"><pre><span></span>                                                      { P assume    { Q assume
         P                  Q                 P ∨ Q     ... R    }    ... R   }
∨i1 : --------    ∨i2 :  --------        ∨e: ------------------------------------
       P ∨ Q              P ∨ Q                              R
</pre></div>
</div>
<div class="sidebar">
<p class="first sidebar-title">Don’t assume what you need to prove</p>
<p class="last">The “fact” you assume only has the scope of the sub-proof. Inside the sub-proof
it is considered to be a fact, outside the sub-proof it may not exist.
Therefore, if you assume the “fact” need to prove, you are almost certainly
wrong.</p>
</div>
<p>The <code class="docutils literal"><span class="pre">∨e</span></code>-rule is the deduction-rule form of case analysis: you assume <code class="docutils literal"><span class="pre">p</span></code>
and do deductions that prove <code class="docutils literal"><span class="pre">r</span></code> and then you assume <code class="docutils literal"><span class="pre">q</span></code> and do another
sequence of deductions to reprove <code class="docutils literal"><span class="pre">r</span></code>.
Each case is a “subproof” that is indented with braces.
Once both cases are proved, you conclude <code class="docutils literal"><span class="pre">r</span></code> no matter what. The introduction and
elimination rules will be expanded on in the next section.</p>
</div>
<div class="section" id="id5">
<h3>3.9.2. Examples<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none"><div class="highlight"><pre><span></span>p ⊢ q ∨ p
{
  1. p              premise
  2. q ∨ p          ∨i2 1
}
</pre></div>
</div>
<p>Perhaps it seems strange to “weaken” fact <code class="docutils literal"><span class="pre">p</span></code> by attaching <code class="docutils literal"><span class="pre">q</span></code> to it.
Yet, we do this all the time.
For example, when we say, “today is Tuesday, so today is a weekday”, we have
weakened “today is Tuesday” to “today is Monday or Tuesday or … or Friday”.
In math, we might have that <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, so we conclude that <code class="docutils literal"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">0</span></code>, that is,
<code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">⊢</span> <span class="pre">(x</span> <span class="pre">&lt;</span> <span class="pre">0)</span> <span class="pre">∨</span> <span class="pre">(x</span> <span class="pre">&gt;</span> <span class="pre">0)</span></code>.</p>
<p>What is more interesting is that proposition <code class="docutils literal"><span class="pre">q</span></code> in the above proof can be any
proposition, and it need not be a true fact (<code class="docutils literal"><span class="pre">p</span></code> is the fact that matters
here).
For example, we can prove <code class="docutils literal"><span class="pre">2</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">⊢</span> <span class="pre">(2</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">∨</span> <span class="pre">(1</span> <span class="pre">==</span> <span class="pre">0)</span></code>.
This sequent is valid, because it is enough that <code class="docutils literal"><span class="pre">2</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">1</span></code> is a fact;
literally, <code class="docutils literal"><span class="pre">1</span> <span class="pre">==</span> <span class="pre">0</span></code> does not matter.</p>
<p>A similar result goes</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>p ∧ q ⊢ p ∨ q
{
  1. p ∧ q        premise
  2. p            ∧e1 1
  3. p ∨ q        ∨i1 2
}
</pre></div>
</div>
<p>For that matter, we reprove this result using <code class="docutils literal"><span class="pre">∧e2</span></code></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>p ∧ q ⊢ p ∨ q
{
  1. p ∧ q        premise
  2. q            ∧e2 1
  3. p ∨ q        ∨i2 2
}
</pre></div>
</div>
<p>We cannot prove <code class="docutils literal"><span class="pre">p</span> <span class="pre">∨</span> <span class="pre">q</span> <span class="pre">⊢</span> <span class="pre">p</span> <span class="pre">∧</span> <span class="pre">q</span></code>, which clearly shows that the <code class="docutils literal"><span class="pre">∨i</span></code> rule
generates “weaker knowledge” from its facts.</p>
<p>Here is a proof that uses case analysis — <code class="docutils literal"><span class="pre">∨e</span></code> — to prove a useful sequent.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>p ∨ q, r ⊢ (p ∧ r) ∨ (q ∧ r)
{
  1. p ∨ q                     premise
  2. r                         premise
  3. {
       4. p                    assume   // (the first case for line 1)
       5. p ∧ r                ∧i 4 2
       6. (p ∧ r) ∨ (q ∧ r)    ∨i1 5
  }
  7. {
       8. q                    assume   // (the second case for line 1)
       9. q ∧ r                ∧i 8 2
       10. (p ∧ r) ∨ (q ∧ r)   ∨i2 9
  }
  11.  (p ∧ r) ∨ (q ∧ r)       ∨e 1 3 7
}
</pre></div>
</div>
<p>Each case — the <code class="docutils literal"><span class="pre">p</span></code> case and the <code class="docutils literal"><span class="pre">q</span></code> case — proved the same fact, so
we conclude that the fact holds no matter what.</p>
<p><em>Both subproofs must prove the same fact</em>, and then the <code class="docutils literal"><span class="pre">∨e</span></code> rule finishes the
proof.
Here, line 11 states that, starting from the cases asserted on line 1, the proof
that <code class="docutils literal"><span class="pre">p</span></code> proves the goal is stated in lines 4-6 and the proof that <code class="docutils literal"><span class="pre">q</span></code>
proves the goal is stated in lines 8-10.</p>
<p>The assumption on line 4 (and the one on line 8) acts like a local variable
inside a function – it can be used only within the function’s body.
This is because the assumption is a what-if premise that is used only for the
sake of discussion of the case.</p>
<p>Finally, here is a simple but vital proof</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>p ∨ p ⊢ p
{
  1. p ∨ p         premise
  2. {
       3. p        assume
  }
  4. {
       5. p        assume
  }
  6. p             ∨e 1 2 4
}
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h3>3.9.3. Tactics<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>There is one good tactic, and one not-so-good:</p>
<ul>
<li><p class="first">(***) <code class="docutils literal"><span class="pre">∨e</span></code>-tactic: To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">r</span></code>, if <code class="docutils literal"><span class="pre">p</span> <span class="pre">∨</span> <span class="pre">q</span></code> appears as a
premise or proved fact in the partial proof, then</p>
<ol class="arabic simple">
<li>prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">p</span> <span class="pre">⊢</span> <span class="pre">r</span></code></li>
<li>prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">q</span> <span class="pre">⊢</span> <span class="pre">r</span></code></li>
<li>use the <code class="docutils literal"><span class="pre">∨e</span></code>-rule to prove <code class="docutils literal"><span class="pre">r</span></code>.</li>
</ol>
<p>The proof is structured like this</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>1. Premises       premise
     . . .
i. p ∨ q
j. {
     k. p         assume
          (fill in)
     l. r
}
m. {
     n. q         assume
          (fill in)
     o. r
}
p. r             ∨e i j m
</pre></div>
</div>
</li>
<li><p class="first">(*) <code class="docutils literal"><span class="pre">∨i</span></code>-tactic: To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">p</span> <span class="pre">∨</span> <span class="pre">q</span></code>, pick either of <code class="docutils literal"><span class="pre">p</span></code> or
<code class="docutils literal"><span class="pre">q</span></code>, and try to prove it.
Finish with <code class="docutils literal"><span class="pre">∨i</span></code></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>1.  Premises     premise
     (fill in)
i.  P
j.  p ∨ q        ∨i1 i
</pre></div>
</div>
</li>
</ul>
<p>If you examine the previous proof example, you see that the proof was
constructed by applying the <code class="docutils literal"><span class="pre">∨e</span></code> tactic, which made possible the use of the
<code class="docutils literal"><span class="pre">∧i</span></code> tactic upon the two subgoals.
The <code class="docutils literal"><span class="pre">∨i</span></code> tactic is used only when it is clear that it will yield progress
towards the goal.</p>
</div>
<div class="section" id="id7">
<h3>3.9.4. Logika Tips<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>Proving the exact same fact means exact.  Proving <code class="docutils literal"><span class="pre">p</span> <span class="pre">∧</span> <span class="pre">r</span></code> in the first subproof
and <code class="docutils literal"><span class="pre">r</span> <span class="pre">∧</span> <span class="pre">p</span></code> in the second will not work.  From the Logika standpoint, these
are different (at least in manual mode).</p>
</div>
</div>
<div class="section" id="implies-introduction-and-implies-elimination">
<h2>3.10. Implies-Introduction and Implies-Elimination<a class="headerlink" href="#implies-introduction-and-implies-elimination" title="Permalink to this headline">¶</a></h2>
<p>Remember that <code class="docutils literal"><span class="pre">→</span></code> is a kind of “logical if-then”.
The word “implies” has several shadings of meaning in spoken English, and there
are also multiple meanings of the word in logic.
Here, we understand <code class="docutils literal"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code> to assert that <code class="docutils literal"><span class="pre">p</span></code> holds knowledge sufficient
to deduce <code class="docutils literal"><span class="pre">q</span></code> – so, whenever <code class="docutils literal"><span class="pre">p</span></code> is proved to be a fact, then <code class="docutils literal"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code>
enables <code class="docutils literal"><span class="pre">q</span></code> to be proved a fact, too.</p>
<p>With this understanding, it is easy to accept that <code class="docutils literal"><span class="pre">p</span></code>, <code class="docutils literal"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span> <span class="pre">⊢</span> <span class="pre">q</span></code>;
this yields the <code class="docutils literal"><span class="pre">→e</span></code> rule.</p>
<p>But there must also be a rule for building propositions of the form,
<code class="docutils literal"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code>.
Say that a family of propositions, <code class="docutils literal"><span class="pre">p</span></code>, <code class="docutils literal"><span class="pre">r</span></code>, <code class="docutils literal"><span class="pre">s</span></code>, <code class="docutils literal"><span class="pre">t</span></code>, … are enough to
prove proposition, <code class="docutils literal"><span class="pre">q</span></code>.
Say we know that <code class="docutils literal"><span class="pre">r</span></code>, <code class="docutils literal"><span class="pre">s</span></code>, <code class="docutils literal"><span class="pre">t</span></code>, … are facts.
Thus, if we only knew that <code class="docutils literal"><span class="pre">p</span></code> was a fact, too, then we would have <code class="docutils literal"><span class="pre">q</span></code> as a
fact.
In this sense, <code class="docutils literal"><span class="pre">r</span></code>, <code class="docutils literal"><span class="pre">s</span></code>, <code class="docutils literal"><span class="pre">t</span></code>, … <em>are enough to prove that</em> <code class="docutils literal"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code>
<em>is a fact</em>.</p>
<p>Stated more precisely, the situation where <code class="docutils literal"><span class="pre">p,</span> <span class="pre">r,</span> <span class="pre">s,</span> <span class="pre">t,</span> <span class="pre">...</span> <span class="pre">⊢</span> <span class="pre">q</span></code> lets us
conclude that <code class="docutils literal"><span class="pre">r,</span> <span class="pre">s,</span> <span class="pre">t,</span> <span class="pre">...</span> <span class="pre">⊢</span> <span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code>.
These two ideas, which go hand in hand, are formalized below.</p>
<div class="section" id="id8">
<h3>3.10.1. Rules<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none"><div class="highlight"><pre><span></span>       { P assume                   P → Q
         ... Q    }                 P
→i : --------------       →e :  ------------
          P → Q                       Q
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">→i</span></code>-rule is a case analysis – it says, consider the case when <code class="docutils literal"><span class="pre">p</span></code> is
a fact.
(We don’t know this for certain; it is a case/possibility we want to discuss.)
If assuming <code class="docutils literal"><span class="pre">p</span></code> (plus using other facts we already have) leads to a proof of
<code class="docutils literal"><span class="pre">q</span></code>, then we conclude that <code class="docutils literal"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code> is a fact.</p>
</div>
<div class="section" id="id9">
<h3>3.10.2. Examples<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>Here are two simple uses of <code class="docutils literal"><span class="pre">→e</span></code></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>(p ∧ q) → r,  p → q,  p  ⊢  r
{
  1. (p ∧ q) → r           premise
  2. p                     premise
  3. p → q                 premise
  4. q                     →e 3 2
  5. p ∧ q                 ∧i 2 4
  6. r                     →e 1 5
}
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre><span></span>(p ∨ q) → r,  q ⊢  r
{
  1. (p ∨ q) → r           premise
  2. q                     premise
  3. p ∨ q                 ∨i2 2
  4. r                     →e 1 3
}
</pre></div>
</div>
<p>Here is an example that uses <code class="docutils literal"><span class="pre">→i</span></code></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>p, (q ∧ p) → r  ⊢  q → r
{
  1. p                      premise
  2. (q ∧ p) → r            premise
  3. {
       4. q                 assume
       5. q ∧ p             ∧i 4 1
       6. r                 →e 2 5
  }
  7. q → r                  →i 3
}
</pre></div>
</div>
<p>The proof includes the case that, when <code class="docutils literal"><span class="pre">q</span></code> is assumed a fact then <code class="docutils literal"><span class="pre">r</span></code> would
follow as a fact, too.
The subproof lets us conclude that <code class="docutils literal"><span class="pre">q</span> <span class="pre">→</span> <span class="pre">r</span></code> is a fact.</p>
<p>Here, two if-then facts entail a third one</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>p → q,  q → r  ⊢ p → r
{
  1. p → q      premise
  2. q → r      premise
  3. {
       4.  p     assume
       5.  q     →e 1 4
       6.  r     →e 2 5
  }
  7. p → r       →i 3
}
</pre></div>
</div>
<p>Notice how we assumed <code class="docutils literal"><span class="pre">p</span></code> to move the proof forwards to a proof of <code class="docutils literal"><span class="pre">r</span></code>.
We employ a similar tactic in this example</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>p → (q → r) ⊢  (q ∧ p) →  r
{
  1. p → (q → r)      premise
  2. {
       3. q ∧ p       assume
       4. p           ∧e2 3
       5. q → r       →e 1 4
       6. q           ∧e1 3
       7. r           →e 5 6
  }
  8. (q ∧ p) →  r     →i 2
}
</pre></div>
</div>
<p>It is possible to nest cases-analyses, as in this crucial example</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>p → r,  q → r  ⊢  (p ∨ q) → r

{
  1. p → r             premise
  2. q → r             premise
  3. {
       4. p ∨ q        assume
       5. {
            6. p       assume
            7. r       →e 1 6
       }
       8. {
            9.  q      assume
            10. r      →e 2 9
       }
       11. r           ∨e 4 5 8
  }
  12. (p ∨ q) → r     →i 3
}
</pre></div>
</div>
<p>Here, the “or reasoning” is nested inside the “implies reasoning”.
This example shows how mastery of basic deduction rules allows one to reason far
more precisely than ordinary people do in real life.</p>
</div>
<div class="section" id="id10">
<h3>3.10.3. Tactics<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>Implication comes with two good tactics:</p>
<ul>
<li><p class="first">(***) <code class="docutils literal"><span class="pre">→i</span></code>-tactic: To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code>,</p>
<ol class="arabic simple">
<li>assume <code class="docutils literal"><span class="pre">p</span></code></li>
<li>prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">p</span> <span class="pre">⊢</span> <span class="pre">q</span></code></li>
<li>use <code class="docutils literal"><span class="pre">→i</span></code>.</li>
</ol>
<p>The proof structure looks like this</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>1.  Premises          premise
       . . .
j.  {
      k.  p           assume
           (fill in)
      l.  q
}
m.  p → q            →i j
</pre></div>
</div>
</li>
<li><p class="first">(*) <code class="docutils literal"><span class="pre">→e</span></code>-tactic: To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">r</span></code>, if <code class="docutils literal"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code> appears as a
premise or a proved fact in the partial proof, then</p>
<ol class="arabic simple">
<li>prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">p</span></code></li>
<li>use <code class="docutils literal"><span class="pre">→e</span></code> to deduce <code class="docutils literal"><span class="pre">q</span></code></li>
<li>prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">P,</span> <span class="pre">q</span> <span class="pre">⊢</span> <span class="pre">r</span></code>.</li>
</ol>
<p>Here, the tactic is to generate new knowledge that will bring us closer to the
goal, <code class="docutils literal"><span class="pre">r</span></code>.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>1.  Premises      premise
       . . .
i.  p → q
        (fill in)
j.  P
k.  q             →e i j
        (fill in)
k.  r
</pre></div>
</div>
</li>
</ul>
<p>In an earlier proof example, you see an immediate use of the (***)-<code class="docutils literal"><span class="pre">→i</span></code>
tactic to the new subgoal</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>p → (q → r), q ∧ p ⊢ r
</pre></div>
</div>
<p>An easy application of the (**)-<code class="docutils literal"><span class="pre">∧i</span></code> tactic generates this simpler subgoal</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>p → (q → r), q, p ⊢ r
</pre></div>
</div>
<p>and we quickly finish the proof by applying the (*)-<code class="docutils literal"><span class="pre">→e</span></code> tactic twice to
deduce <code class="docutils literal"><span class="pre">r</span></code>.</p>
</div>
</div>
<div class="section" id="negation">
<h2>3.11. Negation<a class="headerlink" href="#negation" title="Permalink to this headline">¶</a></h2>
<p>The word, “not”, has many shadings in English, and this is also true in logic.
We might read <code class="docutils literal"><span class="pre">¬</span> <span class="pre">p</span></code> as saying, “<code class="docutils literal"><span class="pre">p</span></code> is not a fact”, or “the opposite of <code class="docutils literal"><span class="pre">p</span></code>
is a fact”, or “<code class="docutils literal"><span class="pre">p</span></code> can never be a fact”, or “it is impossible for <code class="docutils literal"><span class="pre">p</span></code> to be
a fact”, or “<code class="docutils literal"><span class="pre">p</span></code> is ruled out”, or even “<code class="docutils literal"><span class="pre">p</span></code> is false”.
The choice of deduction rules will decide the precise meaning of <code class="docutils literal"><span class="pre">¬</span> <span class="pre">p</span></code>.
What is clearcut, however, is that whenever we can prove, <code class="docutils literal"><span class="pre">p</span></code> and also <code class="docutils literal"><span class="pre">¬</span> <span class="pre">p</span></code>,
for some proposition, <code class="docutils literal"><span class="pre">p</span></code>, we have a contradiction.
A contradiction states an impossible situation, that is, <code class="docutils literal"><span class="pre">p</span></code> is a fact at the
same time that it is not a fact.
It is a “crash”, “the end of the world (or at least of the proof!)”.</p>
<div class="section" id="id11">
<h3>3.11.1. Rules<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>We use this symbol — <code class="docutils literal"><span class="pre">⊥</span></code> (Logika Symbol: False) — to stand for a
contradiction.
There is an extra rule to deduce you have proved a contradiction</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>        P
        ¬ P
¬ e :  -----------
         ⊥
</pre></div>
</div>
<p>(The name is not ideal, but we will use it anyway.)</p>
<p>If you start from some premises and you prove a contradiction, it means that the
premises disagree with each other.
(For example, from premises <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> and <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">0</span></code> we can deduce
<code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">∧</span> <span class="pre">¬</span> <span class="pre">(x</span> <span class="pre">&gt;</span> <span class="pre">0)</span></code>.
The problem is that the premises disagree about what is true at the start.)</p>
<p>When we encounter a contradiction in real life, we usually “start over” and try
our reasoning again, from a different set of premises.
In logic, contradictions are not only a signal that we should “start over”
(that is, change the premises of the proof we are building), but they are also
useful for finishing a line of logical reasoning where we must consider all
cases, even the impossible ones, that follow from some starting set of premises.</p>
<p>There is a special law for reasoning forwards from an impossible situation —
the <code class="docutils literal"><span class="pre">⊥e</span></code> law — which says, in the case of a contradiction, everything
becomes a fact. (That is, “if <code class="docutils literal"><span class="pre">False</span></code> is a fact, so is everything else!”.)</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>         ⊥
⊥e :  ------  for any proposition, Q, at all
         Q
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h3>3.11.2. Examples<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">⊥e</span></code>-rule works well with case analysis, where we discover that one case
is impossible.
Here is the classic example</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>p ∨ q, ¬ p ⊢ q

{
  1. p ∨ q      premise
  2. ¬ p        premise
  3. {
       4. p     assume
       5. ⊥     ¬e 4 2
       6. q     ⊥e 5
  }
  7. {
       8. q     assume
  }
  9. q          ∨e 1 3 7
}
</pre></div>
</div>
<p>Considering the premise, <code class="docutils literal"><span class="pre">p</span> <span class="pre">∨</span> <span class="pre">q</span></code>, we develop the two-case analysis.
The first case, where <code class="docutils literal"><span class="pre">p</span></code> holds true, is impossible, because it causes a
contradiction.
The <code class="docutils literal"><span class="pre">⊥e</span></code>-rule lets us gracefully prove <code class="docutils literal"><span class="pre">q</span></code> in this “impossible case”.
(You can read lines 4-6 as saying, “in the case when <code class="docutils literal"><span class="pre">p</span></code> might hold true,
there is a contradiction, and in such an impossible situation, we can deduce
whatever we like, so we deduce <code class="docutils literal"><span class="pre">q</span></code> to finish this impossible case”.)</p>
<p>The second case, that <code class="docutils literal"><span class="pre">q</span></code> holds true, is the only realistic case, and it
immediately yields the consequent.
The proof finishes the two-case analysis with a step of <code class="docutils literal"><span class="pre">∨e</span></code>.</p>
<p>In the <code class="docutils literal"><span class="pre">¬e</span></code> rule, the positive (not negated) claim goes first.</p>
<p>Here is another example</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>p → ⊥ ⊢  p → r

{
  1. p → ⊥       premise
  2. {
       3. p      assume
       4. ⊥      →e 1 3
       5. r      ⊥e 4
  }
  6. p → r       →i 2
}
</pre></div>
</div>
<p>The sequent can be read as, “if <code class="docutils literal"><span class="pre">p</span></code> generates a contradiction, then <code class="docutils literal"><span class="pre">p</span></code>
generates anything we want!”.
Here is a more interesting variation</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>¬ p ⊢  p → q

{
  1. ¬ p       premise
  2. {
       3. p    assume
       4. ⊥    ¬e 3 1
       5. q    ⊥e 4
  }
  6. p → q     →i 2
}
</pre></div>
</div>
<p>That is, if <code class="docutils literal"><span class="pre">p</span></code> is impossible, we can make any old if-then claim we want about
would follow if <code class="docutils literal"><span class="pre">p</span></code> somehow became a fact.
(Example: “if I am the president of the U.S., then everyone gets a tax refund of
a million bucks”. It’s a true statement but not so useful, since I am not the
president and will never be.)</p>
</div>
<div class="section" id="tactic">
<h3>3.11.3. Tactic<a class="headerlink" href="#tactic" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>(*) <code class="docutils literal"><span class="pre">⊥</span></code>-tactic: To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">q</span></code>, if <code class="docutils literal"><span class="pre">¬</span> <span class="pre">p</span></code> appears as a premise
or as a proved fact in our partial proof, then<ol class="arabic">
<li>prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">p</span></code></li>
<li>use <code class="docutils literal"><span class="pre">¬</span> <span class="pre">e</span></code> to deduce <code class="docutils literal"><span class="pre">⊥</span></code></li>
<li>use the <code class="docutils literal"><span class="pre">⊥e</span></code>-rule to deduce <code class="docutils literal"><span class="pre">q</span></code>.</li>
</ol>
</li>
</ul>
<p>The structure is</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>1.   Premises     premise
       . . .
i.   ¬ P
      (fill in)
j.   P
k.   ⊥          ¬ e i j
l.   q            ⊥e k
</pre></div>
</div>
<p>In the previous proof example, we see that <code class="docutils literal"><span class="pre">¬</span> <span class="pre">p</span> <span class="pre">⊢</span> <span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code> is proved quickly
once we obtain as a new fact (via an assumption, thanks to the (***)-<code class="docutils literal"><span class="pre">→i</span></code>
tactic!).</p>
</div>
</div>
<div class="section" id="negation-introduction">
<h2>3.12. Negation Introduction<a class="headerlink" href="#negation-introduction" title="Permalink to this headline">¶</a></h2>
<p>Another rule for negation lets us deduce when an assertion is incompatible with
facts we already know.</p>
<p>For example, say that <code class="docutils literal"><span class="pre">q</span></code>, <code class="docutils literal"><span class="pre">r</span></code>, <code class="docutils literal"><span class="pre">s</span></code>, … are some premises that we have
used to prove facts.
Say we add <code class="docutils literal"><span class="pre">p</span></code> to the premise set, but it is incompatible, that is, we prove,
<code class="docutils literal"><span class="pre">q,</span> <span class="pre">r,</span> <span class="pre">s,</span> <span class="pre">...,</span> <span class="pre">p</span> <span class="pre">⊢</span> <span class="pre">⊥</span></code>.
So, in a world where <code class="docutils literal"><span class="pre">q</span></code>, <code class="docutils literal"><span class="pre">r</span></code>, <code class="docutils literal"><span class="pre">s</span></code>, … are facts, <code class="docutils literal"><span class="pre">p</span></code> can never be a
fact – we have <code class="docutils literal"><span class="pre">q,</span> <span class="pre">r,</span> <span class="pre">s,</span> <span class="pre">...</span> <span class="pre">⊢</span> <span class="pre">¬</span> <span class="pre">p</span></code>.</p>
<div class="section" id="rule">
<h3>3.12.1. Rule<a class="headerlink" href="#rule" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none"><div class="highlight"><pre><span></span>       { P assume
         ... ⊥  }
¬ i:   --------------
           ¬ P
</pre></div>
</div>
<p>The rule says that we can discuss the case when <code class="docutils literal"><span class="pre">p</span></code> holds; if a contradiction
results, then it is impossible for <code class="docutils literal"><span class="pre">p</span></code> to ever be a fact – indeed, <code class="docutils literal"><span class="pre">¬</span> <span class="pre">p</span></code> is
the fact that holds.</p>
</div>
<div class="section" id="id13">
<h3>3.12.2. Examples<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none"><div class="highlight"><pre><span></span>p,  q → ¬ p  ⊢  ¬ q

{
  1. p           premise
  2. q → ¬ p     premise
  3. {
       4. q      assume
       5. ¬ p    →e 2 4
       6. ⊥      ¬e 1 5
  }
  7. ¬ q         ¬i 3
}
</pre></div>
</div>
<p>Here, the premises, <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">q</span> <span class="pre">→</span> <span class="pre">¬</span> <span class="pre">p</span></code>, are so strong that <em>it is impossible
for</em> <code class="docutils literal"><span class="pre">q</span></code> <em>to ever be proved as a fact</em>.
(Lines 4-5 show that, if <code class="docutils literal"><span class="pre">q</span></code> ever was proved a fact, it would cause a
contradiction/crash.)
So, <code class="docutils literal"><span class="pre">¬</span> <span class="pre">q</span></code> (“<code class="docutils literal"><span class="pre">q</span></code> is impossible”) is proved, instead.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>p ⊢ ¬ ¬ p

{
  1. p           premise
  2. {
       3. ¬ p    assume
       4. ⊥      ¬e 1 3
  }
  5. ¬ (¬ p)     ¬i 2
}
</pre></div>
</div>
<p>Note that the <code class="docutils literal"><span class="pre">¬</span> <span class="pre">i</span></code> rule is not capable of proving <code class="docutils literal"><span class="pre">¬</span> <span class="pre">¬</span> <span class="pre">p</span> <span class="pre">⊢</span> <span class="pre">p</span></code>.
Indeed, if “it is impossible that it is impossible for <code class="docutils literal"><span class="pre">p</span></code> to be a fact”, does
this mean that <code class="docutils literal"><span class="pre">p</span></code> (is proved to be) a fact?
(Example: Last night, you came home late and used your keys to enter your
apartment.
This morning, you can’t find your keys.
You say, “It’s not that I don’t have my keys!”
But do you have them in hand – do you have the evidence that you have your
keys
In mathematics, there are number problems where people have proved that it is
impossible for there not to be a solution.
But no one yet knows exactly what the solution is!)</p>
<p>These examples support this understanding of <code class="docutils literal"><span class="pre">¬</span> <span class="pre">p</span></code></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">¬</span> <span class="pre">p</span></code> <em>says that</em> “<code class="docutils literal"><span class="pre">p</span></code> <em>is impossible</em>”</div></blockquote>
<p>The three rules, <code class="docutils literal"><span class="pre">⊥e</span></code>, <code class="docutils literal"><span class="pre">¬</span> <span class="pre">i</span></code>, and <code class="docutils literal"><span class="pre">¬</span> <span class="pre">e</span></code>, give the meaning of
“is impossible” to the operator, <code class="docutils literal"><span class="pre">¬</span></code>.</p>
</div>
<div class="section" id="id14">
<h3>3.12.3. Tactic<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>The (***)-<code class="docutils literal"><span class="pre">¬</span> <span class="pre">i</span></code> tactic says, to prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">¬</span> <span class="pre">p</span></code>,</p>
<ol class="arabic simple">
<li>assume <code class="docutils literal"><span class="pre">p</span></code></li>
<li>prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">p</span> <span class="pre">⊢</span> <span class="pre">⊥</span></code></li>
<li>use <code class="docutils literal"><span class="pre">¬</span> <span class="pre">i</span></code></li>
</ol>
<div class="highlight-none"><div class="highlight"><pre><span></span>1. Premises         premises
     . . .
j. {
     k.  p          assume
           (fill in)
     l.  ⊥
}
m. ¬ p                ¬ i j
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">¬</span> <span class="pre">i</span></code>-tactic was used with good success in the previous example.</p>
</div>
</div>
<div class="section" id="proof-by-contradiction">
<h2>3.13. Proof by Contradiction<a class="headerlink" href="#proof-by-contradiction" title="Permalink to this headline">¶</a></h2>
<p>In circuit theory, the not-gate is a “flipper” – it flips low voltage to high
and vice versa.
In integer arithmetic, the negative symbol flips positive ints to negatives and
vice versa.
In these areas, for a datum, <code class="docutils literal"><span class="pre">D</span></code>, the phrase, <code class="docutils literal"><span class="pre">¬</span> <span class="pre">D</span></code>, means the “opposite of”
or the “complement of” <code class="docutils literal"><span class="pre">D</span></code>.</p>
<p>In real life, we use opposites a lot – the opposite of daytime is nighttime,
the opposite of happy is sad, and so on.
We might even say that <code class="docutils literal"><span class="pre">¬</span> <span class="pre">daytime</span></code> equals <code class="docutils literal"><span class="pre">nighttime</span></code>, and so on.
But what is <code class="docutils literal"><span class="pre">¬</span> <span class="pre">raining</span></code>? Does it equal <code class="docutils literal"><span class="pre">sunny</span></code>? <code class="docutils literal"><span class="pre">overcast</span></code>? <code class="docutils literal"><span class="pre">snowing</span></code>?
Some concepts have no natural opposite.</p>
<p>If we work with circuits or similar True/False or “opposite” systems, then we
should be able to prove <code class="docutils literal"><span class="pre">¬</span> <span class="pre">¬</span> <span class="pre">p</span> <span class="pre">⊢</span> <span class="pre">p</span></code>.
Here is the rule that lets us do so:</p>
<div class="section" id="id15">
<h3>3.13.1. Rule<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none"><div class="highlight"><pre><span></span>        { ¬ P assume
          ... ⊥   }
pbc:   ---------------
             P
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">pbc</span></code> (“proof by contradiction”) rule says that, when <code class="docutils literal"><span class="pre">¬</span> <span class="pre">p</span></code> leads to a
contradiction, then we have built a proof of <code class="docutils literal"><span class="pre">p</span></code>.</p>
<p>That is, <em>when</em> “<code class="docutils literal"><span class="pre">p</span></code> <em>is impossible</em>” <em>is impossible</em>, <code class="docutils literal"><span class="pre">pbc</span></code> <em>concludes not
only that</em> “<code class="docutils literal"><span class="pre">p</span></code> <em>is possible</em>” <em>but that</em> “<code class="docutils literal"><span class="pre">p</span></code> <em>is a certainty</em>” –
<em>a fact</em>.</p>
<p>In a sense, <code class="docutils literal"><span class="pre">pbc</span></code> builds “something from nothing” – a “proof” of “fact” <code class="docutils literal"><span class="pre">p</span></code>
from an argument that says <code class="docutils literal"><span class="pre">¬</span> <span class="pre">p</span></code> leads to an impossible situation.
But does this mean we have “built” <code class="docutils literal"><span class="pre">p</span></code>?
In a world where the word “not” means the “opposite of”, we have.</p>
</div>
<div class="section" id="id16">
<h3>3.13.2. Examples<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none"><div class="highlight"><pre><span></span>¬ ¬ p ⊢ p

{
  1. ¬ ¬ p       premise
  2. {
       3. ¬ p    assume
       4. ⊥      ¬e 3 1
  }
  5. p           pbc 2
}
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre><span></span>¬ (¬ p ∨ ¬ q)  ⊢ p ∧ q

{
  1. ¬ (¬ p ∨ ¬ q)    premise
  2. {
       3. ¬ p         assume
       4. ¬ p ∨ ¬ q   ∨i1 3
       5. ⊥           ¬e 4 1
  }
  6. p                pbc 2
  7. {
       8.  ¬ q        assume
       9.  ¬ p ∨ ¬ q  ∨i2 8
       10. ⊥          ¬e 9 1
  }
  11.  q              pbc 7
  12.  p ∧ q          ∧i 6 11
}
</pre></div>
</div>
<p>Here is a famous consequence of <code class="docutils literal"><span class="pre">pbc</span></code>: from no starting premises at all, we
can prove <code class="docutils literal"><span class="pre">p</span> <span class="pre">∨</span> <span class="pre">¬</span> <span class="pre">p</span></code> for <em>any proposition we can imagine</em>.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>⊢ p ∨ ¬ p

{
  1. {
       2. ¬ (p ∨ ¬ p)    assume
       3. {
            4. p         assume
            5. p ∨ ¬ p   ∨i1 4
            6. ⊥         ¬e 5 2
       }
       7.  ¬ p           ¬i 3
       8.  p ∨ ¬ p       ∨i2 7
       9.  ⊥             ¬e 8 2
  }
  10. p ∨ ¬ p            pbc 1
}
</pre></div>
</div>
<p>This is sometimes referred to as the law of the excluded middle (LEM) as <code class="docutils literal"><span class="pre">p</span></code>
is either true or false.  There is no third possibility (hence <em>excluded middle</em>).
Now that we have done this proof, say that <code class="docutils literal"><span class="pre">p</span></code> stands for “God has red hair”.
We have this result:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>⊢ &quot;God has red hair&quot; ∨ ¬ (&quot;God has red hair&quot;)
</pre></div>
</div>
<p>Do you accept this?
Perhaps the <code class="docutils literal"><span class="pre">pbc</span></code> rule is not so well suited for deductions in the world of
theology.
A similar example is this one: let <code class="docutils literal"><span class="pre">p</span></code> stand for “I have stopped kicking my
dog”.
(But perhaps I do not even have a pet, let alone ever kicked one!)</p>
<p><code class="docutils literal"><span class="pre">pbc</span></code> constructs “something from nothing”.
This appeals to circuit builders, where <code class="docutils literal"><span class="pre">¬</span></code> and <code class="docutils literal"><span class="pre">∨</span></code> are just gates/on-off
switches, but not always to computer scientists, who like to compute/build data
values and data structures in constructive ways, with algorithms.
For this reason, some logicians (actually, not so many) refuse to accept the
<code class="docutils literal"><span class="pre">pbc</span></code> rule, except in specific circumstances.</p>
<p>Typically, when people accept that <code class="docutils literal"><span class="pre">⊢</span> <span class="pre">p</span> <span class="pre">∨</span> <span class="pre">¬</span> <span class="pre">p</span></code> is a fact, it is because they
are using a decision procedure to answer the question.
When we consider situations that do not have decision procedures, the situation
gets murky, as in the example about the color of God’s hair.</p>
<p>Here is a surprising result, due to <code class="docutils literal"><span class="pre">pbc</span></code></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>p → q ⊢ ¬ p ∨ q

 {
   1. p → q               premise

   2. {                             // start of previous p ∨ ¬ p proof
         3. ¬ (p ∨ ¬ p)   assume
         4. {
              5. p        assume
              6. p ∨ ¬ p  ∨i1 5
              7. ⊥        ¬e 6 3
         }
         8.  ¬ p          ¬i 4
         9.  p ∨ ¬ p      ∨i2 8
         10. ⊥            ¬e 9 3
   }
   11. p ∨ ¬ p            pbc 2    // conclusion of p ∨ ¬ p proof

   12. {
         13. p            assume
         14. q            →e 1 13
         15. ¬ p ∨ q      ∨i2 14
   }
   16. {
         17. ¬ p          assume
         18. ¬ p ∨ q      ∨i1 17
   }
   19. ¬ p ∨ q            ∨e 11 12 16
 }
</pre></div>
</div>
<p>This proof says that the dependency of <code class="docutils literal"><span class="pre">q</span></code> on <code class="docutils literal"><span class="pre">p</span></code> forces us to conclude that
either <code class="docutils literal"><span class="pre">q</span></code> is already a fact or <code class="docutils literal"><span class="pre">p</span></code> is impossible.
It is slightly odd that an “if-then” dependency would ensure either of the two
outcomes.
But this is the consequence of <code class="docutils literal"><span class="pre">pbc</span></code>’s ability to build something from nothing.</p>
<p>This result also relies on pbc</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>⊢ (p → q) ∨ (q → P)
</pre></div>
</div>
<p>for <em>any choice whatsover</em> of propositions <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">q</span></code>.
(An example: let <code class="docutils literal"><span class="pre">p</span></code> stand for “It is raining” and <code class="docutils literal"><span class="pre">q</span></code> stand for
“I am the President”.
The above sequent holds true, even though there is no dependency between the two
propositions.
Why is that so?
Is it reasonable?
The claim looks more benign when we restrict <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">q</span></code> to be propositions
about logic gates.
The moral is, certain logic rules are meant for certain application areas, and
the <code class="docutils literal"><span class="pre">pbc</span></code> rule works well in only circuit-theory-like worlds.)</p>
<p>This last result follows because <code class="docutils literal"><span class="pre">pbc</span></code> lets us deduce that
<code class="docutils literal"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span> <span class="pre">⊢</span> <span class="pre">¬</span> <span class="pre">p</span> <span class="pre">∨</span> <span class="pre">q</span></code> – no longer does <code class="docutils literal"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code> tell us that <code class="docutils literal"><span class="pre">p</span></code> gives the
needed knowledge for constructing/deducing <code class="docutils literal"><span class="pre">q</span></code>;
no longer does <code class="docutils literal"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code> tell us that <code class="docutils literal"><span class="pre">q</span></code> physically depends on <code class="docutils literal"><span class="pre">p</span></code>.
Instead, due to <code class="docutils literal"><span class="pre">pbc</span></code>, we must read <code class="docutils literal"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code> as stating a coincidence about
the underlying True/False values of <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">q</span></code>.
For this reason, the <code class="docutils literal"><span class="pre">→</span></code> operator is no longer necessary in a logic that
uses the <code class="docutils literal"><span class="pre">pbc</span></code> rule;
this is why there is no need for an <code class="docutils literal"><span class="pre">→</span></code> gate in circuit theory (you use
<code class="docutils literal"><span class="pre">¬</span> <span class="pre">p</span> <span class="pre">∨</span> <span class="pre">q</span></code> instead).</p>
<p>There is no truly useful tactic for applying the <code class="docutils literal"><span class="pre">pbc</span></code>-rule.
It is indeed a rule of “last resort”, because it says, to try to prove
<code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">p</span></code>, one should assume <code class="docutils literal"><span class="pre">¬</span> <span class="pre">p</span></code> and see if this leads one into a
contradiction, that is, a proof that <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">¬</span> <span class="pre">p</span> <span class="pre">⊢</span> <span class="pre">⊥</span></code>.
This is a kind of logical “wild-goose chase”.
But later in the chapter, we will see how computers can be made to chase after
such geese.</p>
</div>
</div>
<div class="section" id="important-equivalences">
<h2>3.14. Important Equivalences<a class="headerlink" href="#important-equivalences" title="Permalink to this headline">¶</a></h2>
<p>These useful equivalences can be proved with the laws for And and Or:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">p</span> <span class="pre">∨</span> <span class="pre">p</span> <span class="pre">⇔</span> <span class="pre">p</span></code></li>
<li><code class="docutils literal"><span class="pre">p</span> <span class="pre">∧</span> <span class="pre">p</span> <span class="pre">⇔</span> <span class="pre">p</span></code></li>
<li><code class="docutils literal"><span class="pre">p</span> <span class="pre">∨</span> <span class="pre">q</span> <span class="pre">⇔</span> <span class="pre">q</span> <span class="pre">∨</span> <span class="pre">p</span></code></li>
<li><code class="docutils literal"><span class="pre">p</span> <span class="pre">∧</span> <span class="pre">q</span> <span class="pre">⇔</span> <span class="pre">q</span> <span class="pre">∧</span> <span class="pre">p</span></code></li>
<li><code class="docutils literal"><span class="pre">(p</span> <span class="pre">∨</span> <span class="pre">q)</span> <span class="pre">∨</span> <span class="pre">r⇔</span> <span class="pre">p</span> <span class="pre">∨</span> <span class="pre">(q</span> <span class="pre">∨</span> <span class="pre">r)</span></code></li>
<li><code class="docutils literal"><span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">q)</span> <span class="pre">∧</span> <span class="pre">r⇔</span> <span class="pre">p</span> <span class="pre">∧</span> <span class="pre">(q</span> <span class="pre">∧</span> <span class="pre">r)</span></code></li>
<li><code class="docutils literal"><span class="pre">(p</span> <span class="pre">∨</span> <span class="pre">q)</span> <span class="pre">∧</span> <span class="pre">r⇔</span> <span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">r)</span> <span class="pre">∨</span> <span class="pre">(q</span> <span class="pre">∧</span> <span class="pre">r)</span></code></li>
<li><code class="docutils literal"><span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">q)</span> <span class="pre">∨</span> <span class="pre">r⇔</span> <span class="pre">(p</span> <span class="pre">∨</span> <span class="pre">r)</span> <span class="pre">∧</span> <span class="pre">(q</span> <span class="pre">∨</span> <span class="pre">r)</span> <span class="pre">p</span></code></li>
</ul>
<p>If you are an algebraist, you already knew these assertions, which characterize
a distributive lattice.</p>
<p>When we add the rules for implies, we can prove one other key equivalence:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">q)</span> <span class="pre">→</span> <span class="pre">r⇔</span> <span class="pre">p</span> <span class="pre">→</span> <span class="pre">(q</span> <span class="pre">→</span> <span class="pre">r)</span></code></li>
</ul>
<p>When we add the <code class="docutils literal"><span class="pre">¬</span> <span class="pre">e</span></code>, <code class="docutils literal"><span class="pre">⊥e</span></code>, and <code class="docutils literal"><span class="pre">¬</span> <span class="pre">i</span></code> rules, we can also prove:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">¬</span> <span class="pre">(p</span> <span class="pre">∨</span> <span class="pre">q)</span> <span class="pre">⇔</span> <span class="pre">¬</span> <span class="pre">p</span> <span class="pre">∧</span> <span class="pre">¬</span> <span class="pre">q</span></code></li>
<li><code class="docutils literal"><span class="pre">¬</span> <span class="pre">(p</span> <span class="pre">∨</span> <span class="pre">q)</span> <span class="pre">⇔</span> <span class="pre">¬</span> <span class="pre">(¬</span> <span class="pre">p</span> <span class="pre">→</span> <span class="pre">q)</span></code></li>
<li><code class="docutils literal"><span class="pre">(p</span> <span class="pre">→</span> <span class="pre">¬</span> <span class="pre">q)</span> <span class="pre">⇔</span> <span class="pre">¬</span> <span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">q)</span></code></li>
<li><code class="docutils literal"><span class="pre">(p</span> <span class="pre">→</span> <span class="pre">¬</span> <span class="pre">q)</span> <span class="pre">⇔</span> <span class="pre">(¬</span> <span class="pre">P)</span> <span class="pre">∨</span> <span class="pre">q</span></code></li>
<li><code class="docutils literal"><span class="pre">¬</span> <span class="pre">p</span> <span class="pre">⇔</span> <span class="pre">p</span> <span class="pre">→</span> <span class="pre">⊥</span></code></li>
<li><code class="docutils literal"><span class="pre">¬</span> <span class="pre">p</span> <span class="pre">⇔</span> <span class="pre">¬</span> <span class="pre">¬</span> <span class="pre">¬</span> <span class="pre">p</span></code></li>
</ul>
<p>Now we have characterized what algebraists call the Heyting lattices.</p>
<p>If we accept <code class="docutils literal"><span class="pre">pbc</span></code> (or equivalently, we accept <code class="docutils literal"><span class="pre">p</span> <span class="pre">∨</span> <span class="pre">¬</span> <span class="pre">p</span></code> as a fact), then we
have these important results:
(Note, for each equivalence, <code class="docutils literal"><span class="pre">⇔</span></code>, that follows, the first part, stated with
<code class="docutils literal"><span class="pre">⊢</span></code>, can be proved without <code class="docutils literal"><span class="pre">pbc</span></code>, but the reverse direction requires
<code class="docutils literal"><span class="pre">pbc</span></code>.)</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">p</span> <span class="pre">⇔</span> <span class="pre">¬</span> <span class="pre">¬</span> <span class="pre">p</span></code></li>
<li><code class="docutils literal"><span class="pre">p</span> <span class="pre">∧</span> <span class="pre">q</span> <span class="pre">⇔</span> <span class="pre">¬</span> <span class="pre">(¬</span> <span class="pre">p</span> <span class="pre">∨</span> <span class="pre">¬</span> <span class="pre">q)</span></code></li>
<li><code class="docutils literal"><span class="pre">p</span> <span class="pre">∨</span> <span class="pre">q</span> <span class="pre">⇔</span> <span class="pre">¬</span> <span class="pre">(¬</span> <span class="pre">p</span> <span class="pre">∧</span> <span class="pre">¬</span> <span class="pre">q)</span></code></li>
<li><code class="docutils literal"><span class="pre">p</span> <span class="pre">∨</span> <span class="pre">q</span> <span class="pre">⇔</span> <span class="pre">¬</span> <span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code></li>
<li><code class="docutils literal"><span class="pre">¬</span> <span class="pre">p</span> <span class="pre">∨</span> <span class="pre">¬</span> <span class="pre">q</span> <span class="pre">⇔</span> <span class="pre">¬</span> <span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">q)</span></code></li>
<li><code class="docutils literal"><span class="pre">¬</span> <span class="pre">p</span> <span class="pre">∨</span> <span class="pre">q</span> <span class="pre">⇔</span> <span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code></li>
<li><code class="docutils literal"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span> <span class="pre">⇔</span> <span class="pre">¬</span> <span class="pre">q</span> <span class="pre">→</span> <span class="pre">¬</span> <span class="pre">p</span></code></li>
<li><code class="docutils literal"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span> <span class="pre">⇔</span> <span class="pre">¬</span> <span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">¬</span> <span class="pre">q)</span></code></li>
<li><code class="docutils literal"><span class="pre">(B</span> <span class="pre">∧</span> <span class="pre">P)</span> <span class="pre">∨</span> <span class="pre">(¬</span> <span class="pre">B</span> <span class="pre">∧</span> <span class="pre">q)</span> <span class="pre">⇔</span> <span class="pre">(B</span> <span class="pre">→</span> <span class="pre">P)</span> <span class="pre">∧</span> <span class="pre">(¬</span> <span class="pre">B</span> <span class="pre">→</span> <span class="pre">q)</span></code></li>
</ul>
<p>In algebra, the inference rules presented here for <code class="docutils literal"><span class="pre">∧</span></code>, <code class="docutils literal"><span class="pre">∨</span></code>, <code class="docutils literal"><span class="pre">⊥</span></code>, and
<code class="docutils literal"><span class="pre">¬</span></code> define the structure of a Boolean lattice, and the origins of modern
abstract algebra and logic come from George Boole’s attempt to formalize
“what it means” to compute with <code class="docutils literal"><span class="pre">∧</span></code>, <code class="docutils literal"><span class="pre">∨</span></code>, <code class="docutils literal"><span class="pre">¬</span></code>.</p>
</div>
<div class="section" id="models-of-propositional-logic-soundness-and-completeness">
<h2>3.15. Models of Propositional Logic: Soundness and Completeness<a class="headerlink" href="#models-of-propositional-logic-soundness-and-completeness" title="Permalink to this headline">¶</a></h2>
<p>When we say that “<code class="docutils literal"><span class="pre">p</span></code> is a fact”, what does this mean?
Perhaps it means “<code class="docutils literal"><span class="pre">p</span></code> is True”, or “<code class="docutils literal"><span class="pre">p</span></code> is proved”, or “our confidence in
<code class="docutils literal"><span class="pre">p</span></code> is absolute”.</p>
<p>The purpose of this section is to describe ways that we give meaning to
propositions and to show that the deduction rules in this chapter generate new
knowledge that means what we think it means.</p>
<p>The most basic interpretation of propositions is that a proposition means either
True (<code class="docutils literal"><span class="pre">T</span></code>, <code class="docutils literal"><span class="pre">1</span></code>) or False (<code class="docutils literal"><span class="pre">F</span></code>, <code class="docutils literal"><span class="pre">0</span></code>).
This is a “circuit theory” interpretation.
In this situation, the meanings of the connectives, <code class="docutils literal"><span class="pre">∧</span></code>, <code class="docutils literal"><span class="pre">∨</span></code>, <code class="docutils literal"><span class="pre">¬</span></code> are
given by the truth tables in the Chapter on <a class="reference internal" href="../02-circuits-truth-tables/index.html#circuits"><span class="std std-ref">Circuits and Truth Tables</span></a>.</p>
<p>Return to the Chapter on <a class="reference internal" href="../02-circuits-truth-tables/index.html#circuits"><span class="std std-ref">Circuits and Truth Tables</span></a> of these notes and review the truth tables for
<code class="docutils literal"><span class="pre">∧</span></code>, <code class="docutils literal"><span class="pre">∨</span></code>, <code class="docutils literal"><span class="pre">¬</span></code>.
A truth table defines how the “inputs” <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">q</span></code> are converted into
“outputs”.
Next, here is the standard truth table for <code class="docutils literal"><span class="pre">→</span></code></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>          *
--------------
 p q |  p → q
--------------
 T T |    T
 T F |    F
 F T |    T
 F F |    T
 -------------
 Contingent:
 - T : [T T] [F T][F F]
 - F : [F T]
</pre></div>
</div>
<p>The table’s last two rows are a bit surprising – indeed, neither <code class="docutils literal"><span class="pre">T</span></code> nor
<code class="docutils literal"><span class="pre">F</span></code> seem exactly correct as outputs here!
Think of <code class="docutils literal"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code> as “the truth of “<code class="docutils literal"><span class="pre">p</span></code> forces the truth of <code class="docutils literal"><span class="pre">q</span></code>”.
So, when <code class="docutils literal"><span class="pre">p</span></code> is <code class="docutils literal"><span class="pre">F</span></code>, then <code class="docutils literal"><span class="pre">q</span></code> is not forced to be anything at all.
This makes <code class="docutils literal"><span class="pre">T</span></code> a reasonable answer for the last two rows of the table.</p>
<p>In a more technical sense, the values in the last two rows connect to our
ability to prove <code class="docutils literal"><span class="pre">¬</span> <span class="pre">p</span> <span class="pre">⊢</span> <span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code> and also <code class="docutils literal"><span class="pre">¬</span> <span class="pre">p</span> <span class="pre">⊢</span> <span class="pre">p</span> <span class="pre">→</span> <span class="pre">¬</span> <span class="pre">q</span></code> –
they relate to our willingness to consider impossible cases (and embrace the
<code class="docutils literal"><span class="pre">⊥e</span></code> rule).</p>
<p>Nonetheless, we see that our understanding of implication as a truth table is
open to discussion.</p>
<p>Recall that we can build a truth table of a compound proposition.
We can do this for any sequent, computing the values of its premises and its
goal.
Here is an example: the sequent <code class="docutils literal"><span class="pre">p,</span> <span class="pre">q</span> <span class="pre">v</span> <span class="pre">r</span>&#160; <span class="pre">⊢</span>&#160; <span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">q)</span> <span class="pre">v</span> <span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">r)</span></code> can be
translated as <code class="docutils literal"><span class="pre">p</span> <span class="pre">∧</span> <span class="pre">(q</span> <span class="pre">v</span> <span class="pre">r)</span> <span class="pre">→</span> <span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">q)</span> <span class="pre">v</span> <span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">r)</span></code> and the following truth
table can be constructed</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>                        *
---------------------------------------------
p  q  r  |  p ∧ (q v r) → (p ∧ q) v (p ∧ r)
--------------------------------------------
T  T  T  |    T    T    T     T    T    T
T  T  F  |    T    T    T     T    T    F
T  F  T  |    T    T    T     F    T    T
T  F  F  |    F    F    T     F    F    F
F  T  T  |    F    T    T     F    F    F
F  T  F  |    F    T    T     F    F    F
F  F  T  |    F    T    T     F    F    F
F  F  F  |    F    F    T     F    F    F
--------------------------------------------
Tautology
</pre></div>
</div>
<p>According to the truth table, <code class="docutils literal"><span class="pre">p</span></code>, <code class="docutils literal"><span class="pre">q</span> <span class="pre">∨</span> <span class="pre">s</span></code> entails
<code class="docutils literal"><span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">q)</span> <span class="pre">∨</span> <span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">r)</span></code>, because, in every row where both <code class="docutils literal"><span class="pre">p</span></code> and also <code class="docutils literal"><span class="pre">q</span> <span class="pre">∨</span> <span class="pre">r</span></code>
compute to <code class="docutils literal"><span class="pre">T</span></code>, then so does <code class="docutils literal"><span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">q)</span> <span class="pre">∨</span> <span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">r)</span></code>.</p>
<p>We can of course use the deduction rules to build a proof of
<code class="docutils literal"><span class="pre">p,</span> <span class="pre">q</span> <span class="pre">∨</span> <span class="pre">r</span> <span class="pre">⊢</span> <span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">q)</span> <span class="pre">∨</span> <span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">r)</span></code>.</p>
<p>Now, we have two questions:</p>
<ol class="arabic simple">
<li><em>soundness</em>: When we use the deduction rules to prove that
<code class="docutils literal"><span class="pre">P1,</span> <span class="pre">P2,</span> <span class="pre">...,</span> <span class="pre">Pn</span> <span class="pre">⊢</span> <span class="pre">q</span></code>, does this mean that the compound truth table also
shows that <code class="docutils literal"><span class="pre">P1,</span> <span class="pre">P2,</span> <span class="pre">...,</span> <span class="pre">Pn</span></code> entails <code class="docutils literal"><span class="pre">q</span></code>?</li>
<li><em>completeness</em>: When we use a compound truth table and calculate that
<code class="docutils literal"><span class="pre">P1,</span> <span class="pre">P2,</span> <span class="pre">...,</span> <span class="pre">Pn</span></code> entails <code class="docutils literal"><span class="pre">q</span></code>, does this mean we can use the deduction
rules to build a proof that <code class="docutils literal"><span class="pre">P1,</span> <span class="pre">P2,</span> <span class="pre">...,</span> <span class="pre">Pn</span> <span class="pre">⊢</span> <span class="pre">q</span></code>?</li>
</ol>
<p>When we use all the inference rules presented in this chapter (that is, <code class="docutils literal"><span class="pre">∧i</span></code>,
<code class="docutils literal"><span class="pre">∧e</span></code>, <code class="docutils literal"><span class="pre">∨i</span></code>, <code class="docutils literal"><span class="pre">∨e</span></code>, <code class="docutils literal"><span class="pre">→i</span></code>, <code class="docutils literal"><span class="pre">→e</span></code>, <code class="docutils literal"><span class="pre">⊥e</span></code>, <code class="docutils literal"><span class="pre">¬</span> <span class="pre">i</span></code>, <code class="docutils literal"><span class="pre">¬</span> <span class="pre">e</span></code>, <code class="docutils literal"><span class="pre">pbc</span></code>)
then the short answer to both questions is “yes”.
The inference rules encode completely all the information within truth tables,
and truth tables decode all the deductions of inference rules.</p>
<p>Because of soundness and completeness, one way to determine whether there is a
proof for a sequent, <code class="docutils literal"><span class="pre">P1,</span> <span class="pre">P2,</span> <span class="pre">...,</span> <span class="pre">Pn</span> <span class="pre">⊢</span> <span class="pre">q</span></code>, is to build its truth table and
see if the truth table tells us whether the claim is true.
If yes, then we know there is a proof.</p>
<p>The reason why truth tables predict existence of proofs is because they are tied
to the <code class="docutils literal"><span class="pre">pbc</span></code> rule.
Say that we are purists and refuse to use the <code class="docutils literal"><span class="pre">pbc</span></code> inference rule.
The set of rules that remain are certainly sound with respect to the truth
tables, but they are not complete.
(For example, a compound truth table shows that <code class="docutils literal"><span class="pre">⊢</span> <span class="pre">p</span> <span class="pre">∨</span> <span class="pre">¬</span> <span class="pre">p</span></code>, but this cannot
be proved without <code class="docutils literal"><span class="pre">pbc</span></code>.)</p>
<p>You might argue that the deduction system lacking <code class="docutils literal"><span class="pre">pbc</span></code> is too weak.
<em>Or, you might argue that our understanding of the meaning of propositions is
incorrect.</em></p>
<p>Additionally, while this brute-force technique is easy to program,
truth tables will fail us when we add the for-all and there-exists
operators to logic.  Other methods (based on the resolution theorem)
can and will be expanded to work with quantifiers.</p>
<p>The point is, meaning goes beyond primitive notions like <code class="docutils literal"><span class="pre">{0,</span> <span class="pre">1}</span></code> and
<code class="docutils literal"><span class="pre">{T,</span> <span class="pre">F}</span></code>, and mathematicians have understood this for about 200 years.
Indeed, there are many different forms of meaning and many different forms of
symbolic logic that deduce assertions with those meanings.</p>
</div>
<div class="section" id="summary-of-rules-and-tactics">
<h2>3.16. Summary of Rules and Tactics<a class="headerlink" href="#summary-of-rules-and-tactics" title="Permalink to this headline">¶</a></h2>
<p>As a general principle, when you are proving a claim:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>s1, s2, ... ⊢ t
</pre></div>
</div>
<p>first look at the connectives within <code class="docutils literal"><span class="pre">t</span></code> and note that you will probably need
the introduction rules for those connectives to assemble the clauses you prove
into <code class="docutils literal"><span class="pre">t</span></code>.
Then, look at the connectives within each of the premises, <code class="docutils literal"><span class="pre">si</span></code>, and note that
you will probably need the elimination rules for those connectives to
disassemble the premises into the primitive propositions needed to assemble into
<code class="docutils literal"><span class="pre">t</span></code>.</p>
<p>To choose the order for using the introduction and elimination rules, think
about the tactics you might use to disassemble the premises and assemble the
goal.
The inference rules in this chapter are reviewed below in the order in which
they should be tactically applied:</p>
<ul>
<li><p class="first">(***) <code class="docutils literal"><span class="pre">∧i</span></code>: use to prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">p</span> <span class="pre">∧</span> <span class="pre">q</span></code>:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>1. Premises     premise
     (fill in)
j. P
     (fill in)
k. q
l. p ∧ q       ∧i j k
</pre></div>
</div>
</li>
<li><p class="first">(***) <code class="docutils literal"><span class="pre">∨e</span></code>-tactic: To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">r</span></code>, if <code class="docutils literal"><span class="pre">p</span> <span class="pre">∨</span> <span class="pre">q</span></code> appears as a
premise or proved fact in the partial proof, then</p>
<ol class="arabic simple">
<li>prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">p</span> <span class="pre">⊢</span> <span class="pre">r</span></code></li>
<li>prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">q</span> <span class="pre">⊢</span> <span class="pre">r</span></code></li>
<li>use the <code class="docutils literal"><span class="pre">∨e</span></code>-rule to prove <code class="docutils literal"><span class="pre">r</span></code>.</li>
</ol>
<p>The proof is structured like this</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>1. Premises          premise
      . . .
j. p ∨ q
k. {
     l. p            assume
         (fill in)
     m. r
}
n. {
     o. q            assume
         (fill in)
     p. r
}
q. r                ∨e j k n
</pre></div>
</div>
</li>
<li><p class="first">(***) <code class="docutils literal"><span class="pre">→i</span></code>: use to prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>1. Premises          premise
     . . .
j. {
     k.  p           assume
          (fill in)
     l.  q
}
m. p → q           →i j
</pre></div>
</div>
</li>
<li><p class="first">(***) <code class="docutils literal"><span class="pre">¬</span> <span class="pre">i</span></code>: use to prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">¬</span> <span class="pre">p</span></code></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>1.  Premises         premises
      . . .
j. {
     k.  p           assume
          (fill in)
     l.  ⊥
}
m. ¬ p                ¬ i j
</pre></div>
</div>
</li>
<li><p class="first">(**) <code class="docutils literal"><span class="pre">∧e</span></code>-tactic: If your task is to prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">r</span></code> and you have as
a premise or proved fact in your partial proof, <code class="docutils literal"><span class="pre">p</span> <span class="pre">∧</span> <span class="pre">q</span></code>, then apply <code class="docutils literal"><span class="pre">∧e</span></code>
to extract <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">q</span></code> to use in the proof</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>1.   Premises      premise
        . . .
i.   p ∧ q
i+1. p             ∧e1 i
i+2. q             ∧e2 i
       (fill in)
j.   r
</pre></div>
</div>
</li>
<li><p class="first">(*) <code class="docutils literal"><span class="pre">→e</span></code>-tactic: To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">r</span></code>, if <code class="docutils literal"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code> appears as a
premise or a proved fact in the partial proof, then</p>
<ol class="arabic simple">
<li>prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">p</span></code></li>
<li>use <code class="docutils literal"><span class="pre">→e</span></code> to deduce <code class="docutils literal"><span class="pre">q</span></code></li>
<li>prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">P,</span> <span class="pre">q</span> <span class="pre">⊢</span> <span class="pre">r</span></code>.</li>
</ol>
<p>Here, the tactic is to generate new knowledge that will bring us closer to the
goal, <code class="docutils literal"><span class="pre">r</span></code></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>1.  Premises      premise
       . . .
i.  p → q
        (fill in)
j.  P
k.  q             →e i,j
        (fill in)
k.  r
</pre></div>
</div>
</li>
<li><p class="first">(*) <code class="docutils literal"><span class="pre">⊥</span></code>-tactic: To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">q</span></code>, if <code class="docutils literal"><span class="pre">¬</span> <span class="pre">p</span></code> appears as a premise
or as a proved fact in our partial proof, then</p>
<ol class="arabic simple">
<li>prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">p</span></code></li>
<li>use <code class="docutils literal"><span class="pre">¬</span> <span class="pre">e</span></code> to deduce <code class="docutils literal"><span class="pre">⊥</span></code></li>
<li>use the <code class="docutils literal"><span class="pre">⊥e</span></code>-rule to deduce <code class="docutils literal"><span class="pre">q</span></code>.</li>
</ol>
<p>The structure is</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>1.   Premises     premise
       . . .
i.   ¬ P
      (fill in)
j.   P
k.   ⊥          ¬ e j i
l.   q            ⊥e k
</pre></div>
</div>
</li>
<li><p class="first">(*) <code class="docutils literal"><span class="pre">∨i</span></code>: use to prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">p</span> <span class="pre">∨</span> <span class="pre">q</span></code></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>1.  Premises     premise
      (fill in)
i.  P
j.  p ∨ q        ∨i1 i
</pre></div>
</div>
</li>
<li><p class="first">() <code class="docutils literal"><span class="pre">pbc</span></code>: use, as a last resort, to try to prove any <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">⊢</span> <span class="pre">p</span></code></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>1.  Premises         premise
      . . .
i. {
     j. ¬ p           assume
         (fill in)
     k. ⊥
}
k. P                 pbc i
</pre></div>
</div>
</li>
</ul>
<hr class="docutils" />
 <p align=right><small><em>
 This note was adapted from David Schmidt's CIS 301, 2008,
 <a href="http://people.cis.ksu.edu/¬ schmidt/301s14/Lectures/5natdedT.html">Chapter 5</a>
 course note.
 </em></small></p>
<p align=right><small><em>
It was updated in 2018 by Dr John Hatcliff and George Lavezzi <br>
to conform with Logika syntax and more closely match <br>
KSU's CIS 301 course as taught in Spring 2018.
</em></small></p></div>
</div>


    </div>
      
  </div>
</div>

  </body>
</html>