
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>8. The Predicate-Logic Quantifiers &mdash; Sireum Logika</title>
    
    <link rel="stylesheet" href="../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootswatch-3.3.4/journal/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sireum.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.3.4/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../_static/logika.ico"/>
    <link rel="top" title="Sireum Logika" href="../../index.html" />
    <link rel="up" title="Logika: Programming Logics" href="../index.html" />
    <link rel="prev" title="7. Applications of Propositional Logic to Program Proving" href="../07-propositional-logic/index.html" />
  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          Logika</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../doc/index.html">Documentation</a></li>
                <li><a href="../index.html">Course Notes</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html"> <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#"> <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">8. The Predicate-Logic Quantifiers</a><ul>
<li><a class="reference internal" href="#the-universal-quantifier-and-its-deduction-rules">8.1. The Universal quantifier and Its Deduction Rules</a><ul>
<li><a class="reference internal" href="#more-examples">8.1.1. More Examples</a></li>
<li><a class="reference internal" href="#tactics-for-the-forall-rules">8.1.2. Tactics for the FORALL-rules</a></li>
<li><a class="reference internal" href="#other-ways-of-proving-propositions-with-the-universal-quantifier">8.1.3. Other Ways of Proving Propositions with The Universal Quantifier</a></li>
<li><a class="reference internal" href="#application-of-the-universal-quantifier-to-programming-functions">8.1.4. Application of The Universal Quantifier to Programming Functions</a></li>
<li><a class="reference internal" href="#application-of-the-universal-quantifier-to-data-structures">8.1.5. Application of The Universal Quantifier to Data Structures</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-existential-quantifier">8.2. The Existential Quantifier</a><ul>
<li><a class="reference internal" href="#the-existential-introduction-rule">8.2.1. The Existential-Introduction Rule</a><ul>
<li><a class="reference internal" href="#exist-introduction-rule">EXIST-Introduction Rule</a></li>
<li><a class="reference internal" href="#the-exist-elimination-rule">The EXIST-Elimination Rule</a></li>
<li><a class="reference internal" href="#standard-examples">Standard Examples</a></li>
<li><a class="reference internal" href="#an-important-example">An Important Example</a></li>
<li><a class="reference internal" href="#domains-and-models">Domains and Models</a></li>
<li><a class="reference internal" href="#tactics-for-the-exist-rules">Tactics for The EXIST-Rules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#applications-of-the-existential-quantifier">8.2.2. Applications of The Existential Quantifier</a></li>
<li><a class="reference internal" href="#the-forwards-assignment-law-uses-an-existential-quantifier">8.2.3. The Forwards Assignment Law Uses an Existential Quantifier</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-law-for-assigning-to-individual-array-elements">8.3. The Law for Assigning to Individual Array Elements</a></li>
<li><a class="reference internal" href="#case-studies">8.4. Case Studies</a><ul>
<li><a class="reference internal" href="#in-place-selection-sort">8.4.1. In-place Selection Sort</a></li>
<li><a class="reference internal" href="#binary-search">8.4.2. Binary Search</a></li>
<li><a class="reference internal" href="#maintaining-a-board-game-programming-by-contract">8.4.3. Maintaining a Board Game: Programming by Contract</a></li>
</ul>
</li>
<li><a class="reference internal" href="#equivalences-in-predicate-logic">8.5. Equivalences in Predicate Logic</a></li>
<li><a class="reference internal" href="#predicate-logic-without-the-existential-quantifier-skolem-functions">8.6. Predicate Logic Without The Existential Quantifier: Skolem Functions</a></li>
<li><a class="reference internal" href="#resolution-theorem-proving-for-predicate-logic">8.7. Resolution Theorem Proving for Predicate Logic</a><ul>
<li><a class="reference internal" href="#conversion-into-clause-form">8.7.1. Conversion into clause form</a></li>
</ul>
</li>
<li><a class="reference internal" href="#soundness-and-completeness-of-deduction-rules">8.8. Soundness and Completeness of Deduction Rules</a><ul>
<li><a class="reference internal" href="#interpretations">8.8.1. Interpretations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary">8.9. Summary</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <br/>
<font color="darkgray">
<big><big><b>
Logika: Programming Logics
</b></big></big>
</font>
<br/>
<font color="black">
<big><big><big><big><b>
8. The Predicate-Logic Quantifiers
</b></big></big></big></big>
</font><div class="section" id="the-predicate-logic-quantifiers">
<span id="predicate-logic"></span><h1>8. The Predicate-Logic Quantifiers<a class="headerlink" href="#the-predicate-logic-quantifiers" title="Permalink to this headline">¶</a></h1>
<p>In the previous chapter, we studied how to combine primitive propositions with
the operators,
<code class="docutils literal"><span class="pre">^</span></code> (math: ∧),
<code class="docutils literal"><span class="pre">v</span></code> (math: ∨),
<code class="docutils literal"><span class="pre">--&gt;</span></code> (math: →), and
<code class="docutils literal"><span class="pre">~</span></code> (math: ¬).
When we wrote propositions like <code class="docutils literal"><span class="pre">(p</span> <span class="pre">^</span> <span class="pre">q)</span> <span class="pre">--&gt;</span> <span class="pre">r</span></code>, we pretended that <code class="docutils literal"><span class="pre">p</span></code>,
<code class="docutils literal"><span class="pre">q</span></code>, and <code class="docutils literal"><span class="pre">r</span></code> stood for complete, primitive statements like &#8220;It is raining&#8221;
or &#8220;<code class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>&#8221;.
We did not try to disassemble <code class="docutils literal"><span class="pre">p</span></code>, <code class="docutils literal"><span class="pre">q</span></code>, and <code class="docutils literal"><span class="pre">r</span></code>.</p>
<p>Now it is time to decompose and analyze primitive propositions in terms of their
&#8220;verbs&#8221; (called <em>predicates</em>) and their &#8220;nouns&#8221; (called <em>individuals</em>).
This leads to predicate logic.</p>
<p>First, some background: When we study a particular &#8220;universe&#8221; or &#8220;domain&#8221;
consisting of &#8220;individuals&#8221;, we make assertions (propositions) about the
individuals in the domain.
Example domains are: the domain of all animals, the domain of U.S. Presidents,
the domain of days-of-the-week, the domain of crayon colors,
the domain of integers, the domain of strings, etc.
We assemble propositions by using the individuals in the domain along with some
<em>predicates</em>.
For example, for the domain of integers, we use predicates like <code class="docutils literal"><span class="pre">==</span></code> and
<code class="docutils literal"><span class="pre">&gt;</span></code>, like this: <code class="docutils literal"><span class="pre">3</span> <span class="pre">&gt;</span> <span class="pre">5</span></code>,  <code class="docutils literal"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">1</span></code>, etc.
(Here, <code class="docutils literal"><span class="pre">3</span></code> and <code class="docutils literal"><span class="pre">5</span></code> are individuals, and <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> are names of
individuals.)
As these examples show, we might also use <em>functions</em>, like <code class="docutils literal"><span class="pre">*</span></code> and <code class="docutils literal"><span class="pre">+</span></code>, to
compute new individuals.</p>
<p>For nonnumeric domains like humans, animals, and objects, predicates are written
in a function-call style, like this: <code class="docutils literal"><span class="pre">hasFourLegs(_)</span></code>, <code class="docutils literal"><span class="pre">isTheMotherOf(_,_)</span></code>,
<code class="docutils literal"><span class="pre">isHuman(_)</span></code>, <code class="docutils literal"><span class="pre">isOlderThan(_,_)</span></code>, etc.
So, if <code class="docutils literal"><span class="pre">Lassie</span></code> is an individual animal, we write <code class="docutils literal"><span class="pre">hasFourLegs(Lassie)</span></code> to
make the proposition, &#8220;Lassie has four legs&#8221;.
Another example is <code class="docutils literal"><span class="pre">isOlderThan(GeorgeWashington,</span> <span class="pre">AbrahamLincoln)</span></code>, which uses
the individuals <code class="docutils literal"><span class="pre">GeorgeWashington</span></code> and <code class="docutils literal"><span class="pre">AbrahamLincoln</span></code>.</p>
<p>Predicate logic has two important new operators that let us write stronger
propositions than what we can do with mere predicates.
These operators are called quantifiers. The quantifers are &#8220;for all&#8221;
(<code class="docutils literal"><span class="pre">FORALL</span></code>; math: ∀), and &#8220;exists&#8221;
(<code class="docutils literal"><span class="pre">EXIST</span></code>; math: ∃).
In this chapter, we will learn to use the quantifiers to reason about data
structures.</p>
<p>The <code class="docutils literal"><span class="pre">FORALL</span></code> quantifier helps us write propositions about all the individuals
in a domain.
Say we consider the domain of animals.
The sentence, &#8220;All humans are mortal&#8221; is written like this:</p>
<div class="highlight-python"><div class="highlight"><pre>FORALLx (isHuman(x) --&gt; isMortal(x))
</pre></div>
</div>
<p>That is, if an individual, <code class="docutils literal"><span class="pre">x</span></code>, is human, then <code class="docutils literal"><span class="pre">x</span></code> is mortal also.
(Notice that dogs like <code class="docutils literal"><span class="pre">Lassie</span></code> are individuals in the domain, but the above
proposition cannot be used to show that <code class="docutils literal"><span class="pre">Lassie</span></code> is mortal, since dogs aren&#8217;t
human.
Sadly, dogs are nonetheless mortal.)</p>
<p>An arithmetic example looks like this: for the domain of ints, &#8220;every value is
less-than-or-equal to its square&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">FORALLn</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>A data-structure example looks like this: For array, <code class="docutils literal"><span class="pre">r</span></code>, we can assert that
every element of <code class="docutils literal"><span class="pre">r</span></code> is positive:</p>
<div class="highlight-python"><div class="highlight"><pre>FORALLi ((i &gt;= 0 ^ i &lt; len(r)) --&gt; r[i] &gt; 0)
</pre></div>
</div>
<p>That is, for every index int, <code class="docutils literal"><span class="pre">i</span></code>, in the range of <code class="docutils literal"><span class="pre">0</span></code> up to (but not
including) <code class="docutils literal"><span class="pre">len(r)</span></code> (the length of <code class="docutils literal"><span class="pre">r</span></code>), the indexed element <code class="docutils literal"><span class="pre">r[i]</span></code> is
greater than <code class="docutils literal"><span class="pre">0</span></code>.
The previous statement is often written in a &#8220;shorthand&#8221; like this:</p>
<div class="highlight-python"><div class="highlight"><pre>FORALL 0 &lt;= i &lt; len(r), r[i] &gt; 0
</pre></div>
</div>
<p>which we later use in many of our programming examples.</p>
<p>The <code class="docutils literal"><span class="pre">EXIST</span></code> quantifier helps us write propositions about specific individuals
in a domain, where the name of the individual is unimportant or unknown.
For example, we can say that <code class="docutils literal"><span class="pre">Lassie</span></code> has a mother like this:</p>
<div class="highlight-python"><div class="highlight"><pre>EXISTx isMotherOf(x, Lassie)
</pre></div>
</div>
<p>(&#8220;There exists some <code class="docutils literal"><span class="pre">x</span></code> such that <code class="docutils literal"><span class="pre">x</span></code> is the mother of <code class="docutils literal"><span class="pre">Lassie</span></code>&#8221;.)
Here is how we write that every individual in the domain has a mother:</p>
<div class="highlight-python"><div class="highlight"><pre>FORALLxEXISTy isMotherOf(y, x)
</pre></div>
</div>
<p>For the domain of integers, we can make assertions like these:</p>
<div class="highlight-python"><div class="highlight"><pre>EXISTx (x * x = x)
EXISTy (y + 2 = 9)
FORALLx (x &gt; 1) --&gt; (EXISTy (y &gt; 0 and y + 1 = x))
</pre></div>
</div>
<p>For array <code class="docutils literal"><span class="pre">r</span></code>, we can say that <code class="docutils literal"><span class="pre">r</span></code> holds at least one negative int like
this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">EXISTi</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">^</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">^</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>(The shorthand version is <code class="docutils literal"><span class="pre">EXIST</span> <span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">len(r),</span> <span class="pre">r[i]</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>.)
Lots more examples will follow.</p>
<p>With the new format of primitive propositions, we can write proofs like before:</p>
<div class="highlight-python"><div class="highlight"><pre>isHuman(Socrates) --&gt; isMortal(Socrates), isHuman(Socrates)  |-  isMortal(Socrates) ^ isHuman(Socrates)

1.   isHuman(Socrates) --&gt; isMortal(Socrates)   premise
2.   isHuman(Socrates)                          premise
3.   isMortal(Socrates)                         --&gt;e 1,2
4.   isMortal(Socrates) ^ isHuman(Socrates)     ^i 3,2
</pre></div>
</div>
<p>But more importantly, we will learn to prove claims like this:</p>
<div class="highlight-python"><div class="highlight"><pre>FORALLx(isHuman(x) --&gt; isMortal(x)),  isHuman(Socrates)  |-  isMortal(Socrates)
</pre></div>
</div>
<div class="section" id="the-universal-quantifier-and-its-deduction-rules">
<h2>8.1. The Universal quantifier and Its Deduction Rules<a class="headerlink" href="#the-universal-quantifier-and-its-deduction-rules" title="Permalink to this headline">¶</a></h2>
<p>Like the other logical operators, <code class="docutils literal"><span class="pre">FORALL</span></code> has an introduction rule and an
elimination rule.
It works best to introduce the rules via examples.
First, here is the most famous claim in logic:</p>
<div class="highlight-python"><div class="highlight"><pre>All humans are mortal.
Socrates is human.
Therefore, Socrates is mortal.
</pre></div>
</div>
<p>We express this ancient claim like this:</p>
<div class="highlight-python"><div class="highlight"><pre>FORALLx (isHuman(x) --&gt; isMortal(x)),  isHuman(Socrates) |- isMortal(Socrates)
</pre></div>
</div>
<p>Clearly, we require a kind of matching/binding rule to prove that the human
individual, <code class="docutils literal"><span class="pre">Socrates</span></code>, is mortal. The rule is <code class="docutils literal"><span class="pre">FORALLe</span></code>
(&#8220;all elimination&#8221;):</p>
<div class="highlight-python"><div class="highlight"><pre>1. FORALLx (isHuman(x) --&gt; isMortal(x))      premise
2. isHuman(Socrates)                         premise
3. isHuman(Socrates) --&gt; isMortal(Socrates)  FORALLe 1
4. isMortal(Socrates)                        --&gt;e 3,2
</pre></div>
</div>
<p>Line 3 shows that the claim on Line 1, <em>which holds for all individuals in the
domain</em>, can apply specifically to <code class="docutils literal"><span class="pre">Socrates</span></code>, an individual member of the
domain.
We use the new knowledge on Line 3 to reach the conclusion on Line 4.</p>
<p><code class="docutils literal"><span class="pre">FORALLe</span></code> tailors a general claim, prefixed by <code class="docutils literal"><span class="pre">FORALLx</span></code>, to any individual
element (who replaces the <code class="docutils literal"><span class="pre">x</span></code>).
We see this in Line 3 above.
Here is the rule&#8217;s schematic:</p>
<div class="highlight-python"><div class="highlight"><pre>         FORALLx P_x
FORALLe: ------------
           P_v        that is, [v/x]P_x,  where  v  is an individual in the domain
</pre></div>
</div>
<p>(Here, <code class="docutils literal"><span class="pre">P_x</span></code> stands for a proposition that contains some occurrences of <code class="docutils literal"><span class="pre">x</span></code>.
Recall that <code class="docutils literal"><span class="pre">[v/x]P_x</span></code> is &#8220;substitution notation&#8221;: substitute <code class="docutils literal"><span class="pre">v</span></code> for
occurrences of <code class="docutils literal"><span class="pre">x</span></code> in <code class="docutils literal"><span class="pre">P_x</span></code>.)
For example, from the premise, <code class="docutils literal"><span class="pre">FORALLi</span> <span class="pre">(i</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&gt;</span> <span class="pre">i)</span></code>, we apply <code class="docutils literal"><span class="pre">FORALLe</span></code> to
deduce <code class="docutils literal"><span class="pre">[3/i](i</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&gt;</span> <span class="pre">i)</span></code>, that is, <code class="docutils literal"><span class="pre">3</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&gt;</span> <span class="pre">3</span></code>.</p>
<p>The other deduction rule, <code class="docutils literal"><span class="pre">FORALLi</span></code> (&#8220;all-introduction&#8221;), deduces propositions
that are prefixed by <code class="docutils literal"><span class="pre">FORALL</span></code>.
Here is a motivating example, in the domain of integers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">FORALLn</span><span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">),</span>  <span class="n">FORALLn</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>  <span class="o">|-</span>  <span class="n">FORALLn</span><span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="o">^</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>That is, we wish to prove that for every possible int, the int is smaller than
its successor and larger than its predecessor.
How do we do this?</p>
<p>Clearly, we will not inspect all of <code class="docutils literal"><span class="pre">...,</span> <span class="pre">-2,</span> <span class="pre">-1,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">...</span></code> and verify that
<code class="docutils literal"><span class="pre">(-2</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">&gt;</span> <span class="pre">-2</span> <span class="pre">^</span> <span class="pre">-2</span> <span class="pre">&lt;</span> <span class="pre">(-2</span> <span class="pre">-</span> <span class="pre">1),</span> <span class="pre">(-1</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">&gt;</span> <span class="pre">-1</span> <span class="pre">^</span> <span class="pre">-1</span> <span class="pre">&lt;</span> <span class="pre">(-1</span> <span class="pre">-</span> <span class="pre">1),</span> <span class="pre">(0</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">^</span> <span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">(0</span> <span class="pre">-</span> <span class="pre">1)</span></code>,
etc.!
Instead, we write a single, generic, general-purpose argument &#8212; a
&#8220;case analysis&#8221; &#8212; that applies to whichever, arbitrary int we would ever
consider.
Let <code class="docutils literal"><span class="pre">a</span></code> stand for the arbitrary int we will discuss.
The case analysis appears in the proof like this:</p>
<div class="highlight-python"><div class="highlight"><pre>FORALLn ((n + 1) &gt; n),  FORALLn (n &gt; (n - 1))  |-  FORALLn ((n + 1) &gt; n ^ n &gt; (n - 1))

1.  FORALLn ((n + 1) &gt; n)                premise
2.  FORALLn (n &gt; (n - 1))                premise
... 3.  a
... 4.  (a + 1) &gt; a                      FORALLe 1
... 5.  a &gt; (a - 1)                      FORALLe 2
... 6.  (a + 1) &gt; a  ^  a &gt; (a - 1)      ^i 4,5
7.  FORALLn ((n + 1) &gt; n ^ n &gt; (n - 1))  FORALLi 3-6
</pre></div>
</div>
<p>Lines 3-6 are the generic argument: let <code class="docutils literal"><span class="pre">a</span></code> be the arbitrary/anybody integer
we discuss.
By Lines 1 and 2, we must have that <code class="docutils literal"><span class="pre">(a</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">&gt;</span> <span class="pre">a</span></code> and that <code class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">(a</span> <span class="pre">-</span> <span class="pre">1)</span></code>.
Line 6 uses <code class="docutils literal"><span class="pre">^i</span></code> to show a has the property <code class="docutils literal"><span class="pre">(a</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">&gt;</span> <span class="pre">a</span> <span class="pre">^</span> <span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">(a</span> <span class="pre">-</span> <span class="pre">1)</span></code>.</p>
<p>Since the argument in Lines 3-6 is not specific to any specific integer, we can
use the argument on <em>all</em> the individual integers &#8211; that is, we can substitute
<code class="docutils literal"><span class="pre">-2</span></code> for <code class="docutils literal"><span class="pre">a</span></code> and the argument holds;
we can substitute <code class="docutils literal"><span class="pre">-1</span></code> for <code class="docutils literal"><span class="pre">a</span></code> and the argument holds;
we can substitute <code class="docutils literal"><span class="pre">0</span></code> for <code class="docutils literal"><span class="pre">a</span></code> and the argument holds; and so on!</p>
<p>Line 7 is justified by the new deduction rule, <code class="docutils literal"><span class="pre">FORALLi</span></code>, which asserts that
the generic case analysis in Lines 3-6 applies to all the individual integers.
Here is the rule&#8217;s schematic:</p>
<div class="highlight-python"><div class="highlight"><pre>         ... a            (a  must be a brand new name)
         ... P_a
FORALLi: ------------
         FORALLx P_x      (That is,  P_x  is  [x/a]P_a.
                           Thus,  a  _does not appear_ in  P_x,  and
                           every premise and assumption visible
                           to  FORALLx P_x   _does not mention_  a)
</pre></div>
</div>
<p>To repeat this important idea: The rule says, to prove a claim of form,
<code class="docutils literal"><span class="pre">FORALLx</span> <span class="pre">P_x</span></code>, we undertake a case analysis:
we prove property <code class="docutils literal"><span class="pre">P_a</span></code> for an <em>arbitrary member</em>, <code class="docutils literal"><span class="pre">a</span></code>, of domain <code class="docutils literal"><span class="pre">D</span></code>.
(Call the element, &#8220;Mister <code class="docutils literal"><span class="pre">a</span></code>&#8221; &#8212; Mister arbitrary &#8212; Mister anybody &#8212;
Mister anonymous).
Since Mister <code class="docutils literal"><span class="pre">a</span></code> is a complete unknown, it stands for &#8220;everyone&#8221; in doman D.
<em>We know that we can substitute whichever domain element</em>, <code class="docutils literal"><span class="pre">d</span></code>, <em>from domain</em>
<code class="docutils literal"><span class="pre">D</span></code> <em>we want into the proof and we get a proof of</em> <code class="docutils literal"><span class="pre">P_d</span></code>.
In this way, we have proofs of <code class="docutils literal"><span class="pre">P</span></code> <em>for all</em> elements of domain <code class="docutils literal"><span class="pre">D</span></code>.</p>
<p>Here is the same idea, used in a proof about a domain of people:
&#8220;Everyone is healthy; everyone is happy.
Therefore, everyone is both healthy and happy&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre>FORALLx isHealthy(x),  FORALLy isHappy(y)  |-  FORALLz(isHealthy(z) ^ isHappy(z))

1. FORALLx isHealthy(x)                 premise
2. FORALLy isHappy(y)                   premise
... 3.  a
... 4.  isHealthy(a)                    FORALLe 1
... 5.  isHappy(a)                      FORALLe 2
... 6.  isHealthy(a) ^ isHappy(a)       ^i 4,5
7. FORALLz(isHealthy(z) ^ isHappy(z))   FORALLi 3-6
</pre></div>
</div>
<p>Say that we have a domain of living beings.
This next example requires nested cases:</p>
<div class="highlight-python"><div class="highlight"><pre>All humans are mortal
All mortals have soul
Therefore, all humans have soul
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>FORALLx (isHuman(x) --&gt;  isMortal(x)),
FORALLy (isMortal(y) --&gt; hasSoul(y))
|-  FORALLx (isHuman(x) --&gt; hasSoul(x))

1. FORALLx (isHuman(x) --&gt; isMortal(x))      premise
2. FORALLy (isMortal(y) --&gt; hasSoul(y))      premise
... 3. a
... ... 4. isHuman(a)                        assumption
... ... 5. isHuman(a) --&gt; isMortal(a)        FORALLe 1
... ... 6. isMortal(a)                       --&gt;e 4,3
... ... 7. isMortal(a) --&gt; hasSoul(a)        FORALLe 2
... ... 8. hasSoul(a)                        --&gt;e 6,5
... 9.  isHuman(a) --&gt; hasSoul(a)            --&gt;i 4-8
10.  FORALLx (isHuman(x) --&gt; hasSoul(x))     FORALLi 3-9
</pre></div>
</div>
<p>Line 3 states that we use <code class="docutils literal"><span class="pre">a</span></code> to stand for an arbitrary individual of the
domain.
Line 4 starts a nested case, which assumes <code class="docutils literal"><span class="pre">a</span></code> is human.
Then we can prove that a has a soul, hence by <code class="docutils literal"><span class="pre">--&gt;i</span></code>,
<code class="docutils literal"><span class="pre">isHuman(a)</span> <span class="pre">--&gt;</span> <span class="pre">hasSoul(a)</span></code>.
Since the outer case is stated in terms of the arbitrary, anonymous individual,
<code class="docutils literal"><span class="pre">a</span></code>, we can finish the proof on Line 10 by <code class="docutils literal"><span class="pre">FORALLi</span></code>.</p>
<p>Here is a last, important example.
Let the domain be the members of one family.
We can prove this truism:</p>
<div class="highlight-python"><div class="highlight"><pre>Every (individual) family member who is healthy is also happy.
Therefore, if all the family members are healthy, then all the members are happy.
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>FORALLx (healthy(x) --&gt; happy(x))  |-  (FORALLy healthy(y)) --&gt; (FORALLx happy(x))

1. FORALLx healthy(x) --&gt; happy(x)              premise
... 2. FORALLy healthy(y)                       assumption
... ... 3. a
... ... 4. healthy(a)                           FORALLe 4
... ... 5. healthy(a) --&gt; happy(a)              FORALLe 1
... ... 6. happy(a)                             --&gt;e 5,4
... 7. FORALL x happy(x)                        FORALLi 3-6
8. (FORALLy healthy(y)) --&gt; (FORALLx happy(x))  --&gt;i 2-7
</pre></div>
</div>
<p>We commence by assuming all the family is healthy (Line 2).
Then, we consider an arbitrary/anonymous family member, <code class="docutils literal"><span class="pre">a</span></code>, and show that
<code class="docutils literal"><span class="pre">healthy(a)</span></code> is a fact (from Line 2).
Then we deduce <code class="docutils literal"><span class="pre">happy(a)</span></code>.
Since <code class="docutils literal"><span class="pre">a</span></code> stands for anyone/everyone in the family, we use <code class="docutils literal"><span class="pre">FORALLi</span></code> to
conclude on Line 7 that all family members are happy.
Line 8 finishes.</p>
<p>Consider the converse claim; is it valid?</p>
<div class="highlight-python"><div class="highlight"><pre>If all the family members are healthy, then all are happy.
Therefore, for every (individual) family member, if (s)he is healthy then
(s)he is also happy.
</pre></div>
</div>
<p>Well, no &#8211; perhaps the family is so close-knit that, if one one family member
is unhealthy; then other, healthy, family members might well be unhappy with
worry.
This is a subtle point, so take a moment and think about it!</p>
<p>Let&#8217;s try to prove the dubious claim and see where we get stuck:</p>
<div class="highlight-python"><div class="highlight"><pre>(FORALLy healthy(y)) --&gt; (FORALLx happy(x)) |-
    FORALLx (healthy(x) --&gt; happy(x))

1. (FORALLy healthy(y)) --&gt; (FORALLx happy(x))  premise
... 2. a                                        assumption
... ... 3. healthy(a)                           assumption     WE ARE TRYING TO PROVE happy(a)?!
4. FORALLy healthy(y)                           FORALLi 2-3??  NO --- WE ARE TRYING TO FINISH
                                                   THE OUTER BLOCK BEFORE THE INNER ONE IS FINISHED!
</pre></div>
</div>
<p>No matter how you might try, you will see that the &#8220;block structure&#8221; of the
proofs warns us when we are making invalid deductions.
It is impossible to prove this claim.</p>
<div class="section" id="more-examples">
<h3>8.1.1. More Examples<a class="headerlink" href="#more-examples" title="Permalink to this headline">¶</a></h3>
<p>We state some standard exercises with <code class="docutils literal"><span class="pre">FORALL</span></code>, where the domains and
predicates are unimportant:</p>
<div class="highlight-python"><div class="highlight"><pre>FORALLx F(x) |- FORALLy F(y)

1. FORALLx F(x)    premise
... 2. a
... 3. F(a)        FORALLe 1
4. FORALLy F(y)    FORALLi 2-3
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>FORALLz (F(z) ^ G(z)  |- (FORALLx F(x)) ^ (FORALLy G(y))

1. FORALLz (F(z) ^ G(z)              premise
... 2.  a
... 3.  F(a) ^ G(z)                  FORALLe 1
... 4.  F(a)                         ^e1 3
5. FORALLx F(x)                      FORALLi 2-4

... 6.  b
... 7.  F(b) ^ G(b)                  FORALLe 1
... 8.  G(b)                         ^e2 7
9. FORALLy F(y)                      FORALLi 6-8

10. (FORALLx F(x)) ^ (FORALLy G(y))  ^i 5,9
</pre></div>
</div>
<p>The earlier example about healthy and happy families illustrates an important
structural relationship between <code class="docutils literal"><span class="pre">FORALL</span></code> and <code class="docutils literal"><span class="pre">--&gt;</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>FORALLx (F(x) --&gt; G(x)) |- (FORALLx F(x)) --&gt; (FORALLx G(x))
</pre></div>
</div>
<p>can be proved, but the converse cannot.</p>
<p>This last one is reasonable but the proof is a bit tricky because of the nested
subproofs:</p>
<div class="highlight-python"><div class="highlight"><pre>FORALLx FORALLy F(x,y)  |-  FORALLy FORALLx F(x,y)

1. FORALLx FORALLy F(x,y)   premise
... 2.  b
... ... 3. a
... ... 4. FORALLy F(a,y)   FORALLe 1
... ... 5. F(a,b)           FORALLe 4
... 6. FORALLx F(x,y)       FORALLi 3-5
7. FORALLy FORALLx F(x,y)   FORALLi 2-6
</pre></div>
</div>
</div>
<div class="section" id="tactics-for-the-forall-rules">
<h3>8.1.2. Tactics for the FORALL-rules<a class="headerlink" href="#tactics-for-the-forall-rules" title="Permalink to this headline">¶</a></h3>
<p>As in the previous chapter, we now give advice as to when to use the <code class="docutils literal"><span class="pre">FORALLi</span></code>
and <code class="docutils literal"><span class="pre">FORALLe</span></code> rules.</p>
<ul>
<li><p class="first">(<a href="#id1"><span class="problematic" id="id2">**</span></a><a href="#id3"><span class="problematic" id="id4">*</span></a>) <code class="docutils literal"><span class="pre">FORALLi</span></code>-tactic:
To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">FORALLx</span> <span class="pre">P_x</span></code>,</p>
<ol class="arabic simple">
<li>assume <code class="docutils literal"><span class="pre">a</span></code>, for a new, anonymous &#8220;Mister <code class="docutils literal"><span class="pre">a</span></code>&#8220;</li>
<li>prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">P_a</span></code></li>
<li>finish with <code class="docutils literal"><span class="pre">FORALLi</span></code>.</li>
</ol>
<p>The proof structure looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre>1.  Premises         premise
... i.  a
         (fill in)
... j.  P_a
k. FORALLx P_x       FORALLi i-j

This tactic was applied in Lines 2-7 of the previous (correct) example
proof.
</pre></div>
</div>
</li>
<li><p class="first">(*) <code class="docutils literal"><span class="pre">FORALLe</span></code>-tactic:
To prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">FORALLx</span> <span class="pre">P_x</span> <span class="pre">|-</span> <span class="pre">Q</span></code>, then for an individual, <code class="docutils literal"><span class="pre">i</span></code>, that
appears in the proof so far, use the <code class="docutils literal"><span class="pre">FORALLe</span></code> rule to deduce the new fact,
<code class="docutils literal"><span class="pre">P_i</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>1.  Premises        premise
2.  FORALLx P_x     premise
  . . .
j.  P_i             FORALLe 2
         (fill in)
k.  Q
</pre></div>
</div>
<p>This tactic should be used only when it is clear that the new fact makes a
significant step forwards to finishing the proof.
Steps 4 and 5 of the previous (correct) example proof used this tactic.</p>
</li>
</ul>
</div>
<div class="section" id="other-ways-of-proving-propositions-with-the-universal-quantifier">
<h3>8.1.3. Other Ways of Proving Propositions with The Universal Quantifier<a class="headerlink" href="#other-ways-of-proving-propositions-with-the-universal-quantifier" title="Permalink to this headline">¶</a></h3>
<p>How do we prove an assertion of the form, <code class="docutils literal"><span class="pre">FORALLx</span> <span class="pre">P_x</span></code>?
We just saw that <code class="docutils literal"><span class="pre">FORALLi</span></code> can do this for any domain whatsoever.
But there are, in fact, three different approaches, depending on the form of
domain we use:</p>
<ul>
<li><p class="first">Approach 1: use conjunctions for a finite domain</p>
<p>Say that the domain we study is a <em>finite set</em>, <code class="docutils literal"><span class="pre">D</span> <span class="pre">=</span> <span class="pre">{e0,</span> <span class="pre">e1,</span> <span class="pre">...,</span> <span class="pre">ek}</span></code>.
(An example domain is the days of the week,
<code class="docutils literal"><span class="pre">{sun,</span> <span class="pre">mon,</span> <span class="pre">tues,</span> <span class="pre">weds,</span> <span class="pre">thurs,</span> <span class="pre">fri,</span> <span class="pre">sat}</span></code>.)</p>
<p>This makes <code class="docutils literal"><span class="pre">FORALLx</span> <span class="pre">P_x</span></code> just an abbreviation itself of this much-longer
assertion:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">P_e0</span> <span class="o">^</span> <span class="n">P_e1</span> <span class="o">^</span> <span class="o">...</span> <span class="o">^</span> <span class="n">P_ek</span>
</pre></div>
</div>
<p>For example, when the domain is the days of the week, the assertion,
<code class="docutils literal"><span class="pre">FORALLd</span> <span class="pre">isBurgerKingDay(d)</span></code>, abbreviates:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">isBurgerKingDay</span><span class="p">(</span><span class="n">sun</span><span class="p">)</span> <span class="o">^</span> <span class="n">isBurgerKingDay</span><span class="p">(</span><span class="n">mon</span><span class="p">)</span> <span class="o">^</span> <span class="n">isBurgerKingDay</span><span class="p">(</span><span class="n">tues</span><span class="p">)</span> <span class="o">^</span> <span class="o">...</span> <span class="o">^</span> <span class="n">isBurgerKingDay</span><span class="p">(</span><span class="n">sat</span><span class="p">)</span>
</pre></div>
</div>
<p>To prove such a <code class="docutils literal"><span class="pre">FORALLx</span> <span class="pre">P_x</span></code> for a finite domain <code class="docutils literal"><span class="pre">D</span></code>, we must prove
<code class="docutils literal"><span class="pre">P_ei</span></code>, for each and every <code class="docutils literal"><span class="pre">ei</span></code> in <code class="docutils literal"><span class="pre">D</span></code>.</p>
<p>We can use this approach when we are analyzing all the elements of a
finite-length array.
Say that array <code class="docutils literal"><span class="pre">r</span></code> has length 4.
We can say that the domain of its indexes is <code class="docutils literal"><span class="pre">{0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3}</span></code>.
So, if we wish to prove that <code class="docutils literal"><span class="pre">FORALL</span> <span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">4,</span> <span class="pre">r[i]</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, we need only
prove that <code class="docutils literal"><span class="pre">r[0]</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">^</span> <span class="pre">r[1]</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">^</span> <span class="pre">r[2]</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">^</span> <span class="pre">r[3]</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
</li>
<li><p class="first">Approach 2: for the domain of nonnegative ints, use mathematical induction</p>
<p>The domain, <code class="docutils literal"><span class="pre">Nat</span> <span class="pre">=</span> <span class="pre">{0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">...</span> <span class="pre">}</span></code> is infinite, so we cannot use the
previous technique to prove properties like <code class="docutils literal"><span class="pre">FORALL</span> <span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0,</span> <span class="pre">(n</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">&gt;</span> <span class="pre">n</span></code> &#8211;
we would have to write separate proofs that
<code class="docutils literal"><span class="pre">0</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&gt;</span> <span class="pre">0,</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&gt;</span> <span class="pre">1,</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&gt;</span> <span class="pre">2,</span> <span class="pre">...</span></code>, forever.
But we <em>can</em> use mathematical induction.
Remember how it works: we write two proofs:</p>
<ul class="simple">
<li><em>basis case</em>: a proof of <code class="docutils literal"><span class="pre">P_0</span></code></li>
<li><em>induction case</em>: a proof of <code class="docutils literal"><span class="pre">P_k</span> <span class="pre">--&gt;</span> <span class="pre">P_k+1</span></code>, where <code class="docutils literal"><span class="pre">k</span></code> is a brand new
variable name</li>
</ul>
<p>(At this point, it would be a very good idea for you to review the Section on
<a class="reference internal" href="../06-loops-invariants-induction/index.html#induction"><span>An Introduction to Mathematical Induction</span></a>.)</p>
<p>There is a variation of mathematical induction that we use when proving loop
invariants of the form, <code class="docutils literal"><span class="pre">FORALL</span> <span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">count,</span> <span class="pre">P_k</span></code>:</p>
<ul>
<li><p class="first">We start with this assertion, at point <code class="docutils literal"><span class="pre">(a)</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>FORALL 0 &lt;= k &lt; 0, P_k
</pre></div>
</div>
<p>This assertion is <em>true</em> because it defines an empty range of integers &#8211;
<em>there are no elements in the domain defined by</em>
<code class="docutils literal"><span class="pre">{k:int</span> <span class="pre">|</span> <span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">^</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">0}</span></code>.
Hence, for <em>all</em> the elements, <code class="docutils literal"><span class="pre">k</span></code>, in the empty domain, we have proved
<a href="#id5"><span class="problematic" id="id6">``</span></a>P_k``(!)
This proves the Basis case.</p>
</li>
<li><p class="first">Using the loop invariant (the induction hypothesis), starting at point
<code class="docutils literal"><span class="pre">(b)</span></code>, we analyze the loop;s body and prove:</p>
<p>P_count</p>
<p>That is, <code class="docutils literal"><span class="pre">P</span></code> holds for the value, <code class="docutils literal"><span class="pre">count</span></code>.
Using <code class="docutils literal"><span class="pre">^i</span></code> we get:</p>
<div class="highlight-python"><div class="highlight"><pre>FORALL 0 &lt;= k &lt; count, P_k  ^  P_count
</pre></div>
</div>
<p>This can be understood as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">P_0</span> <span class="o">^</span> <span class="n">P_1</span> <span class="o">^</span> <span class="n">P_2</span> <span class="o">^</span> <span class="o">...</span> <span class="o">^</span> <span class="n">P_count</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">P_count</span>
</pre></div>
</div>
<p>Based on what we read in Approach 1 earlier, we combine the facts into this
one:</p>
<div class="highlight-python"><div class="highlight"><pre>FORALL 0 &lt;= k &lt; count + 1, P_k
</pre></div>
</div>
<p>Since the loop&#8217;s body ends with the assignment, <code class="docutils literal"><span class="pre">count</span> <span class="pre">=</span> <span class="pre">count</span> <span class="pre">+</span> <span class="pre">1</span></code>, we
recover the loop invariant at point <code class="docutils literal"><span class="pre">(c)</span></code>.
This is the proof of the induction case.</p>
<p>We will see several uses of this approach in the next Section.</p>
</li>
</ul>
</li>
<li><p class="first">Approach 3: for any domain, finite or infinite whatsoever, use the
<code class="docutils literal"><span class="pre">FORALLi</span></code>-law</p>
<p>Finally, we might be using a large domain that is not as organized as the
nonnegatives, <code class="docutils literal"><span class="pre">0,1,2,...</span></code>.
Maybe the domain is the domain of all humans or all the citizens of Peru or
the members of the Republican party or all the objects on Planet Earth.
How can we prove <code class="docutils literal"><span class="pre">FORALL</span> <span class="pre">x</span> <span class="pre">P_x</span></code> for such huge collections?</p>
<p>To prove a claim of form, <code class="docutils literal"><span class="pre">FORALLx</span> <span class="pre">P_x</span></code>, for an arbitrary domain, we
undertake a kind of case analysis: we prove property <code class="docutils literal"><span class="pre">P_a</span></code> for an
<em>arbitrary member</em>, <code class="docutils literal"><span class="pre">a</span></code>, of domain <code class="docutils literal"><span class="pre">D</span></code>.
(Call the element, &#8220;Mister <code class="docutils literal"><span class="pre">a</span></code>&#8221; &#8212; Mister arbitrary &#8212; Mister anybody &#8212;
Mister anonymous).
Since Mister <code class="docutils literal"><span class="pre">a</span></code> is a complete unknown, it stands for &#8220;everyone&#8221; in doman
<code class="docutils literal"><span class="pre">D</span></code>.
<em>We know that we can substitute whichever domain element,</em> <code class="docutils literal"><span class="pre">d</span></code> <em>from domain</em>
<code class="docutils literal"><span class="pre">D</span></code>, <em>we want into the proof and we get a proof of</em> <code class="docutils literal"><span class="pre">P_d</span></code>.
In this way, we have proofs of <code class="docutils literal"><span class="pre">P</span></code> <em>for all</em> elements of domain <code class="docutils literal"><span class="pre">D</span></code>.</p>
<p>This is the idea behind the <code class="docutils literal"><span class="pre">FORALLi</span></code>-rule.</p>
</li>
</ul>
</div>
<div class="section" id="application-of-the-universal-quantifier-to-programming-functions">
<h3>8.1.4. Application of The Universal Quantifier to Programming Functions<a class="headerlink" href="#application-of-the-universal-quantifier-to-programming-functions" title="Permalink to this headline">¶</a></h3>
<p>We have been using the rules for the universal quantifier every time we call a
function.
A function&#8217;s parameter names are like the variables <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> in
<code class="docutils literal"><span class="pre">FORALLx</span></code> and <code class="docutils literal"><span class="pre">FORALLy</span></code>.
Here is an example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">fac</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    { pre    n &gt;= 0</span>
<span class="sd">      post   ans == n!</span>
<span class="sd">      return ans }</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>We saw in the previous chapter that the pre- and post-condition can be combined
into this compound proposition:</p>
<div class="highlight-python"><div class="highlight"><pre>(n &gt;= 0)  --&gt; (fac(n) == n!)
</pre></div>
</div>
<p>which describes <code class="docutils literal"><span class="pre">fac</span></code>&#8216;s behavior in terms of name <code class="docutils literal"><span class="pre">n</span></code>.</p>
<p>But <code class="docutils literal"><span class="pre">n</span></code> is a parameter name that is <em>internal</em> to <code class="docutils literal"><span class="pre">fac</span></code>&#8216;s code.
A more proper specification, one that makes sense to <code class="docutils literal"><span class="pre">fac</span></code>&#8216;s caller, is:</p>
<div class="highlight-python"><div class="highlight"><pre>FORALLn ((n &gt;= 0)  --&gt; (fac(n) == n!))
</pre></div>
</div>
<p>That is, &#8220;for all possible int arguments, if the argument is nonnegative, then
<code class="docutils literal"><span class="pre">fac</span></code> computes the argument&#8217;s factorial&#8221;.</p>
<p>We use this logical propery when we call the function.
Here is the proof of it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">fac</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. FORALLn((n &gt;= 0)  --&gt; (fac(n) == n!))    premise (about  fac )</span>
<span class="sd">  2. 6 &gt;= 0                                   algebra</span>
<span class="sd">  3. (6 &gt;= 0) --&gt; (fac(6) == 6!)              FORALLe 1</span>
<span class="sd">  4. fac(6) == 6!                             --&gt;e 3,2</span>
<span class="sd">  5. x == fac(6)                              premise (the assign law)</span>
<span class="sd">  6. x == 6!                                  subst 4,5 }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">FORALLe</span></code> <em>applies the function&#8217;s logical property to its argument</em>.
The function-call law we learned in the Chapter on <a class="reference internal" href="../05-functions-procedures/index.html#functions-procedures"><span>Functions and Procedures</span></a>
hid the <code class="docutils literal"><span class="pre">FORALL</span></code> &#8211; we weren&#8217;t ready for it yet!
But the universal quantifier is implicit in the description of every function we
call.</p>
<p>When we wrote the coding of <code class="docutils literal"><span class="pre">fac</span></code>, we also built a proof that fac computes and
returns <code class="docutils literal"><span class="pre">n!</span></code>, for input parameter name, <code class="docutils literal"><span class="pre">n</span></code>.
We didn&#8217;t know if <code class="docutils literal"><span class="pre">n</span></code> will equal <code class="docutils literal"><span class="pre">1</span></code> or <code class="docutils literal"><span class="pre">9</span></code> or <code class="docutils literal"><span class="pre">99999</span></code> &#8211; we just call
it <code class="docutils literal"><span class="pre">n</span></code> and work with the name.
This is just a &#8220;Mr. anybody&#8221;, exactly as we have been using in our case analyses
that finish with <code class="docutils literal"><span class="pre">FORALLi</span></code>.
<em>The rule for function building hides the use of</em> <code class="docutils literal"><span class="pre">FORALLi</span></code> &#8211; we were not
ready for it in the <a class="reference internal" href="../05-functions-procedures/index.html#functions-procedures"><span>Functions and Procedures</span></a> chapter.
But writing a function is the same thing as writing a proof that finishes with
<code class="docutils literal"><span class="pre">FORALLi</span></code>.</p>
</div>
<div class="section" id="application-of-the-universal-quantifier-to-data-structures">
<h3>8.1.5. Application of The Universal Quantifier to Data Structures<a class="headerlink" href="#application-of-the-universal-quantifier-to-data-structures" title="Permalink to this headline">¶</a></h3>
<p>A data structure is a container for holding elements from a domain, and we often
use universal quantifiers to write assertions about the data structure and how
to compute upon it.
We use the <code class="docutils literal"><span class="pre">FORALLi</span></code> and <code class="docutils literal"><span class="pre">FORALLe</span></code> rules to reason about the elements that
are inserted and removed from the data structure.</p>
<p>We use arrays (lists) in the examples in this chapter.
First, recall these Python operators for arrays:</p>
<ul>
<li><p class="first">For array <code class="docutils literal"><span class="pre">r</span></code>, <code class="docutils literal"><span class="pre">r.append(e)</span></code> adds element <code class="docutils literal"><span class="pre">e</span></code> to the end of <code class="docutils literal"><span class="pre">r</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="k">print</span> <span class="n">a</span>      <span class="c"># prints  [2, 3, 5, 7]</span>
<span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
<span class="k">print</span> <span class="n">a</span>      <span class="c"># prints  [2, 3, 5, 7, 11]</span>
</pre></div>
</div>
</li>
<li><p class="first">For array <code class="docutils literal"><span class="pre">r</span></code>, <code class="docutils literal"><span class="pre">r[:index]</span></code> computes a new array that is the &#8220;slice&#8221; of
<code class="docutils literal"><span class="pre">r</span></code> up to and not including <code class="docutils literal"><span class="pre">r[index]</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">]</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">c</span><span class="p">[:</span><span class="mi">6</span><span class="p">]</span>
<span class="k">print</span> <span class="n">e</span>      <span class="c"># prints  [2, 3, 5, 7, 11, 13]</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">c</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
<span class="k">print</span> <span class="n">f</span>      <span class="c"># prints []</span>
<span class="k">print</span> <span class="n">c</span>      <span class="c"># prints [2, 3, 5, 7, 11, 13, 17, 19]</span>
</pre></div>
</div>
</li>
<li><p class="first">For array, <code class="docutils literal"><span class="pre">r</span></code>, <code class="docutils literal"><span class="pre">r[index;]</span></code> computes a new array that is the &#8220;slice&#8221; of
<code class="docutils literal"><span class="pre">r</span></code> from <code class="docutils literal"><span class="pre">r[index]</span></code> to the end of <code class="docutils literal"><span class="pre">r</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">]</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
<span class="k">print</span> <span class="n">g</span>      <span class="c"># prints  [11, 13, 17, 19]</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">c</span><span class="p">[:</span><span class="mi">8</span><span class="p">]</span>
<span class="k">print</span> <span class="n">h</span>      <span class="c"># prints []</span>
<span class="k">print</span> <span class="n">c</span>      <span class="c"># prints [2, 3, 5, 7, 11, 13, 17, 19]</span>
</pre></div>
</div>
</li>
</ul>
<p>Here is an example; it is math-induction-like (&#8220;Approach 2&#8221; mentioned earlier).
We outline below how a procedure resets all the elements of an array (list) to
zeros:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">zeroOut</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    { pre  isIntArray(a)</span>
<span class="sd">      post FORALL 0 &lt;= i &lt; len(a),  a[i] == 0 }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">j</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;{ invariant  FORALL 0 &lt;= i &lt; j,  a[i] == 0 }&quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        { assert      FORALL 0 &lt;= i &lt; j,  a[i] == 0   ^  a[j] = 0</span>
<span class="sd">          therefore,  FORALL 0 &lt;= i &lt; j+1,  a[i] == 0    (*) }</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;{ assert  FORALL 0 &lt;= i &lt; j,  a[i] == 0 }&quot;&quot;&quot;</span>
    <span class="c">#END LOOP</span>
   <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   { assert      j == len(a)  ^  (FORALL 0 &lt;= i &lt; len(a),  a[i] == 0)</span>
<span class="sd">     therefore,  FORALL 0 &lt;= i &lt; len(a),  a[i] == 0  }</span>
<span class="sd">   &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>We state that the range of elements from <code class="docutils literal"><span class="pre">0</span></code> up to (and not including) <code class="docutils literal"><span class="pre">j</span></code>
are reset to <code class="docutils literal"><span class="pre">0</span></code> by stating:</p>
<div class="highlight-python"><div class="highlight"><pre>FORALL 0 &lt;= i &lt; j,  a[i] == 0
</pre></div>
</div>
<p>This loop invariant leads to the goal as <code class="docutils literal"><span class="pre">j</span></code> counts through the range of <code class="docutils literal"><span class="pre">0</span></code>
up to the length of array <code class="docutils literal"><span class="pre">a</span></code>.
At the point marked (*), there is an informal use of <code class="docutils literal"><span class="pre">FORALLi</span></code>.
Here is a second, similar example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">doubleArray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;doubleArray builds a new array that holds array  a&#39;s  values *2&quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    {  pre:  isIntArray(a)</span>
<span class="sd">       post: isIntArray(answer)  ^  len(answer) == len(a)</span>
<span class="sd">             ^ FORALL 0 &lt;= i &lt; len(a), answer[i] == 2 * a[i] }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">index</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        {  invariant  isIntArray(answer)  ^  len(answer) == index  ^</span>
<span class="sd">                      FORALL 0 &lt;= i &lt; index, answer[i] == 2 * a[i] }</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot;{  assert:  index != len(a)  ^  invariant }&quot;&quot;&quot;</span>
        <span class="n">answer</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        {  assert:   invariant ^  answer[index] == 2 * a[index]</span>
<span class="sd">           implies:  FORALL 0 &lt;= i &lt; index+1, answer[i] == 2 * a[i]  }</span>
<span class="sd">        &quot;&quot;&quot;</span>   <span class="c"># (see Approach 2)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;{  assert: invariant }&quot;&quot;&quot;</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    {  assert:   index == len(a) ^ invariant</span>
<span class="sd">       implies:  isIntArray(answer)  ^  len(answer) == len(a)</span>
<span class="sd">       implies:  FORALL 0 &lt;= i &lt; len(a),  answer[i] == 2 * a[i]  }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">answer</span>
</pre></div>
</div>
<p>Notice how the postcondition notes that the answer array is the same length as
the parameter array.
This prevents the function&#8217;s code from misbehaving and adding junk to the end of
the answer array.</p>
<p>See the Case Studies for more examples.</p>
</div>
</div>
<div class="section" id="the-existential-quantifier">
<h2>8.2. The Existential Quantifier<a class="headerlink" href="#the-existential-quantifier" title="Permalink to this headline">¶</a></h2>
<p>The existential quantifier, <code class="docutils literal"><span class="pre">EXIST</span></code> (math: ∃), means
&#8220;there exists&#8221; or &#8220;there is&#8221;.
We use this phrase when we do not care about the name of the individual involved
in our claim.
Here are examples:</p>
<div class="highlight-python"><div class="highlight"><pre>There is a mouse in the house:  EXISTm (isMouse(m) ^ inHouse(m))
    (We don&#39;t care about the mouse&#39;s name.)

Someone ate my cookie:   EXISTx ateMyCookie(x)

There is a number that equals its own square:  EXISTn  n == n*n

For every int, there is an int that is smaller:  FORALLx EXISTy y &lt; x
</pre></div>
</div>
<p>If we have a fact about an individual in a domain, we can use the fact to deduce
a fact that begins with an existential quantifier.
For example, if we know that:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">isHuman</span><span class="p">(</span><span class="n">Socrates</span><span class="p">)</span> <span class="o">^</span> <span class="n">isMortal</span><span class="p">(</span><span class="n">Socrates</span><span class="p">)</span>
</pre></div>
</div>
<p>surely we can conclude that:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">EXISTh</span> <span class="p">(</span><span class="n">isHuman</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">^</span> <span class="n">isMortal</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
</pre></div>
</div>
<p>that is, &#8220;there is someone who is human and mortal&#8221;.
The identity of the human is no longer important to us.
In the next section, we see that the <code class="docutils literal"><span class="pre">EXISTi</span></code>-rule makes such deductions.</p>
<div class="section" id="the-existential-introduction-rule">
<h3>8.2.1. The Existential-Introduction Rule<a class="headerlink" href="#the-existential-introduction-rule" title="Permalink to this headline">¶</a></h3>
<p>Often <code class="docutils literal"><span class="pre">EXIST</span></code> is used to &#8220;hide&#8221; secret information.
Consider these Pat Sajack musings from a typical game of Wheel of Fortune:</p>
<ul>
<li><p class="first">Pat thinks: &#8220;There is an &#8216;E&#8217; covered over on Square 14 of the game board&#8221;.
In predicate logic, this can be written:</p>
<div class="highlight-python"><div class="highlight"><pre>isCovered(Square14) ^ holds(Square14,&#39;E&#39;).
</pre></div>
</div>
</li>
<li><p class="first">Pat thinks: &#8220;Wait &#8211; I can&#8217;t say that on TV! Perhaps I can say,
There is a vowel covered on Square 14 of the game board&#8221;.
In predicate logic, this is written:</p>
<div class="highlight-python"><div class="highlight"><pre>isCovered(Square14) ^ (EXISTc isVowel(c) ^ holds(Square14,c)).
</pre></div>
</div>
<p>In this way, Pat does not reveal the letter to the game players and TV
viewers.</p>
</li>
<li><p class="first">Because it isn&#8217;t fair to tell the players which squares hold vowels, Pat
announces on the air,
&#8220;There is a vowel that is still covered on the game board&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre>EXISTs (isSquare(s) ^ isCovered(s) ^ (EXISTc isVowel(c) ^ holds(s,c)))
</pre></div>
</div>
<p>This statement hides the specific square and letter that Pat is thinking
about.</p>
</li>
</ul>
<p>Pat&#8217;s announcement was deduced from its predecessors by means of the
<code class="docutils literal"><span class="pre">EXISTi</span></code>-rule, which we see in a moment.</p>
<p>What can a game player do with Pat&#8217;s uttered statement?
A player might deduce these useful facts:</p>
<ul>
<li><p class="first">There is a square still covered: <code class="docutils literal"><span class="pre">EXISTs</span> <span class="pre">isSquare(s)</span> <span class="pre">^</span> <span class="pre">isCovered(s)</span></code></p>
</li>
<li><p class="first">There is a vowel: <code class="docutils literal"><span class="pre">EXISTc</span> <span class="pre">isVowel(c)</span></code></p>
</li>
<li><p class="first">There is a covered letter, <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">E</span></code>, <code class="docutils literal"><span class="pre">I</span></code>, <code class="docutils literal"><span class="pre">O</span></code>, <code class="docutils literal"><span class="pre">U</span></code> (assuming the
vowels are exactly <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">E</span></code>, <code class="docutils literal"><span class="pre">I</span></code>, <code class="docutils literal"><span class="pre">O</span></code>, <code class="docutils literal"><span class="pre">U</span></code>):</p>
<div class="highlight-python"><div class="highlight"><pre>EXISTs isSquare(s) ^ isCovered(s) ^ (holds(s,&#39;A&#39;) v holds(s,&#39;E&#39;) v holds(s,&#39;I&#39;) v holds(s,&#39;O&#39;) v holds(s,&#39;U&#39;))
</pre></div>
</div>
</li>
</ul>
<p>Although the game player does not know the letter and square that Pat Sajak
&#8220;hid&#8221; with his statement, the player can still make useful deductions.
We will use the <code class="docutils literal"><span class="pre">EXISTe</span></code> rule to deduce these style of propositions.</p>
<div class="section" id="exist-introduction-rule">
<h4>EXIST-Introduction Rule<a class="headerlink" href="#exist-introduction-rule" title="Permalink to this headline">¶</a></h4>
<p>The rule for <code class="docutils literal"><span class="pre">EXISTi</span></code> has this format:</p>
<div class="highlight-python"><div class="highlight"><pre>            P_d         where  d  is an individual in the domain D
EXISTi: ------------
         EXISTx P_x
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">EXISTi</span></code> rule says, if we locate an individual <code class="docutils literal"><span class="pre">d</span></code> (a &#8220;witness&#8221;, as it
is called by logicians) that makes <code class="docutils literal"><span class="pre">P</span></code> true, then surely we can say there
exists <em>someone</em> that has <code class="docutils literal"><span class="pre">P</span></code> and hide the identity of the individual/witness.</p>
<p>The rule was used in the previous section in a tiny example:</p>
<div class="highlight-python"><div class="highlight"><pre>isHuman(Socrates), isMortal(Socrates) |- EXISTh (isHuman(h) ^ isMortal(h))

1. isHuman(Socrates)                        premise
2. isMortal(Socrates)                       premise
3. isHuman(Socrates) ^ isMortal(Socrates)   ^i 1,2
4. EXISTh (isHuman(h) ^ isMortal(h))        EXISTi 3
</pre></div>
</div>
<p>Since <code class="docutils literal"><span class="pre">Socrates</span></code> is an individual that is both human and mortal, we deduce
Line 3.
Line 4 &#8220;hides&#8221; <code class="docutils literal"><span class="pre">Socrates</span></code>&#8216; name.</p>
<p>Let&#8217;s do a Wheel-Of-Fortune example: Pat Sajak uses two premises and the
<code class="docutils literal"><span class="pre">EXISTi</span></code> rule to deduce a new conclusion:</p>
<div class="highlight-python"><div class="highlight"><pre>isVowel(&#39;E&#39;), holds(Square14,&#39;E&#39;) |- EXISTc(isVowel(c) ^ EXISTs holds(s,c))

1. isVowel(&#39;E&#39;)                             premise
2. holds(Square14,&#39;E&#39;)                      premise
3. EXISTs holds(s,&#39;E&#39;)                      EXISTi 2
4. isVowel(&#39;E&#39;) ^ EXISTs holds(s,&#39;E&#39;)       ^i 1,3
5. EXISTc(isVowel(c) ^ EXISTs holds(s,c))   EXISTi 4
</pre></div>
</div>
<p>Line 3 hides the number of the square (&#8220;there is a square that holds &#8216;E&#8217;&#8221;), and
Line 5 hides the &#8216;E&#8217; (&#8220;there is a letter that is a vowel and there is a square
that holds the letter&#8221;).</p>
<p>From the same two premises we can also prove this:</p>
<div class="highlight-python"><div class="highlight"><pre>1. isVowel(&#39;E&#39;)                             premise
2. holds(Square14,&#39;E&#39;)                      premise
3. isVowel(&#39;E&#39;) ^ holds(Square14,&#39;E&#39;)       ^i 1,3
4. EXISTs(isVowel(&#39;E&#39;) ^ holds(s,&#39;E&#39;))      EXISTi 3
5. EXISTcEXISTs(isVowel(s) ^ holds(s,c))    EXISTi 4
</pre></div>
</div>
<p>This reads, &#8220;there are a letter and square such that the letter is a vowel and
the square holds the letter&#8221;.
The proposition differs slightly from the previous one, but the two seem to have
identical information content.
(When we learn the <code class="docutils literal"><span class="pre">EXISTe</span></code>-rule, we can prove the two conclusions have
identical content.)</p>
</div>
<div class="section" id="the-exist-elimination-rule">
<h4>The EXIST-Elimination Rule<a class="headerlink" href="#the-exist-elimination-rule" title="Permalink to this headline">¶</a></h4>
<p>Since the <code class="docutils literal"><span class="pre">EXISTi</span></code>-rule constructs propositions that begin with <code class="docutils literal"><span class="pre">EXIST</span></code>, the
<code class="docutils literal"><span class="pre">EXISTe</span></code>-rule disassembles propositions that begin with <code class="docutils literal"><span class="pre">EXIST</span></code>.
The new rule employs a subtle case analysis.</p>
<p>Here is a quick example (in the universe of things on planet Earth), to get our
bearings:</p>
<div class="highlight-python"><div class="highlight"><pre>All humans are mortal
Someone is human
Therefore, someone is mortal
</pre></div>
</div>
<p>We don&#8217;t know the name of the individual human, but it does not matter &#8211;
we can still conclude someone is mortal.
The steps we will take go like this:</p>
<div class="highlight-python"><div class="highlight"><pre>* Since &quot;someone is human&quot; and since we don&#39;t know his/her name, we&#39;ll just make
</pre></div>
</div>
<blockquote>
<div>up our own name for them &#8211; &#8220;Mister A&#8221;.
So, we assume that &#8220;Mr. A is human&#8221;.</div></blockquote>
<ul class="simple">
<li>We use the logic rules we already know to prove that &#8220;Mr. A is mortal&#8221;.</li>
<li>Therefore <em>&#8220;someone is mortal&#8221; and their name does not matter</em>.</li>
</ul>
<p>This approach is coded into the last logic law, <code class="docutils literal"><span class="pre">EXISTe</span></code> (exists-elimination).</p>
<p>Say we have a premise of the form, <code class="docutils literal"><span class="pre">EXISTx</span> <span class="pre">P_x</span></code>.
Since we <em>do not know the name</em> of the individual &#8220;hidden&#8221; behind the
<code class="docutils literal"><span class="pre">EXISTx</span></code>,
we make up a name for it, say <code class="docutils literal"><span class="pre">a</span></code>, and discuss what must follow from the
assumption that <code class="docutils literal"><span class="pre">P_a</span></code> holds true:</p>
<div class="highlight-python"><div class="highlight"><pre>                       ... a  P_a   assumption  (where  a  is a new, fresh name)
        EXISTx P_x     ...    Q
EXISTe: -------------------------   (a  MUST NOT appear in  Q)
               Q
</pre></div>
</div>
<p>That is, if we can deduce <code class="docutils literal"><span class="pre">Q</span></code> from <code class="docutils literal"><span class="pre">P_a</span></code>, and we do not mention a within
<code class="docutils literal"><span class="pre">Q</span></code>, then it means <code class="docutils literal"><span class="pre">Q</span></code> can be deduced no matter what name the hidden
individual has.
So, <code class="docutils literal"><span class="pre">Q</span></code> follows from <code class="docutils literal"><span class="pre">EXISTx</span> <span class="pre">P_x</span></code>.</p>
<p>We can work the previous example, with <code class="docutils literal"><span class="pre">EXISTe</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>All humans are mortal
Someone is human
Therefore, someone is mortal
</pre></div>
</div>
<p>We make up the name, <code class="docutils literal"><span class="pre">a</span></code>, for the individual whose name we do not know, and
do a case analysis:</p>
<div class="highlight-python"><div class="highlight"><pre>FORALLh(isHuman(h) --&gt; isMortal(h)), EXISTx isHuman(x) |- EXISTy isMortal(y)

1.  FORALLh(isHuman(h) --&gt; isMortal(h))    premise
2.  EXISTx isHuman(x)                      premise
... 3.  a   isHuman(a)                     assumption
... 4.      isHuman(a) --&gt; isMortal(a)     FORALLe 1
... 5.      isMortal(a)                    --&gt;e 4,3
... 6.      EXISTy isMortal(y)             EXISTi 5
7.  EXISTy isMortal(y)                     EXISTe 2, 3-6
</pre></div>
</div>
<p>Line 3 proposes the name <code class="docutils literal"><span class="pre">a</span></code> and the assumption that <code class="docutils literal"><span class="pre">isHuman(a)</span></code>.
The case analysis leads to Line 6, which says that someone is mortal.
(We never learned the individual&#8217;s name!)
Since Line 6 does not explicitly mention the made-up name, <code class="docutils literal"><span class="pre">a</span></code>, we use Line 7
to repeat Line 6 &#8211; without knowing the name of the individual &#8220;hiding&#8221; inside
Line 2, we made a case analysis in Lines 3-6 that prove the result, anyway.
This is how <code class="docutils literal"><span class="pre">EXISTe</span></code> works.</p>
<p>To repeat: The <code class="docutils literal"><span class="pre">EXISTe</span></code> rule describes how to discuss an anonymous individual
(a witness) without knowing/revealing its identity:
Assume the witness&#8217;s name is Mister <code class="docutils literal"><span class="pre">a</span></code> (&#8220;Mister Anonymous&#8221;) and that
Mister <code class="docutils literal"><span class="pre">a</span></code> makes <code class="docutils literal"><span class="pre">P</span></code> true.
Then, we deduce some fact, <code class="docutils literal"><span class="pre">Q</span></code>, that holds <em>even though we don&#8217;t know who is
Mister</em> <code class="docutils literal"><span class="pre">a</span></code>.
The restriction on the <code class="docutils literal"><span class="pre">EXISTe</span></code> rule (<code class="docutils literal"><span class="pre">Q</span></code> cannot mention <code class="docutils literal"><span class="pre">a</span></code>) enforces
that we have no extra information about the identity of Mister <code class="docutils literal"><span class="pre">a</span></code> &#8211; the name
<code class="docutils literal"><span class="pre">a</span></code> must not leave the subproof.</p>
<p>Here is a Wheel-of-Fortune example that uses <code class="docutils literal"><span class="pre">EXISTe</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>EXISTc (isVowel(c) ^ EXISTs holds(s,c)) |-  EXISTy isVowel(y)

1. EXISTc (isVowel(c) ^ EXISTs holds(s,c))    premise
... 2.  a   isVowel(a) ^ EXISTs holds(s,a)    assumption
... 3.      isVowel(a)                        ^e1 2
... 4.      EXISTy isVowel(y)                 EXISTi 3
5. EXISTy  EXISTy isVowel(y)                  EXISTe 1,2-4
</pre></div>
</div>
<p>We do not know the identity of the vowel held in an unknown square, but this
does not prevent us from concluding that there is a vowel.</p>
</div>
<div class="section" id="standard-examples">
<h4>Standard Examples<a class="headerlink" href="#standard-examples" title="Permalink to this headline">¶</a></h4>
<p>For practice, we do some standard examples:</p>
<div class="highlight-python"><div class="highlight"><pre>EXISTx P(x) |- EXISTy P(y)

1. EXISTx P(x)             premise
... 2. a    P(a)           assumption
... 3.      EXISTy P(y)    EXISTi 2
4. EXISTy P(y)             EXISTe 1,2-3
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>EXISTx(F(x) ^ G(x)) |- (EXISTy F(y)) ^ (EXISTz G(z))

1. EXISTx(F(x) ^ G(x))                      premise
... 2.  a    F(a) ^ G(a)                    assumption
... 3.       F(a)                           ^e1 2
... 4.       EXISTy F(y)                    EXISTi 3
... 5.       G(a)                           ^e2 2
... 6.       EXISTz G(z)                    EXISTi 5
... 7.       (EXISTy F(y)) ^ (EXISTz G(z))  ^i 4,6
8.  (EXISTy F(y)) ^ (EXISTz G(z))           EXISTe 1, 2-7
</pre></div>
</div>
<p>Notice that you cannot prove the converse:</p>
<div class="highlight-python"><div class="highlight"><pre>(EXISTy F(y)) ^ (EXISTz G(z)) |- EXISTx(F(x) ^ G(x)).
</pre></div>
</div>
<p>For example, say that the universe of discussion is the cast of Wheel of
Fortune, and <code class="docutils literal"><span class="pre">F</span> <span class="pre">==</span> <span class="pre">isMale</span></code> and <code class="docutils literal"><span class="pre">G</span> <span class="pre">==</span> <span class="pre">isFemale</span></code>.
Clearly, Pat Sajak is male and Vanna White is female, so
<code class="docutils literal"><span class="pre">(EXISTy</span> <span class="pre">F(y))</span> <span class="pre">^</span> <span class="pre">(EXISTz</span> <span class="pre">G(z))</span></code> is a true premise.
But <code class="docutils literal"><span class="pre">EXISTx(F(x)</span> <span class="pre">^</span> <span class="pre">G(x))</span></code> does not follow.</p>
<p>The following proof uses the <code class="docutils literal"><span class="pre">ve</span></code>-tactic &#8211; a cases analysis.
See the assumptions at lines 3 and 6, based on Line 2:</p>
<div class="highlight-python"><div class="highlight"><pre>EXISTx (P(x) v Q(x))  |-  (EXISTx P(x))  v  (EXISTx Q(x))

1. EXISTx (P(x) v Q(x))                           premise
... 2. a   P(a) v Q(a)                            assumption
...        ... 3. P(a)                            assumption
...        ... 4. EXISTx P(x)                     EXISTi 3
...        ... 5. (EXISTx P(x)) v (EXISTx Q(x))   vi1 4

...        ... 6. Q(a)                            assumption
...        ... 7. EXISTx Q(x)                     EXISTi 6
...        ... 8. (EXISTx P(x)) v (EXISTx Q(x))   vi2 7

... 9.    (EXISTx P(x)) v (EXISTx Q(x))           ve 2,3-5,6-8
11. (EXISTx P(x)) v (EXISTx Q(x))                 EXISTe 1,2-9
</pre></div>
</div>
<p>As an exercise, prove the converse of the above:</p>
<div class="highlight-python"><div class="highlight"><pre>(EXISTx P(x)) v (EXISTx Q(x)) |- EXISTx (P(x) v Q(x)).
</pre></div>
</div>
</div>
<div class="section" id="an-important-example">
<h4>An Important Example<a class="headerlink" href="#an-important-example" title="Permalink to this headline">¶</a></h4>
<p>We finish with this crucial example.
We use the domain of people:</p>
<div class="highlight-python"><div class="highlight"><pre>EXISTx FORALLy isBossOf(x,y)
</pre></div>
</div>
<p>Read this as, &#8220;there is someone who is the boss of everyone&#8221;.
From this strong fact we can prove that everyone has a boss, that is,
<code class="docutils literal"><span class="pre">FORALLuEXISTv</span> <span class="pre">isBossOf(v,u)</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>EXISTxFORALLy isBossOf(x,y) |- FORALLuEXISTv isBossOf(v,u)

1. EXISTxFORALLy isBossOf(x,y)          premise
... 2. b   FORALLy isBossOf(b,y)        assumption
...        ... 3. a
...        ... 4. isBossOf(b,a)         FORALLe 2
...        ... 5. EXISTv isBossOf(v,a)  EXISTi 4
... 6.     FORALLuEXISTv isBossOf(v,u)  FORALLi 3-5
7.  FORALLuEXISTv bossOf(v,u)           EXISTe 1,3-5
</pre></div>
</div>
<p>In the above proof, we let <code class="docutils literal"><span class="pre">b</span></code> be our made-up name for the boss-of-everyone.
So, we have the assumption that <code class="docutils literal"><span class="pre">FORALLy</span> <span class="pre">isBossOf(b,y)</span></code>.
Next, we let <code class="docutils literal"><span class="pre">a</span></code> be &#8220;anybody at all&#8221; who we might examine in the domain of
people.
The proof exposes that the boss of &#8220;anybody at all&#8221; in the domain must always be
<code class="docutils literal"><span class="pre">b</span></code>.
<code class="docutils literal"><span class="pre">FORALLi</span></code> and then <code class="docutils literal"><span class="pre">EXISTi</span></code> finish the proof.</p>
<p>Here is the proof worked again, with the subproofs swapped:</p>
<div class="highlight-python"><div class="highlight"><pre>EXISTxFORALLy isBossOf(x,y) |- FORALLuEXISTv isBossOf(v,u)

1. EXISTxFORALLy isBossOf(x,y)               premise
... 2. a
... ... 3. b     FORALLy isBossOf(b,y)       assumption
... ... 4.       isBossOf(b,a)               FORALLe 3
... ... 5.       EXISTv isBossOf(v,a)        EXISTi 4
... 6. EXISTv bossOf(v,a)                    EXISTe 1,3-5
7. FORALLuEXISTv isBossOf(v,u)               FORALLi 2-6
</pre></div>
</div>
<p>Can we prove the converse?
That is, if everyone has a boss, then there is one boss who is the boss of
everyone?</p>
<div class="highlight-python"><div class="highlight"><pre>FORALLuEXISTv isBossOf(v,u) |- EXISTxFORALLy isBossOf(x,y) ???
</pre></div>
</div>
<p>No &#8211; we can try, but we get stuck:</p>
<div class="highlight-python"><div class="highlight"><pre>1. FORALLuEXISTv isBossOf(v,u)    premise
... 2. a
... 3. EXISTv isBossOf(v,a)       FORALLe 1
... ... 4. b    isBossOf(b,a)     assumption
5. FORALLy isBoss(b,y)            FORALLi 2-5  NO --- THIS PROOF IS TRYING TO FINISH
                                  THE OUTER SUBPROOF WITHOUT FINISHING THE INNER ONE FIRST.
</pre></div>
</div>
<p>We see that the &#8220;block structure&#8221; of the proofs warns us when we are making
invalid deductions.</p>
<p>It is interesting that we <em>can</em> prove the following:</p>
<blockquote>
<div>EXISTxFORALLy isBossOf(x,y) <a href="#id7"><span class="problematic" id="id8">|</span></a>- EXISTz isBossOf(z,z)</div></blockquote>
<p>(&#8220;if someone is the boss of everyone, then someone is their own boss&#8221;):</p>
<div class="highlight-python"><div class="highlight"><pre>EXISTxFORALLy isBossOf(x,y) |- FORALLuEXISTv isBossOf(v,u)

1. EXISTxFORALLy isBossOf(x,y)     premise
... 2. b    FORALLy isBossOf(b,y)  assumption
... 3.      isBossOf(b,b)          FORALLe 2
... 4.      EXISTz isBossOf(z,z)   EXISTi 4
5. EXISTz bossOf(z,z)              EXISTe 1,2-4
</pre></div>
</div>
<p>Line 3 exposes that the &#8220;big boss&#8221;, <code class="docutils literal"><span class="pre">b</span></code>, <em>must</em> be its own boss.</p>
</div>
<div class="section" id="domains-and-models">
<h4>Domains and Models<a class="headerlink" href="#domains-and-models" title="Permalink to this headline">¶</a></h4>
<p>The examples of bosses and workers illustrate these points:</p>
<ol class="arabic">
<li><p class="first"><em>You must state the domain of individuals when you state premises</em>.
In the bosses-workers examples, the domain is a collection of people.
Both the bosses and the workers belong to that domain.
Here are three drawings of possible different domains, where an arrow,
<code class="docutils literal"><span class="pre">person1</span></code> &#8212;&gt; <code class="docutils literal"><span class="pre">person2</span></code>, means that <code class="docutils literal"><span class="pre">person1</span></code> is the boss of
<code class="docutils literal"><span class="pre">person2</span></code>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="34%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><img alt="../../_images/boss1.png" class="first last" src="../../_images/boss1.png" />
</td>
<td><img alt="../../_images/boss2.png" class="first last" src="../../_images/boss2.png" />
</td>
<td><img alt="../../_images/boss2a.png" class="first last" src="../../_images/boss2a.png" />
</td>
</tr>
</tbody>
</table>
<p>Notice that <code class="docutils literal"><span class="pre">FORALLuEXISTv</span> <span class="pre">isBossOf(v,u)</span></code> (&#8220;everyone has a boss&#8221;) holds
true for the first two domains but not the third.
<code class="docutils literal"><span class="pre">EXISTxFORALLy</span> <span class="pre">isBossOf(x,y)</span></code> holds true for only the second domain.</p>
</li>
<li><p class="first"><em>When we make a proof of</em> <code class="docutils literal"><span class="pre">P</span> <span class="pre">|-</span> <span class="pre">Q</span></code> <em>and</em> <code class="docutils literal"><span class="pre">P</span></code> <em>holds true for a domain,
then</em> <code class="docutils literal"><span class="pre">Q</span></code> <em>must also hold true for that same domain</em>.
We proved that <code class="docutils literal"><span class="pre">EXISTxFORALLy</span> <span class="pre">isBossOf(x,y)</span> <span class="pre">|-</span> <span class="pre">EXISTz</span> <span class="pre">isBossOf(z,z)</span></code>, and
sure enough, in the second example domain, <code class="docutils literal"><span class="pre">EXISTz</span> <span class="pre">isBossOf(z,z)</span></code> holds
true.</p>
<p>Our logic system is designed to work in this way!
When we do a logic proof, we are generating new facts that must hold true for
any domain for which the premises hold true.
This property is called <em>soundness of the logic</em>, and we will examine it more
closely in a later section in this chapter.</p>
</li>
<li><p class="first"><em>A domain can have infinitely many individuals</em>.
Here is a drawing of a domain of infinitely many people, where each person
bosses the person to their right:</p>
<img alt="../../_images/boss3.png" src="../../_images/boss3.png" />
<p>In this domain, <code class="docutils literal"><span class="pre">FORALLuEXISTv</span> <span class="pre">isBossOf(v,u)</span></code> holds true as does
<code class="docutils literal"><span class="pre">FORALLuEXISTv</span> <span class="pre">isBossOf(u,v)</span></code> (&#8220;everyone bosses someone&#8221;), but
<code class="docutils literal"><span class="pre">EXISTz</span> <span class="pre">isBossOf(z,z)</span></code> does not hold true.</p>
</li>
</ol>
<p>The third example domain is famous &#8211; it is just the integer domain, where
<code class="docutils literal"><span class="pre">isBossOf</span></code> is actually <code class="docutils literal"><span class="pre">&gt;</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>. . . &lt; -3 &lt; -2 &lt; -1 &lt; 0 &lt; 1 &lt; 2 &lt; 3 &lt; . . .
</pre></div>
</div>
<p>Indeed, one of the main applications of logic is proving properties of numbers.
This leads to a famous question:
Is it possible to write a collection of premises from which we can deduce
(make proofs of) all the logical properties that hold true for the domain of
integers?</p>
<p>The answer is NO.
In the 1920s, Kurt Goedel, a German PhD student, proved that the integers, along
with <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, are so complex that it is impossible to ever
formulate a finite set (or even an algorithmically defined infinite set) of
premises that generate all the true properties of the integers.
Goedel&#8217;s result, known as the <em>First Incompleteness Theorem</em>, set mathematics
back on its heels and directly led to the formulation of theoretical computer
science (of which this course is one small part).
There is more material about Goedel&#8217;s work at the end of this chapter.</p>
</div>
<div class="section" id="tactics-for-the-exist-rules">
<h4>Tactics for The EXIST-Rules<a class="headerlink" href="#tactics-for-the-exist-rules" title="Permalink to this headline">¶</a></h4>
<p>There are two tactics; neither is easy to master:</p>
<ul>
<li><p class="first">(<a href="#id9"><span class="problematic" id="id10">**</span></a><a href="#id11"><span class="problematic" id="id12">*</span></a>) <code class="docutils literal"><span class="pre">EXISTe</span></code>-tactic:
To prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">EXISTx</span> <span class="pre">P_x</span> <span class="pre">|-</span> <span class="pre">Q</span></code>,</p>
<ol class="arabic simple">
<li>assume <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">P_a</span></code>, where <code class="docutils literal"><span class="pre">a</span></code> is a brand new anonymous name</li>
<li>prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">P_a</span> <span class="pre">|-</span> <span class="pre">Q</span></code></li>
<li>apply <code class="docutils literal"><span class="pre">EXISTe</span></code></li>
</ol>
<p>The proof looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre>1.  Premises        premise
2.  EXISTx P_x      premise
... i. a   P_a      assumption
        (fill in)
... j. Q            (does not mention  a!)
k.  Q               EXISTe 2,i-j
</pre></div>
</div>
</li>
<li><p class="first">(*) <code class="docutils literal"><span class="pre">EXISTi</span></code>-tactic:
To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">EXISTx</span> <span class="pre">P_x</span></code>, try to prove <code class="docutils literal"><span class="pre">P_e</span></code> for some <code class="docutils literal"><span class="pre">e</span></code> that
already appears in the partially completed proof.
Finish with <code class="docutils literal"><span class="pre">EXISTi</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>1.  Premises        premise
  . . .
i.  ...e...
      (fill in)
j.  P_e
k.  EXISTx P_x      EXISTi j
</pre></div>
</div>
</li>
</ul>
<p>Look at the Wheel-of-Fortune proofs for instances where these tactics were
applied.</p>
</div>
</div>
<div class="section" id="applications-of-the-existential-quantifier">
<h3>8.2.2. Applications of The Existential Quantifier<a class="headerlink" href="#applications-of-the-existential-quantifier" title="Permalink to this headline">¶</a></h3>
<p>Since an existential quantifier hides knowledge, it is useful to describe a
function that returns some but not all the information that the function
computes.
Here is a simple example, for a computerized Wheel-of-Fortune game:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">board</span> <span class="o">=</span> <span class="o">...</span>   <span class="s">&quot;&quot;&quot;{ invariant: isStringArray(board) ^  len(board) &gt; 0  }&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">gameOver</span><span class="p">()</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;examines  board  to see if all squares uncovered.  Returns  True  if so,</span>
<span class="sd">       otherwise returns False.&quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;{  gameOver_pre   true }&quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    {  gameOver_post  answer --&gt; ~(EXIST 0 &lt;= i &lt; len(board), board[i] == &quot;covered&quot;)</span>
<span class="sd">       ^  ~answer --&gt; (EXIST 0 &lt;= i &lt; len(board), board[i] == &quot;covered&quot;) }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="o">...</span> <span class="k">while</span> <span class="n">loop</span> <span class="n">that</span> <span class="n">searches</span> <span class="n">board</span> <span class="k">for</span> <span class="n">a</span>  <span class="n">board</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;covered&quot;</span><span class="p">;</span>
          <span class="k">if</span> <span class="n">it</span> <span class="n">finds</span> <span class="n">one</span><span class="p">,</span> <span class="n">it</span> <span class="n">resets</span>  <span class="n">answer</span> <span class="o">=</span> <span class="bp">False</span> <span class="o">...</span>

    <span class="k">return</span> <span class="n">answer</span>
</pre></div>
</div>
<p>The computerized Pat Sajak would use this function like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">done</span> <span class="o">=</span> <span class="n">gameOver</span><span class="p">()</span>
<span class="k">if</span> <span class="n">done</span> <span class="p">:</span>
    <span class="k">print</span> <span class="s">&quot;We have a winner!  Time for a commercial!&quot;</span>
<span class="k">else</span> <span class="p">:</span>
    <span class="k">print</span> <span class="s">&quot;There is still a letter that is covered. Let&#39;s continue!&quot;</span>
</pre></div>
</div>
<p>Here is the relevant deduction:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">done</span> <span class="o">=</span> <span class="n">gameOver</span><span class="p">()</span>
<span class="sd">&quot;&quot;&quot;{  assert:  [done/answer]gameOver_post  }&quot;&quot;&quot;</span>
<span class="k">if</span> <span class="n">done</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    {  1. done                                                          premise</span>
<span class="sd">       2. [done/answer]gameOver_post                                    premise</span>
<span class="sd">       3. done --&gt; ~(EXIST 0 &lt; i &lt; len(board), board[i] == &quot;covered&quot;)   ^e 2</span>
<span class="sd">       4. ~(EXIST 0 &lt; i &lt; len(board), board[i] == &quot;covered&quot;)            --&gt;e 3,1 }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="s">&quot;We have a winner!  Time for a commercial!&quot;</span>
<span class="k">else</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    {  1. ~done                                                         premise</span>
<span class="sd">       2. [done/answer]gameOver_post                                    premise</span>
<span class="sd">       3. ~done --&gt; (EXIST 0 &lt; i &lt; len(board), board[i] == &quot;covered&quot;)   ^e 2</span>
<span class="sd">       4. EXIST 0 &lt; i &lt; len(board), board[i] == &quot;covered&quot;               --&gt;e 3,1 }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="s">&quot;There is still a letter that is covered. Let&#39;s continue!&quot;</span>
</pre></div>
</div>
<p>Notice that the answer returned by <code class="docutils literal"><span class="pre">gameOver</span></code> hides which square on the
<code class="docutils literal"><span class="pre">board</span></code> is still covered (<code class="docutils literal"><span class="pre">==</span> <span class="pre">&quot;covered&quot;</span></code>).</p>
<p>We repeat an example from a previous chapter to show another use of the
existential:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;delete locates an occurrence of  c  in  s  and</span>
<span class="sd">       removes it and returns the resulting string.</span>
<span class="sd">       If  c  is not in  s, a copy of  s  is returned, unchanged.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    {  pre:  isChar(c) ^ isString(s)</span>
<span class="sd">       post: (EXIST 0 &lt;= k &lt; len(s), s[k] == c ^ answer == s[:k] + s[k+1:])</span>
<span class="sd">             v</span>
<span class="sd">             (FORALL 0 &lt;= i &lt; len(s), s[i] != c) ^ answer == s }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">while</span> <span class="n">index</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="ow">and</span>  <span class="ow">not</span> <span class="n">found</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        {  invariant (FORALL 0 &lt;= i &lt; index, s[i] != c)  ^</span>
<span class="sd">                     (found --&gt;  s[index] == c)   }</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span>  <span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">c</span> <span class="p">:</span>
            <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="sd">&quot;&quot;&quot;{  assert: (index == len(s) v found)  ^  above invariant  }&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">found</span> <span class="p">:</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        {  1. found                                              premise</span>
<span class="sd">           2. answer == s[:index] + s[index+1:]                  premise</span>
<span class="sd">           3. invariant                                          premise</span>
<span class="sd">           4. (found --&gt;  s[index] == c)                         ^e 3</span>
<span class="sd">           5. s[index] == c                                      --&gt;e 4,1</span>
<span class="sd">           6. s[index] == c ^ answer == s[:index] + s[index+1:]  ^i 5,2</span>
<span class="sd">           7. 0 &lt;= index &lt; len(s)                                algebra 5</span>
<span class="sd">           8. EXIST 0 &lt;= k &lt; len(s), s[k] == c ^ answer == s[:k] + s[k+1:]  EXISTi 7,6  (where [k/index]) }</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="k">else</span> <span class="p">:</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="n">s</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        {  1. ~found                                             premise</span>
<span class="sd">           2. answer == s                                        premise</span>
<span class="sd">           3. (index == len(s) v found)                          premise</span>
<span class="sd">           4. invariant                                          premise</span>
<span class="sd">           5. index == len(s)                                    by  P v Q, ~Q |- P, 3,1</span>
<span class="sd">           6. FORALL 0 &lt;= i &lt; index, s[i] != c                   ^e 4</span>
<span class="sd">           7. FORALL 0 &lt;= i &lt; len(s), s[i] != c                  substitution 5,6</span>
<span class="sd">           8. (FORALL 0 &lt;= i &lt; len(s), s[i] != c) ^ answer == s  ^i 7,2 }</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">answer</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">EXISTi</span></code> rule is used inside the then-arm of the last conditional, as
shown above.</p>
<p>It is important that <code class="docutils literal"><span class="pre">delete</span></code> hide the value of its local variable, <code class="docutils literal"><span class="pre">index</span></code>,
from appearing in its postcondition, because we do not want confusion like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">index</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">t</span> <span class="o">=</span> <span class="s">&quot;abcd&quot;</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;{ at this point, we certainly cannot assert that t[2] = &quot;a&quot;! }&quot;&quot;&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="the-forwards-assignment-law-uses-an-existential-quantifier">
<h3>8.2.3. The Forwards Assignment Law Uses an Existential Quantifier<a class="headerlink" href="#the-forwards-assignment-law-uses-an-existential-quantifier" title="Permalink to this headline">¶</a></h3>
<p>The original, proper statement of the forwards assignment law reads like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;{ assert: P }&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">e</span>
<span class="sd">&quot;&quot;&quot;{ assert: EXISTx_old ( (x == [x_old/x]e)  ^  [x_old/x]P )  }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Our use of <code class="docutils literal"><span class="pre">x_old</span></code> was hiding the quantifier.
Using <code class="docutils literal"><span class="pre">EXIST</span></code>, we can retain an assertion that uses the old value of <code class="docutils literal"><span class="pre">x</span></code>.
In the earlier chapters, we worked examples like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;{ x &gt; 0 }&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. x_old &gt; 0        premise</span>
<span class="sd">  2. x == x_old + 1   premise</span>
<span class="sd">  3. x &gt; 1            algebra 1,2 }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>and noted that <code class="docutils literal"><span class="pre">x_old</span></code> must not appear in the last line of the proof.</p>
<p>The above proof is actually the subproof of a proof that finishes with
<code class="docutils literal"><span class="pre">EXISTe</span></code>!
Here is the proper proof:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;{ x &gt; 0 }&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. EXISTx_old(x_old &gt; 0  ^  x == x_old + 1)     premise</span>
<span class="sd">  ... 2. x_old     x_old &gt; 0  ^  x == x_old + 1   assumption</span>
<span class="sd">  ... 3.          x_old &gt; 0                       ^e1 2</span>
<span class="sd">  ... 4.          x == x_old + 1                  ^e2 2</span>
<span class="sd">  ... 5.          x &gt; 1                           algebra 3,4</span>
<span class="sd">  6. x &gt; 1                                        EXISTe 1, 2-5</span>
<span class="sd">}</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Again, it is crucial that <code class="docutils literal"><span class="pre">x_old</span></code> not appear in the assertions on Lines 5 and 6.</p>
<p>We unconsciously use the existential quantifier and <code class="docutils literal"><span class="pre">EXISTe</span></code> every time we
reason about the old, overwritten value of an updated variable.</p>
<p>Also, when we introduce dummy names, like <code class="docutils literal"><span class="pre">x_in</span></code> and <code class="docutils literal"><span class="pre">y_in</span></code>, to stand for
specific values, as an example like this,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;{ assert: x == x_in  ^  y == y_in }&quot;&quot;&quot;</span>
<span class="n">temp</span> <span class="o">=</span> <span class="n">x</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">temp</span>
<span class="sd">&quot;&quot;&quot;{ assert: x == y_in  ^  y == x_in }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>we are implicitly using existential quantifiers, again, like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;{ assert: EXISTx_in EXISTy_in(x == x_in  ^  y == y_in) }&quot;&quot;&quot;</span>
<span class="n">temp</span> <span class="o">=</span> <span class="n">x</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">temp</span>
<span class="sd">&quot;&quot;&quot;{ assert: EXISTx_inEXISTy_in(x == y_in  ^  y == x_in) }&quot;&quot;&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="the-law-for-assigning-to-individual-array-elements">
<h2>8.3. The Law for Assigning to Individual Array Elements<a class="headerlink" href="#the-law-for-assigning-to-individual-array-elements" title="Permalink to this headline">¶</a></h2>
<p>A key property of the forwards law for an assignment, <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">e</span></code>, is that the
&#8220;old&#8221; value of <code class="docutils literal"><span class="pre">x</span></code> cannot appear in the final consequence that is deduced from
the assignment.
The same principle holds for assignment to an individual array element:
<code class="docutils literal"><span class="pre">a[e]</span> <span class="pre">=</span> <span class="pre">e'</span></code> &#8211; the &#8220;old&#8221; value of <code class="docutils literal"><span class="pre">a[e]</span></code> cannot appear in the assertion that
results from the assignment.</p>
<p>For example, if we have</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;{ assert: len(a) &gt; 0 ^ FORALL 0 &lt;= i &lt; len(a), a[i] &gt; 0 }&quot;&quot;&quot;</span>
<span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>we should be able to deduce that</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ assert:   a[0] == 0</span>
<span class="sd">            ^  len(a) &gt; 0</span>
<span class="sd">            ^  FORALL 0 &lt; i &lt; len(a), a[i] &gt; 0</span>
<span class="sd">  implies:  FORALL 0 &lt;= i &lt; len(a), a[i] &gt;= 0 }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>How can we do this?
The existing assignment law is too weak.
We require a special law for assignment to array elements.
The situation gets delicate if we are unable to deduce the precise numerical
value of the index expression, <code class="docutils literal"><span class="pre">e</span></code>, in an assignment, <code class="docutils literal"><span class="pre">a[e]</span> <span class="pre">=</span> <span class="pre">e'</span></code>.
Unless we can prove otherwise, the assignment has essentially updated &#8220;all&#8221; of
<code class="docutils literal"><span class="pre">a</span></code>!</p>
<p>Here is an example of a situation where we know nothing about which cell was
updated:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">n</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s">&quot;Type an int between 0 and len(a)-1: &quot;</span><span class="p">)</span>
<span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">n</span>  <span class="ow">and</span>  <span class="n">n</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Clearly only one element of a is decremented. Let&#8217;s try to reason about this
situation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;{ assert: FORALL 0 &lt;= i &lt; len(a), a[i] &gt; 0 }&quot;&quot;&quot;</span>

<span class="n">n</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s">&quot;Type an int between 0 and len(a)-1: &quot;</span><span class="p">)</span>
<span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">n</span>  <span class="ow">and</span>  <span class="n">n</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;{ assert: 0 &lt;= n ^ n &lt; len(a)  ^  FORALL 0 &lt;= i &lt; len(a), a[i] &gt; 0 }&quot;&quot;&quot;</span>

<span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{  assert:  a[n] == a_old[n] - 1  ^  0 &lt;= n  ^  n &lt; len(a)</span>
<span class="sd">            ^  FORALL 0 &lt;= i &lt; len(a), a_old[i] &gt; 0</span>
<span class="sd">   implies: ??? }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>To move forwards, we must assert that all those variables <code class="docutils literal"><span class="pre">a[i]</span></code>, such that
<code class="docutils literal"><span class="pre">i</span> <span class="pre">!=</span> <span class="pre">n</span></code>, retain their old values:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. a[n] == a_old[n] - 1                                  premise</span>
<span class="sd">  2. FORALL 0 &lt;= i &lt; len(a), (i!=n) --&gt; a[i] == a_old[i]   premise  NEW!</span>
<span class="sd">  3. 0 &lt;= n ^ n &lt; len(a)                                   premise</span>
<span class="sd">  4. FORALL 0 &lt;= i &lt; len(a), a_old[i] &gt; 0                  premise</span>
<span class="sd">  5.  ... }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>We accept the assertion (premise) on line 2 as a fact, and the forwards
assignment law for arrays includes this fact &#8220;for free&#8221; as part of its
postcondition.</p>
<p>Here is the law for array assignment:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;{ assert: P }&quot;&quot;&quot;</span>
<span class="n">a</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="s">&#39;    # where  e  contains _no mention_ of  a</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. a[e] == [a_old/a]e&#39;                                     premise</span>
<span class="sd">  2. [a_old/a]P                                              premise</span>
<span class="sd">  3. FORALL 0 &lt;= i &lt; len(a), (i != e) --&gt; a[i] == a_old[i]   premise</span>
<span class="sd">  4. len(a) == len(a_old)                                    premise</span>
<span class="sd">     ...</span>
<span class="sd">  n. Q  # must not mention a_old</span>
<span class="sd">}</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>We gain the new premises in lines 3 and 4.
Line 2 is used with <code class="docutils literal"><span class="pre">FORALLe</span></code> to extract information about array elements that
were not affected by the assignment to <code class="docutils literal"><span class="pre">a[e]</span></code>.</p>
<p>Now we have enough knowledge to make a useful deduction:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. a[n] == a_old[n] - 1                                      premise</span>
<span class="sd">  2. FORALL 0 &lt;= i &lt; len(a), (i!=n) --&gt; a[i] == a_old[i]       premise</span>
<span class="sd">  3. 0 &lt;= n ^ n &lt; len(a)                                       premise</span>
<span class="sd">  4. FORALL 0 &lt;= i &lt; len(a), a_old[i] &gt; 0                      premise</span>
<span class="sd">  5. a_old[n] &gt; 0                                              FORALLe 4,3</span>
<span class="sd">  6. a[n] &gt;= 0                                                 algebra 1,5</span>
<span class="sd">           (next, we salvage the facts about those  a[i] such that i != n: )</span>
<span class="sd">  ... 8.  0 &lt;= x &lt; len(a)                                      assumption</span>
<span class="sd">  ... 9.  a_old[x] &gt; 0                                         FORALLe 4,8</span>
<span class="sd">  ... 10. (x!=n) --&gt; a[x] == a_old[x]                          FORALLe 2,8</span>
<span class="sd">  ... ... 11. x != n                                           assumption</span>
<span class="sd">  ... ... 12. a[x] == a_old[x]                                 --&gt;e 10,11</span>
<span class="sd">  ... ... 13. a[x] &gt; 0                                         algebra 9,12</span>
<span class="sd">  ... 14. (x!=n) --&gt; a[x] &gt; 0                                  --&gt;i 11-13</span>
<span class="sd">  15. FORALL 0 &lt;= x &lt; len(a): (x!=n) --&gt; a[x] &gt; 0              FORALLi 8-14</span>

<span class="sd">  16. a[n] &gt;= 0 ^ FORALL 0 &lt;= x &lt; len(a): (x!=n) --&gt; a[x] &gt; 0  ^i 6,15  }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>This tedious proof shows the difficulty in reasoning precisely about an array
update with an unknown index value.</p>
<p>It is easy to be discouraged by the length of the above proof, which says that
the <code class="docutils literal"><span class="pre">n``th</span> <span class="pre">element</span> <span class="pre">of</span> <span class="pre">``a</span></code> was changed.
For this reason, some researchers use a picture notation to encode the
assertions.
For example, the assertion,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">FORALL</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Might be drawn like this:</p>
<div class="highlight-python"><div class="highlight"><pre>      0  1  ... len(a)-1
    +--+--+-- --+--+
a = |&gt;0|&gt;0| ... |&gt;0|
    +--+--+-- --+--+
</pre></div>
</div>
<p>so that after the assignment, a[n] = a[n]-1, we deduce this new pictorial
assertion:</p>
<div class="highlight-python"><div class="highlight"><pre>      0  1 ...    n  ...  len(a)-1
    +--+--+-   -+---+    -+--+
a = |&gt;0|&gt;0| ... |&gt;=0| ... |&gt;0|
    +--+--+-   -+---+    -+--+
</pre></div>
</div>
<p>which is meant to portray
<code class="docutils literal"><span class="pre">a[n]</span> <span class="pre">&gt;=</span> <span class="pre">0</span> <span class="pre">^</span> <span class="pre">FORALL</span> <span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">len(a),</span> <span class="pre">(x!=n)</span> <span class="pre">--&gt;</span> <span class="pre">a[x]</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
<p>These pictures can be helpful for informal reasoning, but they quickly get
confusing.
(For example, where do you draw <code class="docutils literal"><span class="pre">n</span></code>&#8216;s cell in the above picture?
What if <code class="docutils literal"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">0</span></code>? Etc.)
Use such drawings with caution.</p>
<p>To summarize, the forwards assignment law for individual array elements reads as
follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;{ assert: P }&quot;&quot;&quot;</span>
<span class="n">a</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="s">&#39;    # where  e  contains _no mention_ of  a</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ assert:  a[e] == [a_old/a]e&#39;</span>
<span class="sd">           ^  FORALL 0 &lt;= i &lt; len(a), (i != e) --&gt; a[i] == a_old[i]</span>
<span class="sd">           ^  len(a) == len(a_old)</span>
<span class="sd">           ^  [a_old/a]P  }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="case-studies">
<h2>8.4. Case Studies<a class="headerlink" href="#case-studies" title="Permalink to this headline">¶</a></h2>
<div class="section" id="in-place-selection-sort">
<h3>8.4.1. In-place Selection Sort<a class="headerlink" href="#in-place-selection-sort" title="Permalink to this headline">¶</a></h3>
<p>When an array holds elements that can be ordered by <code class="docutils literal"><span class="pre">&lt;</span></code>, it is useful to
rearrange the elements so that they are ordered (sorted).
There are several useful tecniques to sort an array&#8217;s elements in place,
that is, move them around within the array until the array is sorted.</p>
<p>One useful and straightforward technique is <em>selection sort</em>, where the unsorted
segment of the array is repeatedly scanned for the smallest element therein,
which is extracted at moved to the end of the array&#8217;s sorted segment.</p>
<p>A trace of a selection sort would look like this:</p>
<div class="highlight-python"><div class="highlight"><pre>  (sorted segment) | (unsorted segment)
                   v
              a == [&quot;f&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;e&quot;]
                   v
          a == [&quot;b&quot;, &quot;d&quot;, &quot;c&quot;, &quot;f&quot;, &quot;e&quot;]   (&quot;b&quot; selected and moved to front
                   v                            by exchanging it with &quot;f&quot;)
     a == [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;f&quot;, &quot;e&quot;,]   (&quot;c&quot; selected and moved to front
                   v                        by exchanging it with &quot;d&quot;)
a == [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;f&quot;, &quot;e&quot;]   (&quot;d&quot; selected and moved to front
                                      by exchanging it with itself)
(etc.)                       |
                             v
a ==  [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]   (finished)
</pre></div>
</div>
<p>We require a function that searches the unsorted segment of the array and
locates the position of the least element therein:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span> <span class="p">,</span> <span class="s">&quot;a&quot;</span><span class="p">]</span>   <span class="c"># data structure managed by this module</span>

<span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="p">:</span>
   <span class="sd">&quot;&quot;&quot;select returns the index of the smallest element in array  a&#39;s</span>
<span class="sd">      segment from  a[start]...a[len(a)-1].&quot;&quot;&quot;</span>
   <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   { pre:  0 &lt;= start &lt; len(a)</span>
<span class="sd">     post: start &lt;= answer &lt; len(a)  ^</span>
<span class="sd">           FORALL start &lt;= i &lt; len(a), a[answer] &lt;= a[i]  }</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="n">answer</span> <span class="o">=</span> <span class="n">start</span>
   <span class="n">index</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span>
   <span class="sd">&quot;&quot;&quot;{ invariant:  FORALL start &lt;= i &lt; index, a[answer] &lt;= a[i] }&quot;&quot;&quot;</span>
   <span class="k">while</span> <span class="n">index</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">:</span>
       <span class="k">if</span>  <span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">answer</span><span class="p">]</span> <span class="p">:</span>
          <span class="n">answer</span> <span class="o">=</span> <span class="n">index</span>
       <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
   <span class="k">return</span> <span class="n">answer</span>
</pre></div>
</div>
<p>The pre-postconditions tell us the knowledge the function computes.</p>
<p>Next, define these notions of &#8220;ordered&#8221; and &#8220;permuted&#8221; for arrays:</p>
<div class="highlight-python"><div class="highlight"><pre>ordered(a) =  FORALL 0 &lt; i &lt; len(a), a[i-1] &lt;= a[i]
perm(a, b) =  (len(a) = len(b))  ^  (elements of  a  ==  elements of b)
</pre></div>
</div>
<p>The second predicate states what it means for one array, <code class="docutils literal"><span class="pre">a</span></code>, to have the same
elements as another, <code class="docutils literal"><span class="pre">b</span></code>, but maybe in a different order.
It is a little informal but good enough for us to use here.</p>
<p>The function that does a selection sort uses a loop to repeatedly call
<code class="docutils literal"><span class="pre">select</span></code> to find the elements to move to the front of the array.</p>
<p>Here&#8217;s the function and the sketch of the proof.
The loop invariant is key &#8211; the elements that have been already selected are
moved to the front of <code class="docutils literal"><span class="pre">a</span></code> are all guaranteed to be less-than-or-equal-to the
elements in <code class="docutils literal"><span class="pre">a</span></code>&#8216;s rear that have not yet been selected:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">selectionSort</span><span class="p">()</span> <span class="p">:</span>
   <span class="sd">&quot;&quot;&quot;does an in-place sort on global array  a,  using  select.&quot;&quot;&quot;</span>
   <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   { pre  true</span>
<span class="sd">     post ordered(a)  ^  perm(a_in, a)   (Recall: a_in is the starting value for  a) }</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="k">global</span> <span class="n">a</span>

   <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   { invariant   ordered(a[:index])  ^  perm(a, a_in)  ^</span>
<span class="sd">                 FORALL 0 &lt;= i &lt; index, FORALL index &lt;= j &lt; len(a), a[i] &lt;= a[j] }</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="k">while</span> <span class="n">index</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">:</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      { assert: start &lt;= x &lt; len(a)  ^</span>
<span class="sd">                FORALL index &lt;= i &lt; len(a), a[x] &lt;= a[i]</span>
<span class="sd">                ^  invariant  }</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">least</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>       <span class="c"># exchange the least element with the one at the</span>
      <span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>    <span class="c">#  front of the unsorted segment</span>
      <span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">least</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      {  assert: ordered(a[:index])  ^  perm(a, a_in) ^</span>
<span class="sd">                 index &lt;= x &lt; len(a) ^</span>
<span class="sd">                 a[index] = least  ^</span>
<span class="sd">                 FORALL index &lt; i &lt; len(a), least &lt;= a[i]</span>
<span class="sd">        implies: FORALL 0 &lt;= i &lt; index, a[i] &lt;= least</span>
<span class="sd">        implies: ordered(a[:index+1])  ^</span>
<span class="sd">                 FORALL 0 &lt;= i &lt; index+1, FORALL index+1 &lt;= j &lt; len(a): a[i] &lt;= a[j] }</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="sd">&quot;&quot;&quot;{  assert: invariant }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>The key accomplishment of</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">least</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
<span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">least</span>
</pre></div>
</div>
<p>is to move the least element in the unsorted suffix of <code class="docutils literal"><span class="pre">a</span></code> to the <em>front</em> of
that suffix.
But that makes the least value eligible to be the <em>rear</em> element of the sorted
prefix of <code class="docutils literal"><span class="pre">a</span></code>.
In this way, the loop&#8217;s invariant is restored as we finish with
<code class="docutils literal"><span class="pre">index</span> <span class="pre">=</span> <span class="pre">index</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
</div>
<div class="section" id="binary-search">
<h3>8.4.2. Binary Search<a class="headerlink" href="#binary-search" title="Permalink to this headline">¶</a></h3>
<p>Once an array is sorted, it can be searched for a value quickly, much like you
search for a word in a dictionary: you open the dictionary in the middle and see
if you got lucky and found the word.
If so, you are finished.
If the word is earlier in the dictionary, then you ignore the back half of the
book and instead split open the front half.
(And vice versa for a word located in the back half in the dictionary.)
You repeat this technique till you find the page where your word is.</p>
<p>We can search a sorted array, <code class="docutils literal"><span class="pre">a</span></code>, for a value, <code class="docutils literal"><span class="pre">v</span></code>, but jumping in the
middle of <code class="docutils literal"><span class="pre">a</span></code>.
If we find <code class="docutils literal"><span class="pre">v</span></code> there, we are done.
Otherwise, we repeat the step, jumping into the first half or the second half,
as needed.
Eventually, we find the value (if it is there).</p>
<p>Here is the function, which is famous for its difficulty to write correctly.
Glance at it, then read the paragraph underneath it, then return to the function
and study its assertions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span> <span class="p">:</span>
   <span class="sd">&quot;&quot;&quot;searches for value  v  within array  a  in the range  a[lower]...a[upper].</span>
<span class="sd">      If found, returns the index where  v  is; if not found, returns -1&quot;&quot;&quot;</span>
   <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   {  search_pre   ordered(a)  ^</span>
<span class="sd">                   FORALL 0 &lt;= i &lt; lower, a[i] &lt; v  ^</span>
<span class="sd">                   FORALL upper &lt; j &lt; len(a): v &lt; a[j]</span>
<span class="sd">                     (That is,  v  isn&#39;t in  a[:lower]  and  a[upper+1:].)</span>
<span class="sd">      search_post  ((0 &lt;= answer &lt; len(a))  ^  a[answer] == v)  v</span>
<span class="sd">                      (answer = -1  ^  FORALL 0 &lt;= i &lt; len(a), v != a[i]) }</span>
<span class="sd">   &quot;&quot;&quot;</span>

   <span class="k">if</span>  <span class="n">upper</span> <span class="o">&lt;</span> <span class="mi">0</span>  <span class="ow">or</span>  <span class="n">lower</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>  <span class="ow">or</span>  <span class="n">lower</span> <span class="o">&gt;</span> <span class="n">upper</span> <span class="p">:</span>  <span class="c"># empty range to search?</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      {  assert:  (upper &lt; 0  v  lower &gt; len(a)-1  v  lower &gt; upper)  ^</span>
<span class="sd">                  search_pre</span>
<span class="sd">         implies:  FORALL 0 &lt;= i &lt; len(a), v != a[i] }</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">answer</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      {  assert:  answer = -1  ^  (FORALL 0 &lt;= i &lt; len(a), v != a[i]),</span>
<span class="sd">                  that is,  search_post  }</span>
<span class="sd">      &quot;&quot;&quot;</span>
   <span class="k">else</span> <span class="p">:</span>
      <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower</span> <span class="o">+</span> <span class="n">upper</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
      <span class="k">if</span>  <span class="n">v</span> <span class="o">==</span> <span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">:</span>  <span class="c"># found v at a[index] ?</span>
         <span class="n">answer</span> <span class="o">=</span> <span class="n">index</span>
         <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         {  assert:  a[answer] == v</span>
<span class="sd">            implies: search_post }</span>
<span class="sd">         &quot;&quot;&quot;</span>
      <span class="k">elif</span>  <span class="n">v</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">:</span>
         <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         {  assert:  v &gt; a[index]  ^  search_pre</span>
<span class="sd">            implies: FORALL 0 &lt;= i &lt;= index, a[i] &lt; v</span>
<span class="sd">            implies: [index+1/lower]search_pre  }</span>
<span class="sd">         &quot;&quot;&quot;</span>
         <span class="n">answer</span> <span class="o">=</span> <span class="n">searchFor</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>
         <span class="sd">&quot;&quot;&quot;{  assert:  search_post  }&quot;&quot;&quot;</span>
      <span class="k">else</span> <span class="p">:</span>  <span class="c"># a[index] &lt; v</span>
         <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         {  assert:   a[index] &lt; v  ^  search_pre</span>
<span class="sd">            implies:  FORALL index &lt;= j &lt; len(a), v &lt; a[j]</span>
<span class="sd">            implies:  [index-1/upper]search_pre  }</span>
<span class="sd">         &quot;&quot;&quot;</span>
         <span class="n">answer</span> <span class="o">=</span> <span class="n">searchFor</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
         <span class="sd">&quot;&quot;&quot;{  assert:  search_post  }&quot;&quot;&quot;</span>
   <span class="sd">&quot;&quot;&quot;{  assert: search_post  }&quot;&quot;&quot;</span>
   <span class="k">return</span> <span class="n">answer</span>
</pre></div>
</div>
<p>To search array, <code class="docutils literal"><span class="pre">a</span></code>, for <code class="docutils literal"><span class="pre">v</span></code>, we start the function like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">search</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The precondition is the key: to use correctly <code class="docutils literal"><span class="pre">search(v,</span> <span class="pre">lower,</span> <span class="pre">upper)</span></code>,
we must already know that <code class="docutils literal"><span class="pre">v</span></code> is not in <code class="docutils literal"><span class="pre">a[0]...a[lower-1]</span></code> and not in
<code class="docutils literal"><span class="pre">a[upper+1...a[len(a)-1]</span></code> &#8211; we have already narrowed the search to the range
of <code class="docutils literal"><span class="pre">a[lower]...a[upper]</span></code>.
The function builds on this fact to narrow further the search in subsequent
self-calls until <code class="docutils literal"><span class="pre">v</span></code> is found or there is an empty range left to search.</p>
<p>The previous two examples display a style of documentation that is used when
correctness is critical and one is unable to perform enough testing to generate
high confidence that the coding is correctly &#8211; the program must be correct from
the first time is it used.
Such an approach is taken with safety-critical systems, where money and life
depend on the correct functioning of software from the moment it is installed.</p>
</div>
<div class="section" id="maintaining-a-board-game-programming-by-contract">
<h3>8.4.3. Maintaining a Board Game: Programming by Contract<a class="headerlink" href="#maintaining-a-board-game-programming-by-contract" title="Permalink to this headline">¶</a></h3>
<p>Many programs maintain a data structure like an edit buffer or a spreadsheet or
a game board.
Typically, the data structure is grouped with its maintenance functions (in its
own module or class).
This is often called the <em>model component</em>, because the data structure is a
computerized &#8220;model&#8221; of a real-life object.
Next, there is a <em>controller component</em> (module/class) that interacts with the
user and calls the maintenance functions in the model component.
(The controller sets the protocol and &#8220;controls&#8221; and &#8220;connects&#8221; the interactions
between user and model.)
If there is a graphical user interface to paint and maintain, yet another
component, called the <em>view</em>, must be written.
This trio of components forms a standard software architecture, called the
<em>Model-View-Controller (MVC)</em> architecture.</p>
<p>To build such a system, we must document the internal structure and connection
points of each component so that the system can be connected correctly.
This documentation is exactly the pre- and post-conditions for the functions in
each component as well as the invariants for the data structures therein.</p>
<p>Here is a small example.
It is an implementation of a tic-tac-toe game that follows the usual rules.</p>
<p>First, there is the model module, which models the game board as an array.
The game board has an important invariant that ensures that only legal game
tokens are placed on the board.
There is another data structure in this module that remembers the history of
moves made on the board.
Both data structures are documented with their invariants.
(If you are programming in an object-oriented language and have written a class
to model the game board, you call the data-structure invariants, class
invariants.)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">module GameBoard  models a Tic-Tac-Toe board.</span>

<span class="sd">There are two key data structures:</span>
<span class="sd">--- board,  the game board, which holds the players&#39; moves</span>
<span class="sd">--- history,  a list of all the moves made during the game</span>

<span class="sd">The data structures are managed by calling the functions defined</span>
<span class="sd">in this module.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c"># The game players:</span>
<span class="n">X</span> <span class="o">=</span> <span class="s">&quot;X&quot;</span>
<span class="n">O</span> <span class="o">=</span> <span class="s">&quot;O&quot;</span>
<span class="n">NOBODY</span> <span class="o">=</span> <span class="s">&quot;neither player&quot;</span>

<span class="c">###### The game board, a matrix sized  dimension x dimension:</span>
<span class="n">EMPTY</span> <span class="o">=</span> <span class="s">&quot;_&quot;</span>     <span class="c"># marks an empty square on the board</span>
<span class="n">dimension</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">BOARDSIZE</span> <span class="o">=</span> <span class="n">dimension</span> <span class="o">*</span> <span class="n">dimension</span>
<span class="c"># the board itself:</span>
<span class="n">board</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c"># construct the board with this loop:</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">dimension</span> <span class="p">:</span>
    <span class="n">board</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimension</span> <span class="o">*</span> <span class="p">[</span><span class="n">EMPTY</span><span class="p">])</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ global invariant for board:  Only legal markers are placed on it</span>
<span class="sd">      ALL 0 &lt; i,j &lt; dimension,</span>
<span class="sd">          board[i][j] == X  v  board[i][j] == O  v  board[i][j] == EMPTY }</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c">#### A history log of all the moves:  it is a list of  Marker, Row, Col  tuples:</span>
<span class="n">history</span> <span class="o">=</span> <span class="p">[]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ global invariant for history:  All moves in  history  recorded in  board</span>
<span class="sd">      forall 0 &lt; i &lt; len(history), history[i]==(m,r,c)  and  board[r,c] == m }</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c">### Functions that manage the  board  and  history:</span>

<span class="k">def</span> <span class="nf">printBoard</span><span class="p">()</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;prints the board on the display&quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    {  pre   true</span>
<span class="sd">       post  forall 0 &lt;= i,j &lt; dimension, board[i][j] is printed  }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">board</span> <span class="p">:</span>
        <span class="k">for</span> <span class="n">square</span> <span class="ow">in</span> <span class="n">row</span> <span class="p">:</span>
            <span class="k">if</span> <span class="n">square</span> <span class="o">!=</span> <span class="n">EMPTY</span> <span class="p">:</span>
                <span class="k">print</span> <span class="n">square</span><span class="p">,</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="k">print</span> <span class="n">counter</span><span class="p">,</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">print</span>
    <span class="k">print</span>
    <span class="c">#print history</span>


<span class="k">def</span> <span class="nf">emptyAt</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    examines the ith square on board;  returns whether it equals EMPTY.</span>

<span class="sd">    params: position - an int that falls between 0 and the BOARDSIZE</span>
<span class="sd">    returns: whether or not square number  position on  board  is EMPTY</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    { pre   0 &lt;= position &lt; BOARDSIZE</span>
<span class="sd">      post  answer == (board[position/dimension][position%dimension] == EMPTY) }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">position</span><span class="o">/</span><span class="n">dimension</span><span class="p">,</span> <span class="n">position</span><span class="o">%</span><span class="n">dimension</span><span class="p">)</span>
    <span class="k">if</span>  <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">row</span>  <span class="ow">and</span>  <span class="n">row</span> <span class="o">&lt;</span> <span class="n">dimension</span>  <span class="ow">and</span>  <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">col</span>  <span class="ow">and</span>  <span class="n">col</span> <span class="o">&lt;</span> <span class="n">dimension</span> \
       <span class="ow">and</span>  <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="n">EMPTY</span> <span class="p">:</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="n">answer</span>


<span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="n">marker</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    attempts to move  marker  into the board at  position</span>

<span class="sd">    params: marker - a string, should be  X  or  O</span>
<span class="sd">            position -- an int, should be between 0 and the BOARDSIZE</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    {  pre   ((marker == X) v (marker == O)) &amp;  (0 &lt;= position &lt; BOARDSIZE)</span>
<span class="sd">       post  invariants for board and history are maintained }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">history</span><span class="p">,</span> <span class="n">board</span>   <span class="c"># because we update these global variabes,</span>
                            <span class="c"># we are OBLIGATED to maintain their invariants!</span>
    <span class="k">if</span> <span class="n">emptyAt</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="p">:</span>
        <span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">position</span><span class="o">/</span><span class="n">dimension</span><span class="p">,</span> <span class="n">position</span><span class="o">%</span><span class="n">dimension</span><span class="p">)</span>
        <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">marker</span>
        <span class="n">history</span> <span class="o">=</span> <span class="n">history</span> <span class="o">+</span> <span class="p">[(</span><span class="n">marker</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)]</span>
    <span class="k">else</span> <span class="p">:</span>
       <span class="k">pass</span>

<span class="k">def</span> <span class="nf">winnerIs</span><span class="p">(</span><span class="n">mark</span><span class="p">)</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    checks the game board to see if  mark  is the winner.</span>

<span class="sd">    parameter:  mark - a string, should be  X  or  O</span>
<span class="sd">    returns:    mark,  if it fills a complete row, column, or diagonal of</span>
<span class="sd">                 the board;  returns  NOBODY, otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    {  pre:  (mark == X) v (mark == O)</span>
<span class="sd">       post: (answer == mark --&gt;  mark has filled a row or column or diagonal)</span>
<span class="sd">             and  (answer == NOBODY) --&gt; mark has not filled any row/col/diag }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">winnerAlong</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;sees if all the elements in  vector  are filled by  mark&quot;&quot;&quot;</span>
        <span class="n">check</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">):</span>
            <span class="n">check</span> <span class="o">=</span> <span class="n">check</span> <span class="ow">and</span> <span class="p">(</span><span class="n">vector</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">mark</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">check</span>

    <span class="c"># check  row i  and  column i  for  i in 0,1,...,dimension-1:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span> <span class="p">:</span>
        <span class="n">columni</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">):</span>
            <span class="n">columni</span> <span class="o">=</span> <span class="n">columni</span> <span class="o">+</span> <span class="p">[</span><span class="n">board</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">winnerAlong</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">or</span> <span class="n">winnerAlong</span><span class="p">(</span><span class="n">columni</span><span class="p">)</span> <span class="p">:</span>
            <span class="k">return</span> <span class="n">mark</span>

    <span class="c"># check the left and right diagonals:</span>
    <span class="n">ldiag</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">rdiag</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">):</span>
        <span class="n">ldiag</span> <span class="o">=</span> <span class="n">ldiag</span> <span class="o">+</span> <span class="p">[</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">rdiag</span> <span class="o">=</span> <span class="n">rdiag</span> <span class="o">+</span> <span class="p">[</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][(</span><span class="n">dimension</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">winnerAlong</span><span class="p">(</span><span class="n">ldiag</span><span class="p">)</span> <span class="ow">or</span> <span class="n">winnerAlong</span><span class="p">(</span><span class="n">rdiag</span><span class="p">)</span> <span class="p">:</span>
        <span class="k">return</span> <span class="n">mark</span>
    <span class="c"># else, no winner, so</span>
    <span class="k">return</span> <span class="n">NOBODY</span>
</pre></div>
</div>
<p>The data-structure invariants establish the internal well-formedness of the game
board, and the maintenance functions <em>are obligated to preserve and maintain the
invariants</em>.
In addition, each function is documented with its own pre-post conditions that
specify how the function should be called and what the function guarantees if it
is called correctly.
In the above coding, both informal English and formal logical specifications are
written.
Whether one writes English or logic depends on how critical absolute correctness
might be.
(Frankly, some programs, e.g., toys and games, need not be absolutely correct.)</p>
<p>The other module of this little example is the main program &#8212; the controller
module &#8212; which enforces the rules of the game, that is, the proper interaction
of the game&#8217;s players with the game board.
The controller&#8217;s main loop has its own invariant that asserts this point.
The loop</p>
<ol class="arabic simple">
<li>displays the game board</li>
<li>requests a player&#8217;s next move</li>
<li>implements the move on the board</li>
</ol>
<p>Study the loop invariant first before you study anything else.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;The Main module controls the tic-tac-toe game.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">GameBoard</span>
<span class="kn">from</span> <span class="nn">GameBoard</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">readInt</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    readInt is a helper function that reads an int from the display.</span>
<span class="sd">    If we had a View Module that painted a GUI, this function would</span>
<span class="sd">    be found there.</span>

<span class="sd">    param: message a string</span>
<span class="sd">    returns: an int, denoting the number typed by a player</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    {  pre:  message:String</span>
<span class="sd">       post: answer:int  }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">needInput</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
    <span class="k">while</span> <span class="n">needInput</span> <span class="p">:</span>
        <span class="n">text</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">text</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="p">:</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="n">needInput</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="n">answer</span>

<span class="n">player</span> <span class="o">=</span> <span class="n">X</span>       <span class="c"># whose turn is it?  who goes first?</span>
<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>        <span class="c"># how many moves have been made?</span>
<span class="n">winner</span> <span class="o">=</span> <span class="n">NOBODY</span>  <span class="c"># who is the winner?</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{  loop invariant:  The rules of the tic-tac-toe game are enforced:</span>
<span class="sd">      (i) players take turns moving:</span>
<span class="sd">            forall 0 &lt;= i &lt; count,</span>
<span class="sd">               (i % 2)== 0 --&gt;  history[i][0] == X   and</span>
<span class="sd">               (i % 2)== 1 --&gt;  history[i][0] = O</span>
<span class="sd">      (ii) all moves are recorded on board:</span>
<span class="sd">             invariant for  history  remains true;</span>
<span class="sd">      (iii) board holds only legal game markers:</span>
<span class="sd">             invariant for  board  remains true</span>
<span class="sd">        (NOTE: (ii) and (iii) should hold _automatically provided</span>
<span class="sd">        that we use the board&#39;s maintenance functions.) }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="k">while</span> <span class="n">winner</span> <span class="o">==</span> <span class="n">NOBODY</span>  <span class="ow">and</span>  <span class="n">count</span> <span class="o">!=</span> <span class="n">BOARDSIZE</span> <span class="p">:</span>

    <span class="n">printBoard</span><span class="p">()</span>

    <span class="c"># get the next move:</span>
    <span class="n">awaitingMove</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">while</span> <span class="n">awaitingMove</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        { invariant</span>
<span class="sd">                  awaitingMove --&gt; (0 &lt;= m &lt; BOARDSIZE) and emptyAt(m) }</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s">&quot;Player &quot;</span> <span class="o">+</span> <span class="n">player</span> <span class="o">+</span>  \
                    <span class="s">&quot;: type next move (0..&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">BOARDSIZE</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;): &quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">BOARDSIZE</span><span class="p">)</span> <span class="ow">and</span> <span class="n">emptyAt</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">:</span>
            <span class="n">awaitingMove</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="c"># we have received a legal move:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    { assert: ((player == X) v (player == O))</span>
<span class="sd">              and (0 &lt;= m &lt; BOARDSIZE) and  emptyAt(m)</span>
<span class="sd">      implies:  [player/marker][m/position]move_pre  }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">move</span><span class="p">(</span><span class="n">player</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    {  assert:  movepost, that is,</span>
<span class="sd">       invariants for  board  and   history  are maintained }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># determine whether this player is the winner:</span>
    <span class="n">winner</span> <span class="o">=</span> <span class="n">winnerIs</span><span class="p">(</span><span class="n">player</span><span class="p">)</span>

    <span class="c"># switch players for the next round:</span>
    <span class="k">if</span> <span class="n">player</span> <span class="o">==</span> <span class="n">X</span> <span class="p">:</span>
        <span class="n">player</span> <span class="o">=</span> <span class="n">O</span>
    <span class="k">else</span> <span class="p">:</span>
        <span class="n">player</span> <span class="o">=</span> <span class="n">X</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="sd">&quot;&quot;&quot;{ assert: loop invariant, all 3 parts, holds }&quot;&quot;&quot;</span>

<span class="c"># the loop quit, and the game&#39;s over:</span>
<span class="k">print</span> <span class="n">winner</span> <span class="o">+</span> <span class="s">&quot; won!&quot;</span>
<span class="n">printBoard</span><span class="p">()</span>
</pre></div>
</div>
<p>Note how the controller uses the pre-post-conditions for the board&#8217;s maintenance
functions to fulfill its own invariants.
In this way, we depend on the documentation from one module to program correctly
another.
Programming in this style is sometimes called <em>programming by contract</em>.</p>
</div>
</div>
<div class="section" id="equivalences-in-predicate-logic">
<h2>8.5. Equivalences in Predicate Logic<a class="headerlink" href="#equivalences-in-predicate-logic" title="Permalink to this headline">¶</a></h2>
<p>Here are some important equivalences in predicate logic.
(We include the <code class="docutils literal"><span class="pre">Pbc</span></code>-rule to prove the third and fourth ones.)</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">FORALLx</span> <span class="pre">FORALLy</span> <span class="pre">P_xy</span> <span class="pre">-||-</span> <span class="pre">FORALLy</span> <span class="pre">FORALLx</span> <span class="pre">P_xy</span></code></li>
<li><code class="docutils literal"><span class="pre">EXISTx</span> <span class="pre">EXISTy</span> <span class="pre">P_xy</span> <span class="pre">-||-</span> <span class="pre">EXISTy</span> <span class="pre">EXISTx</span> <span class="pre">P_xy</span></code></li>
<li><code class="docutils literal"><span class="pre">~(FORALLx</span> <span class="pre">P_x)</span> <span class="pre">-||-</span> <span class="pre">EXISTx</span> <span class="pre">~P_x</span></code></li>
<li><code class="docutils literal"><span class="pre">~(EXISTx</span> <span class="pre">P_x)</span> <span class="pre">-||-</span> <span class="pre">FORALLx</span> <span class="pre">~P_x</span></code></li>
<li><code class="docutils literal"><span class="pre">Q</span> <span class="pre">^</span> <span class="pre">(FORALLx</span> <span class="pre">P_x)</span> <span class="pre">-||-</span> <span class="pre">FORALLx</span> <span class="pre">(Q</span> <span class="pre">^</span> <span class="pre">P_x)</span> <span class="pre">(where</span> <span class="pre">x</span> <span class="pre">does</span> <span class="pre">not</span> <span class="pre">appear</span> <span class="pre">in</span> <span class="pre">Q)</span></code></li>
<li><code class="docutils literal"><span class="pre">Q</span> <span class="pre">v</span> <span class="pre">(FORALLx</span> <span class="pre">P_x)</span> <span class="pre">-||-</span> <span class="pre">FORALLx</span> <span class="pre">(Q</span> <span class="pre">v</span> <span class="pre">P_x)</span> <span class="pre">(where</span> <span class="pre">x</span> <span class="pre">does</span> <span class="pre">not</span> <span class="pre">appear</span> <span class="pre">in</span> <span class="pre">Q)</span></code></li>
<li><code class="docutils literal"><span class="pre">Q</span> <span class="pre">^</span> <span class="pre">(EXISTx</span> <span class="pre">P_x)</span> <span class="pre">-||-</span> <span class="pre">EXISTx</span> <span class="pre">(Q</span> <span class="pre">^</span> <span class="pre">P_x)</span> <span class="pre">(where</span> <span class="pre">x</span> <span class="pre">does</span> <span class="pre">not</span> <span class="pre">appear</span> <span class="pre">in</span> <span class="pre">Q)</span></code></li>
<li><code class="docutils literal"><span class="pre">Q</span> <span class="pre">v</span> <span class="pre">(EXISTx</span> <span class="pre">P_x)</span> <span class="pre">-||-</span> <span class="pre">EXISTx</span> <span class="pre">(Q</span> <span class="pre">v</span> <span class="pre">P_x)</span> <span class="pre">(where</span> <span class="pre">x</span> <span class="pre">does</span> <span class="pre">not</span> <span class="pre">appear</span> <span class="pre">in</span> <span class="pre">Q)</span></code></li>
</ul>
</div>
<div class="section" id="predicate-logic-without-the-existential-quantifier-skolem-functions">
<h2>8.6. Predicate Logic Without The Existential Quantifier: Skolem Functions<a class="headerlink" href="#predicate-logic-without-the-existential-quantifier-skolem-functions" title="Permalink to this headline">¶</a></h2>
<p>Complexity arises in predicate logic when a proposition contains a mix of
<code class="docutils literal"><span class="pre">FORALL</span></code> and <code class="docutils literal"><span class="pre">EXIST</span></code>.
Recall that <code class="docutils literal"><span class="pre">FORALLx</span> <span class="pre">EXISTy</span> <span class="pre">P(x,y)</span></code> asserts that each element named by <code class="docutils literal"><span class="pre">x</span></code>
&#8220;has its own personal&#8221; <code class="docutils literal"><span class="pre">y</span></code> to make <code class="docutils literal"><span class="pre">P(x,y)</span></code> true.
(&#8220;Everyone has a boss.&#8221;)
In contrast, <code class="docutils literal"><span class="pre">EXISTy</span> <span class="pre">FORALLx</span> <span class="pre">P(x,y)</span></code> identifies one single individual that is
related to all elements, <code class="docutils literal"><span class="pre">x</span></code>, to make <code class="docutils literal"><span class="pre">P(x,y)</span></code> true.
(&#8220;There is one boss who is the boss of everyone.&#8221;)</p>
<p>Logicians have developed a form of predicate logic that omits the existential
quantifier and uses instead terms called <em>Skolem functions</em> to name the values
represented by each <code class="docutils literal"><span class="pre">EXISTy</span></code>.
A Skolem function is a function name that is used to designate where an
existential quantifier should appear.
Examples explain the idea best:</p>
<div class="highlight-python"><div class="highlight"><pre>Everyone has a boss:                     FORALLx EXISTy P(x,y)
(expressed with a Skolem function,
  named  boss:)                          FORALLx P(x, boss(x))

There is a single boss of everyone:      EXISTy FORALLx P(x,y)
(expressed with a Skolem function,
  named  bigb:)                          FORALLx P(x, bigb())

For every husband and wife, there
is a minister who married them:          FORALLx FORALLy EXISTz M(z,x,y)
(expressed with a Skolem function,
named minister:)                         FORALLx FORALLy M(minister(x,y),x,y)

Every two ints can be added into
a sum:                                   FORALLx FORALLy EXISTz F(x,y,z)
(expressed with a Skolem function,
named sum:)                              FORALLx FORALLy F(x,y,sum(x,y))

Every boss has a secretary,
who talks with everyone:                 FORALLx EXISTy (isSec(y) ^ FORALLz talks(x,z))
(expressed with a Skolem function,
named  s:)                               FORALLx (isSec(s(x)) ^ FORALLz talks(s(x),z))
</pre></div>
</div>
<p>The examples show how the Skolem function acts as a &#8220;witness&#8221; to the missing
<code class="docutils literal"><span class="pre">EXIST</span></code> without revealing the identity of the individual discussed.
You can also see the difference in the first two examples between <code class="docutils literal"><span class="pre">boss(x)</span></code>
and <code class="docutils literal"><span class="pre">bigb()</span></code> &#8211; the first example makes clear how the boss is a function of
which <code class="docutils literal"><span class="pre">x</span></code> in the domain is considered;
the second one makes clear that the boss is independent of all the individuals
in the domain.</p>
<p>It is possible to work proofs in predicate logic with Skolem functions.
Here are two examples:</p>
<div class="highlight-python"><div class="highlight"><pre>FORALLx isMortal(x) --&gt; hasSoul(x),  isMortal(socrates()) |- hasSoul(t())

1. FORALLx isMortal(x) --&gt; hasSoul(x)              premise
2. isMortal(socrates())                            premise
3. isMortal(socrates()) --&gt; hasSoul(socrates())     FORALLe 1
4. hasSoul(socrates())                             --&gt;e 3,2
6. hasSoul(t())                                    def t(): return socrates()
</pre></div>
</div>
<p>Here, the individual, <code class="docutils literal"><span class="pre">Socrates</span></code>, is represented as a constant Skolem
function, <code class="docutils literal"><span class="pre">socrates()</span></code>.
The key step is the last one, where the desired Skolem function, <code class="docutils literal"><span class="pre">t()</span></code>, is
defined in terms of <code class="docutils literal"><span class="pre">socrates()</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">t</span><span class="p">()</span> <span class="p">:</span>
    <span class="k">return</span> <span class="n">socrates</span><span class="p">()</span>
</pre></div>
</div>
<p>This function definition takes the place of <code class="docutils literal"><span class="pre">EXISTi</span></code>.</p>
<p>In the previous example, we could have read <code class="docutils literal"><span class="pre">isMortal(socrates())</span></code> as a
shorthand for <code class="docutils literal"><span class="pre">EXISTsocrates</span> <span class="pre">(isMortal(socrates))</span></code>.
Now, there is no practical difference.</p>
<p>Here is the boss-worker example (&#8220;if someone is the boss of everyone, then
everyone has a boss&#8221;):</p>
<div class="highlight-python"><div class="highlight"><pre>FORALLx isBossOf(x, big()) |- FORALLx isBossOf(x, b(x))

1. FORALLx isBossOf(x, big())     premise
... 2. a
... 3. isBossOf(a, big())         FORALLe 1
... 4. hasBoss(a, b(a))           def b(a): return big()
5. FORALLx is BossOf(x, b(x))     FORALLi 2-4
</pre></div>
</div>
<p>Notice how the defined Skolem function, <code class="docutils literal"><span class="pre">b(a)</span></code>, disregards its argument and
always returns <code class="docutils literal"><span class="pre">big()</span></code> as its answer.
This is because <code class="docutils literal"><span class="pre">big()</span></code> is truly <code class="docutils literal"><span class="pre">a</span></code>&#8216;s boss, no matter what argument is
assigned to parameter <code class="docutils literal"><span class="pre">a</span></code>.</p>
<p>Like before, it is impossible to prove
<code class="docutils literal"><span class="pre">FORALLx</span> <span class="pre">isBossOf(x,</span> <span class="pre">b(x))</span> <span class="pre">|-</span> <span class="pre">FORALLx</span> <span class="pre">isBossOf(x,</span> <span class="pre">big())</span></code> &#8211; there is no way
to define a Skolem function, <code class="docutils literal"><span class="pre">def</span> <span class="pre">big()</span> <span class="pre">:</span> <span class="pre">...</span> <span class="pre">b(x)</span> <span class="pre">...</span></code>, because a value for
parameter <code class="docutils literal"><span class="pre">x</span></code> is required.
In this way, the Skolem functions &#8220;remember&#8221; the placement and use of the
original existential quantifiers.</p>
<p>The technical reasoning why Skolem functions work correctly requires so-called
Herbrand models and the Henkin completeness theorem.
But the programming intuition given here &#8212; defining Skolem functions as Python
functions &#8212; works surprisingly well.</p>
</div>
<div class="section" id="resolution-theorem-proving-for-predicate-logic">
<h2>8.7. Resolution Theorem Proving for Predicate Logic<a class="headerlink" href="#resolution-theorem-proving-for-predicate-logic" title="Permalink to this headline">¶</a></h2>
<p>Skolem functions make it possible to adapt the resolution-theorem-proving
technique from the previous chapter to predicate logic.
The key idea is to convert all propositions into and-or form, remove the
existential quantifers, then <em>move and remove</em> the universal quantifiers (!),
then complete the transformation into conjunctive normal form (cnf).
Then, we can perform resolution theorem proving with the aid of <em>unification</em>
(two-way matching) of Skolem functions.</p>
<div class="section" id="conversion-into-clause-form">
<h3>8.7.1. Conversion into clause form<a class="headerlink" href="#conversion-into-clause-form" title="Permalink to this headline">¶</a></h3>
<p>CNF for predicate calculus is called <em>clause form</em>.
We achieve clause form in these steps:</p>
<ol class="arabic">
<li><p class="first">First, rename as needed all variables, <code class="docutils literal"><span class="pre">x</span></code>, used within all quantifiers,
<code class="docutils literal"><span class="pre">FORALLx</span></code> and <code class="docutils literal"><span class="pre">EXISTx</span></code>, so that each occurrence of a quantifier appears
with a unique variable name.</p>
</li>
<li><p class="first">Remove all implications, <code class="docutils literal"><span class="pre">A</span> <span class="pre">--&gt;</span> <span class="pre">B</span></code>, with this equivalence:</p>
<div class="highlight-python"><div class="highlight"><pre>A --&gt; B  -||-  ~A v B
</pre></div>
</div>
</li>
<li><p class="first">Next, move all remaining negation operators inwards, by repeatedly applying
these equivalences:</p>
<div class="highlight-python"><div class="highlight"><pre>~(A ^ B)  -||-  ~A v ~B
~(A v B)  -||-  ~A ^ ~B
~(FORALLx A) -||- EXISTx ~A
~(EXISTx A) -||- FORALLx ~A
</pre></div>
</div>
<p>and wherever it appears, replace <code class="docutils literal"><span class="pre">~~A</span></code> by <code class="docutils literal"><span class="pre">A</span></code>.</p>
</li>
<li><p class="first">Remove all existential quantifiers, replacing their variables by Skolem
functions.</p>
</li>
<li><p class="first">Use these equivalences to move all occurrences of universal quantifiers to
the leftmost position of the proposition:</p>
<div class="highlight-python"><div class="highlight"><pre>Q ^ (FORALLx P_x) -||- FORALLx (Q ^ P_x)
Q v (FORALLx P_x) -||- FORALLx (Q v P_x)
</pre></div>
</div>
<p>(This is called <em>prenex form</em>.)
Now, <em>remove the quantifiers</em> because they are no longer needed (!).</p>
</li>
<li><p class="first">At this point, all quantifiers are removed, and the proposition is a
combination of conjunctions, disjunctions, and negations attached to
primitive propositions that hold Skolem functions.
To finish, apply this equivalence to move all disjunction operators inward:</p>
<div class="highlight-python"><div class="highlight"><pre>(A ^ B) v C  -||-  (A v C)  ^  (B v C)
</pre></div>
</div>
</li>
</ol>
<p>Here is an example conversion:
<code class="docutils literal"><span class="pre">(EXISTy</span> <span class="pre">FORALLx</span> <span class="pre">isBossOf(y,x))</span> <span class="pre">--&gt;</span> <span class="pre">(EXISTx</span> <span class="pre">isBossOf(x,x))</span></code></p>
<div class="highlight-python"><div class="highlight"><pre>1. (EXISTy FORALLx isBossOf(y,x)) --&gt; (EXISTz isBossOf(z,z))

2. ~(EXISTy FORALLx isBossOf(y,x))  v (EXISTz isBossOf(z,z))

3. (FORALLy ~FORALLx isBossOf(y,x))  v (EXISTz isBossOf(z,z))
   (FORALLy EXISTx ~isBossOf(y,x))  v (EXISTz isBossOf(z,z))

4. (FORALLy ~isBossOf(y, x(y))   v  isBossOf(z(),z())

5. FORALLy ( ~isBossOf(y, x(y))   v  isBossOf(z(),z()) )

   (~isBossOf(y, x(y)))  v  isBossOf(z(),z())

6. (no need to rearrange any ^s and vs)
</pre></div>
</div>
<p>At this point, we can apply the resolution algorithm.
The resolution rule is slightly modified to handle the variables and Skolem
functions: a form of two-way matching, called <em>unification</em>, is used to apply
the <code class="docutils literal"><span class="pre">FORALLe</span></code> rule to variables and Skolem functions:</p>
<div class="highlight-python"><div class="highlight"><pre>        A v P(E1)    ~P(E2) v B    matches = unify(E1,E2)
res:  ---------------------------------------------------------
             [matches](A v B)
</pre></div>
</div>
<p>Since <code class="docutils literal"><span class="pre">P</span></code> is now a predicate (like <code class="docutils literal"><span class="pre">isBossOf</span></code> or <code class="docutils literal"><span class="pre">isMortal</span></code> or <code class="docutils literal"><span class="pre">&gt;</span></code>),
we must unify the arguments <code class="docutils literal"><span class="pre">E1</span></code> and <code class="docutils literal"><span class="pre">E2</span></code> in <code class="docutils literal"><span class="pre">P(E1)</span></code> and <code class="docutils literal"><span class="pre">P(E2)</span></code> so that
they become one and the same.
It works like this: For example,</p>
<div class="highlight-python"><div class="highlight"><pre>for  isMortal(soc())   ~isMortal(z),      unify(soc(),z) =  [z=soc()]

for  isMortal(x)       ~isMortal(y),      unify(x,y) = [x=y]

for  isBoss(a(),x)     ~isBoss(y,b()),    unify((a(),x), (y,b())) = [y=a(), x=b()]

for  isBoss(a(),x)     ~isBoss(b(),b()),  unify((a(),x), (b(),b())) = FAILURE
</pre></div>
</div>
<p>The matches that are computed are applied to the remaining clauses.
For example:</p>
<div class="highlight-python"><div class="highlight"><pre>~P(x) v Q(x)        P(a())
-------------------------------
             Q(a())
</pre></div>
</div>
<p>because <code class="docutils literal"><span class="pre">matches(x,a())</span> <span class="pre">=</span> <span class="pre">[x=a()],</span> <span class="pre">so</span> <span class="pre">[x=a()]Q(x)</span></code> is <code class="docutils literal"><span class="pre">Q(a())</span></code>.</p>
<p>We apply the revised resolution rule to proving contradictions, like we did with
propositional logic.
The resolution rule plus unification searches for a witness to a contradiction.</p>
<p>Here are two examples of resolution proofs conducted with unification:</p>
<div class="highlight-python"><div class="highlight"><pre>FORALLx (P(x) --&gt; Q(x)),  EXISTy P(y)  |-  EXISTz Q(z)

The clauses resulting from the two premises and negated goal are
   ~P(x) v Q(x),   P(y()),   ~Q(z)

The resolution proof goes

~P(x) v Q(x)    P(y())    ~Q(z)
      |              |         |
      +--------------+         |
            | [x=y()]          |
           Q(y())              |
            |                  |
            +------------------+
                    | [z=y()]
                   []
</pre></div>
</div>
<p>Here is another example, the workers-and-bosses proof:</p>
<div class="highlight-python"><div class="highlight"><pre>EXISTy FORALLx isBossOf(y,x)  |-  FORALLu EXISTv isBossOf(v,u)

      isBossOf(y(),x)              ~isBossOf(v, u())
           |                        |
           +------------------------+
                      | [v=y(), x=u()]
                     []
</pre></div>
</div>
<p>Because a clause can be used more than once in a proof, and because a variable
can be set to a new value each time it is unified in a resolution step, there is
no guarantee that the algorithm will always terminate with success or failure.
This is not a flaw of the algorithm &#8211; predicate logic is <em>incomplete</em> in that
there can be no algorithm that can decide whether or not a sequent can be
proved.
Resolution is about as good as we can do in this regard.</p>
</div>
</div>
<div class="section" id="soundness-and-completeness-of-deduction-rules">
<h2>8.8. Soundness and Completeness of Deduction Rules<a class="headerlink" href="#soundness-and-completeness-of-deduction-rules" title="Permalink to this headline">¶</a></h2>
<p>Once again, it is time to consider what propositions mean and how it is that
<code class="docutils literal"><span class="pre">FORALLi</span></code>, <code class="docutils literal"><span class="pre">FORALLe</span></code>, <code class="docutils literal"><span class="pre">EXISTi</span></code>, <code class="docutils literal"><span class="pre">EXISTe</span></code> preserve meaning.</p>
<p>At this point, it would be good to review the section on models for
<a class="reference internal" href="../07-propositional-logic/index.html#propositional-logic"><span>Applications of Propositional Logic to Program Proving</span></a>.
There, we saw that the connectives, <code class="docutils literal"><span class="pre">^</span></code>, <code class="docutils literal"><span class="pre">v</span></code>, <code class="docutils literal"><span class="pre">~</span></code>, <code class="docutils literal"><span class="pre">--&gt;</span></code> were understood
in terms of truth tables.
Also, the primitive propositions were just letters like <code class="docutils literal"><span class="pre">P</span></code>, <code class="docutils literal"><span class="pre">Q</span></code>, and <code class="docutils literal"><span class="pre">R</span></code>,
which were interpreted as either True or False.</p>
<p>Within predicate logic, we use predicates, like <code class="docutils literal"><span class="pre">isMortal()</span></code> and <code class="docutils literal"><span class="pre">&gt;</span></code>, to
build propsitions, and we might also use functions, like <code class="docutils literal"><span class="pre">+</span></code>, within the
predicates.
We must give meanings to all predicates and functions so that we can decide
whether propositions like <code class="docutils literal"><span class="pre">isMortal(God)</span></code> and <code class="docutils literal"><span class="pre">(3+1)&gt;x</span></code> are True or False.
The act of giving meanings to the predicates and functions is called an
<em>interpretation</em>.</p>
<div class="section" id="interpretations">
<h3>8.8.1. Interpretations<a class="headerlink" href="#interpretations" title="Permalink to this headline">¶</a></h3>
<p>When we write propositions in a logic, we use predicates and function symbols
(e.g., <code class="docutils literal"><span class="pre">FORALLi</span> <span class="pre">(i*2)&gt;i</span></code>).
An interpretation gives the meaning of</p>
<ol class="arabic simple">
<li>the underlying domain &#8211; what set of elements it names;</li>
<li>each function symbol &#8211; what answers it computes from its arguments from the
domain; and</li>
<li>each predicate &#8211; which combinations of arguments from the domain lead to
True answers and False answers.</li>
</ol>
<p>Here is an example.
Say we have the function symbols, <code class="docutils literal"><span class="pre">+</span></code>,``-<code class="docutils literal"><span class="pre">,``*</span></code>,``/<code class="docutils literal"><span class="pre">,</span> <span class="pre">and</span> <span class="pre">predicate</span>
<span class="pre">symbols,</span> <span class="pre">``&gt;</span></code>,``=``.
What do these names and symbols mean?
We must interpret them.</p>
<ul class="simple">
<li>The standard interpretation of arithmetic is that int names the set of all
integers; <code class="docutils literal"><span class="pre">+</span></code>,``-<code class="docutils literal"><span class="pre">,``*</span></code>,``/`` name integer addition, subtraction,
multiplication, and division, and <code class="docutils literal"><span class="pre">=</span></code> and <code class="docutils literal"><span class="pre">&gt;</span></code> name integer equality
comparison and integer less-than comparison.
With this interpretation of arithmetic, we can interpret propositions.
For example, <code class="docutils literal"><span class="pre">FORALLi</span> <span class="pre">(i*2)&gt;i</span></code> interprets to False, and
<code class="docutils literal"><span class="pre">EXISTj</span> <span class="pre">(j*j)=j</span></code> interprets to True.
If we use any extra, &#8220;constant names&#8221;, (e.g., <a href="#id13"><span class="problematic" id="id14">``</span></a>p``i), we must give meanings
to the constants, also.</li>
<li>Now, given function names <code class="docutils literal"><span class="pre">+</span></code>,``-<code class="docutils literal"><span class="pre">,``*</span></code>,``/<code class="docutils literal"><span class="pre">,</span> <span class="pre">and</span> <span class="pre">predicates,</span> <span class="pre">``=</span></code>,
<code class="docutils literal"><span class="pre">&gt;</span></code>, we can choose to interpret them in another way.
For example, we might interpret the underlying domain as just the nonnegative
integers.
We can interpret <code class="docutils literal"><span class="pre">+</span></code>,``*``,``/<code class="docutils literal"><span class="pre">,</span></code>&gt;``,``=`` as the usual operations on
ints, but we must give a different meaning to <code class="docutils literal"><span class="pre">-</span></code>.
We might define <code class="docutils literal"><span class="pre">m</span> <span class="pre">-</span> <span class="pre">n</span> <span class="pre">==</span> <span class="pre">0</span></code>, whenever <code class="docutils literal"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">m</span></code>.</li>
<li>Yet another interpretation is to say that the domain is just <code class="docutils literal"><span class="pre">{0,1}</span></code>;
the functions are the usual arithmetic operations on 0,1, modulo 2;
and <code class="docutils literal"><span class="pre">&gt;</span></code> is defined <code class="docutils literal"><span class="pre">1</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> (and that&#8217;s it).</li>
</ul>
<p>These three examples show that the symbols in a logic can be interpreted in
multiple different ways.
(In the Chapter on <a class="reference internal" href="../07-propositional-logic/index.html#propositional-logic"><span>Applications of Propositional Logic to Program Proving</span></a>, we called an interpretation a
&#8220;context&#8221;.
In this chapter, we see that a &#8220;context&#8221; is quite complex &#8211; domain, functions,
and predicates.)</p>
<p>Here is a second example.
There are no functions, and the predicates are <code class="docutils literal"><span class="pre">isMortal(_)</span></code>,
<code class="docutils literal"><span class="pre">isLeftHanded(_)</span></code>, <code class="docutils literal"><span class="pre">isMarriedTo(_,_)</span></code>.
An interpretation might make all (living) members of the human race as the
domain;
make <code class="docutils literal"><span class="pre">isMortal(h)</span></code> True for every human, <code class="docutils literal"><span class="pre">h</span></code>;
make <code class="docutils literal"><span class="pre">isLeftHanded(j)</span></code> True for exactly those humans, <code class="docutils literal"><span class="pre">j</span></code>, who are left
handed;
and set <code class="docutils literal"><span class="pre">isMarriedTo(m,f)</span></code> True for all pairs of humans <code class="docutils literal"><span class="pre">m</span></code>, <code class="docutils literal"><span class="pre">f</span></code>, who have
their marriage document in hand.</p>
<p>You get the idea....</p>
<p>We can ask whether a proposition is True within <em>one</em> specific interpretation,
and we can ask whether a proposition is True within <em>all possible</em>
interpretations.
This leads to the notions of soundness and completeness for predicate logic:</p>
<p>A sequent, <code class="docutils literal"><span class="pre">P_1,</span> <span class="pre">P_2,</span> <span class="pre">...,</span> <span class="pre">P_n</span> <span class="pre">|-</span> <span class="pre">Q</span></code> is <em>valid in an interpretation</em>, <code class="docutils literal"><span class="pre">I</span></code>,
provided that when all of <code class="docutils literal"><span class="pre">P_1,</span> <span class="pre">P_2,</span> <span class="pre">...,</span> <span class="pre">P_n</span></code> are True in interpretation
<code class="docutils literal"><span class="pre">I</span></code>, so is <code class="docutils literal"><span class="pre">Q</span></code>.
The sequent is valid exactly when it is valid in all possible interpretations.
We have these results for the rules of propositional logic plus
<code class="docutils literal"><span class="pre">FORALLi</span></code>, <code class="docutils literal"><span class="pre">FORALLe</span></code>, <code class="docutils literal"><span class="pre">EXISTi</span></code>, <code class="docutils literal"><span class="pre">EXISTe</span></code>:</p>
<ol class="arabic simple">
<li><em>soundness</em>:
When we use the deduction rules to prove that <code class="docutils literal"><span class="pre">P_1,</span> <span class="pre">P_2,</span> <span class="pre">...,</span> <span class="pre">P_n</span> <span class="pre">|-</span> <span class="pre">Q</span></code>,
then the sequent is valid (in all possible interpretations).</li>
<li><em>completeness</em>:
When <code class="docutils literal"><span class="pre">P_1,</span> <span class="pre">P_2,</span> <span class="pre">...,</span> <span class="pre">P_n</span> <span class="pre">|-</span> <span class="pre">Q</span></code> is valid (in all possible interpretations),
then we can use the deduction rules to prove the sequent.</li>
</ol>
<p>Note that, if <code class="docutils literal"><span class="pre">P_1,</span> <span class="pre">P_2,</span> <span class="pre">...,</span> <span class="pre">P_n</span> <span class="pre">|-</span> <span class="pre">Q</span></code> is valid in just one specific
interpretation, we are not guaranteed that our rules will prove it.
This is a famous trouble spot: For centuries, mathematicians were searching for
a set of deduction rules that could be used to build logic proofs of all the
True propositions of arithmetic, that is, the language of int, <code class="docutils literal"><span class="pre">+</span></code>,``-<code class="docutils literal"><span class="pre">,</span>
<span class="pre">``*</span></code>,``/<code class="docutils literal"><span class="pre">,</span></code>&gt;``,``=``.
No appropriate rule set was devised.</p>
<p>In the early 20th century, Kurt Gödel showed that it is <em>impossible</em> to
formulate a sound set of rules customized for arithmetic that will prove exactly
the True facts of arithmetic.
Gödel showed this by formulating True propositions in arithmetic notation that
talked about the computational power of the proof rules themselves, making it
impossible for the proof rules to reason completely about themselves.
The form of proposition he coded in logic+arithmetic stated
&#8220;I cannot be proved&#8221;.
If this proposition is False, it means the proposition can be proved.
But this would make the rule set unsound, because it proved a False claim.
The only possibility is that the proposition is True (and it cannot be proved).
Hence, the proof rules remain sound but are incomplete.</p>
<p>Gödel&#8217;s construction, called <em>diagonalization</em>, opened the door to the modern
theory of computer science, called computability theory, where techniques from
logic are used to analyze computer programs.
Computability theory tells us what problems computers cannot solve, and why, and
so we shouldn&#8217;t try.
(For example, it is impossible to build a program-termination checker that works
on all programs &#8211; the checker won&#8217;t work on itself!)
There is also an offshoot of computability theory, called computational
complexity theory, that studies what can be solved and how fast an algorithm can
solve it.</p>
<p>Given an interpretation of a predicate logic, we can say that the &#8220;meaning&#8221; of a
proposition is exactly the set of interpretations
(cf. Chapter on <a class="reference internal" href="../07-propositional-logic/index.html#propositional-logic"><span>Applications of Propositional Logic to Program Proving</span></a> &#8211; &#8220;contexts&#8221;) in which the
proposition is True.
This returns us to the Boolean-algebra model of logic.
Or, we can organize the interpretations so that an interpretation grows in its
domain and knowledge over time.
This returns us to the Kripke models.
Or, we can introduce two new programming constructs, the <em>abstract data type</em>
and the <em>parametric polymorphic function</em> and extend the Heyting interpretation.</p>
<p>All of these are possible and are studied in a typical second course on logic.</p>
</div>
</div>
<div class="section" id="summary">
<h2>8.9. Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>Here are the rules for the quantifiers, stated in terms of their tactics:</p>
<ul>
<li><p class="first">(<a href="#id15"><span class="problematic" id="id16">**</span></a><a href="#id17"><span class="problematic" id="id18">*</span></a>) <code class="docutils literal"><span class="pre">FORALLi</span></code>: use to prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">FORALLx</span> <span class="pre">P_x</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>1.  Premises        premise
... i.  a
         (fill in)
... j.  P_a
k. FORALLx P_x      FORALLi i-j
</pre></div>
</div>
</li>
<li><p class="first">(<a href="#id19"><span class="problematic" id="id20">**</span></a><a href="#id21"><span class="problematic" id="id22">*</span></a>) <code class="docutils literal"><span class="pre">EXISTe</span></code>-tactic: use to prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">EXISTx</span> <span class="pre">P_x</span> <span class="pre">|-</span> <span class="pre">Q</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>1.  Premises        premise
2.  EXISTx P_x      premise
... i. a   P_a      assumption
      (fill in)
... j.      Q       (does not mention  a!)
k.  Q               EXISTe 2,i-j
</pre></div>
</div>
</li>
<li><p class="first">(*) <code class="docutils literal"><span class="pre">FORALLe</span></code>-tactic: use to prove Premises, <code class="docutils literal"><span class="pre">FORALLx</span> <span class="pre">P_x</span> <span class="pre">|-</span> <span class="pre">Q</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>1.  Premises        premise
2.  FORALLx P_x     premise
  . . .
j.  P_i             FORALLe 2  (where individual  i  appears earlier in the proof)
       (fill in)
k.  Q
</pre></div>
</div>
</li>
<li><p class="first">(*) <code class="docutils literal"><span class="pre">EXISTi</span></code>-tactic: use to prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">EXISTx</span> <span class="pre">P_x</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>1.  Premises        premise
      (fill in)
j.  P_e
k.  EXISTx P_x      EXISTi j
</pre></div>
</div>
</li>
</ul>
<hr class="docutils" />
<p align=right><small><em>
This note was adapted from David Schmidt's CIS 301, 2008,
<a href="http://people.cis.ksu.edu/~schmidt/301s14/Lectures/6quantT.html">Chapter 6</a>
course note.
</em></small></p></div>
</div>


    </div>
      
  </div>
</div>

  </body>
</html>