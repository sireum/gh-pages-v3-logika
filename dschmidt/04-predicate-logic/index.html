
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>4. The Predicate-Logic Quantifiers &#8212; Sireum Logika</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sireum.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../_static/logika.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="5. Programming Logic for Assignments and Conditionals" href="../05-programming-logic/index.html" />
    <link rel="prev" title="3. Propositional Logic" href="../03-propositional-logic/index.html" />
  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          Logika</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../doc/01-getting-started/index.html">Download</a></li>
                <li><a href="../../doc/index.html">Documentation</a></li>
                <li><a href="../index.html">Course Notes</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html"> <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#"> <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">4. The Predicate-Logic Quantifiers</a><ul>
<li><a class="reference internal" href="#the-universal-quantifier-and-its-deduction-rules">4.1. The Universal Quantifier and Its Deduction Rules</a><ul>
<li><a class="reference internal" href="#more-examples">4.1.1. More Examples</a></li>
<li><a class="reference internal" href="#tactics-for-the-rules">4.1.2. Tactics for the ∀-rules</a></li>
<li><a class="reference internal" href="#other-ways-of-proving-propositions-with-the-universal-quantifier">4.1.3. Other Ways of Proving Propositions with The Universal Quantifier</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-existential-quantifier">4.2. The Existential Quantifier</a><ul>
<li><a class="reference internal" href="#the-existential-introduction-rule">4.2.1. The Existential-Introduction Rule</a><ul>
<li><a class="reference internal" href="#introduction-rule">∃-Introduction Rule</a></li>
<li><a class="reference internal" href="#the-elimination-rule">The ∃-Elimination Rule</a></li>
<li><a class="reference internal" href="#standard-examples">Standard Examples</a></li>
<li><a class="reference internal" href="#an-important-example">An Important Example</a></li>
<li><a class="reference internal" href="#domains-and-models">Domains and Models</a></li>
<li><a class="reference internal" href="#id1">Tactics for The ∃-Rules</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#equivalences-in-predicate-logic">4.3. Equivalences in Predicate Logic</a></li>
<li><a class="reference internal" href="#soundness-and-completeness-of-deduction-rules">4.4. Soundness and Completeness of Deduction Rules</a><ul>
<li><a class="reference internal" href="#interpretations">4.4.1. Interpretations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary">4.5. Summary</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <br/>
<font color="darkgray">
<big><big><b>
Logika: Programming Logics
</b></big></big>
</font>
<br/>
<font color="black">
<big><big><big><big><b>
4. The Predicate-Logic Quantifiers
</b></big></big></big></big>
</font><div class="section" id="the-predicate-logic-quantifiers">
<span id="predicate-logic"></span><h1>4. The Predicate-Logic Quantifiers<a class="headerlink" href="#the-predicate-logic-quantifiers" title="Permalink to this headline">¶</a></h1>
<p>In the previous chapter, we studied how to combine primitive propositions with
the operators,
<code class="docutils literal"><span class="pre">∧</span></code>,
<code class="docutils literal"><span class="pre">∨</span></code>,
<code class="docutils literal"><span class="pre">→</span></code>, and
<code class="docutils literal"><span class="pre">¬</span></code>.
When we wrote propositions like <code class="docutils literal"><span class="pre">(p</span> <span class="pre">∧</span> <span class="pre">q)</span> <span class="pre">→</span>&#160; <span class="pre">r</span></code>, we pretended that <code class="docutils literal"><span class="pre">p</span></code>,
<code class="docutils literal"><span class="pre">q</span></code>, and <code class="docutils literal"><span class="pre">r</span></code> stood for complete, primitive statements like “It is raining”
or “<code class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>”.
We did not try to disassemble <code class="docutils literal"><span class="pre">p</span></code>, <code class="docutils literal"><span class="pre">q</span></code>, and <code class="docutils literal"><span class="pre">r</span></code>.</p>
<p>Now it is time to decompose and analyze primitive propositions in terms of their
“verbs” (called <em>predicates</em>) and their “nouns” (called <em>individuals</em>).
This leads to predicate logic.</p>
<p>First, some background: When we study a particular “universe” or “domain”
consisting of “individuals”, we make assertions (propositions) about the
individuals in the domain.
Example domains are: the domain of all animals, the domain of U.S. Presidents,
the domain of days-of-the-week, the domain of crayon colors,
the domain of integers, the domain of strings, etc.
We assemble propositions by using the individuals in the domain along with some
<em>predicates</em>.
For example, for the domain of integers, we use predicates like <code class="docutils literal"><span class="pre">==</span></code> and
<code class="docutils literal"><span class="pre">&gt;</span></code>, like this: <code class="docutils literal"><span class="pre">3</span> <span class="pre">&gt;</span> <span class="pre">5</span></code>,  <code class="docutils literal"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">1</span></code>, etc.
(Here, <code class="docutils literal"><span class="pre">3</span></code> and <code class="docutils literal"><span class="pre">5</span></code> are individuals, and <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> are names of
individuals.)
As these examples show, we might also use <em>functions</em>, like <code class="docutils literal"><span class="pre">*</span></code> and <code class="docutils literal"><span class="pre">+</span></code>, to
compute new individuals.</p>
<div class="sidebar">
<p class="first sidebar-title">Note on Logika and uninterpreted functions</p>
<p class="last">In prepositional (and propositional) modes, Logika treats statements like
<code class="docutils literal"><span class="pre">isHuman(x)</span></code> as an uninterpreted function with non-typed arguments.
Uninterpreted functions, borrowed mathematical logic, are assumed to work
out to whichever type is necessary. In our case, <code class="docutils literal"><span class="pre">isHuman(x)</span></code> must be a
predicate (T or F), so Logika assumes that no matter what you feed it,
<code class="docutils literal"><span class="pre">isHuman(x)</span></code> always returns either True or False.</p>
</div>
<p>For nonnumeric domains like humans, animals, and objects, predicates are written
in a function-call style, like this: <code class="docutils literal"><span class="pre">hasFourLegs(_)</span></code>, <code class="docutils literal"><span class="pre">isTheMotherOf(_,_)</span></code>,
<code class="docutils literal"><span class="pre">isHuman(_)</span></code>, <code class="docutils literal"><span class="pre">isOlderThan(_,_)</span></code>, etc.
So, if <code class="docutils literal"><span class="pre">Lassie</span></code> is an individual animal, we write <code class="docutils literal"><span class="pre">hasFourLegs(Lassie)</span></code> to
make the proposition, “Lassie has four legs”.
Another example is <code class="docutils literal"><span class="pre">isOlderThan(GeorgeWashington,</span> <span class="pre">AbrahamLincoln)</span></code>, which uses
the individuals <code class="docutils literal"><span class="pre">GeorgeWashington</span></code> and <code class="docutils literal"><span class="pre">AbrahamLincoln</span></code>.</p>
<p>Predicate logic has two important new operators that let us write stronger
propositions than what we can do with mere predicates.
These operators are called quantifiers. The quantifers are “for all”
(∀), and “exists”
(∃).
In this chapter, we will learn to use the quantifiers to reason about data
structures.</p>
<p>The <code class="docutils literal"><span class="pre">∀</span></code> quantifier helps us write propositions about all the individuals
in a domain.
Say we consider the domain of animals.
The sentence, “All humans are mortal” is written like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀x (isHuman(x) →  isMortal(x))
</pre></div>
</div>
<p>That is, if an individual, <code class="docutils literal"><span class="pre">x</span></code>, is human, then <code class="docutils literal"><span class="pre">x</span></code> is mortal also.
(Notice that dogs like <code class="docutils literal"><span class="pre">Lassie</span></code> are individuals in the animal domain, but the above
proposition cannot be used to show that <code class="docutils literal"><span class="pre">Lassie</span></code> is mortal, since dogs aren’t
human.
Sadly, dogs are nonetheless mortal.)</p>
<p>An arithmetic example looks like this: for the domain of integers, “every value is
less-than-or-equal to its square”:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀n (n &lt;= n * n)
</pre></div>
</div>
<div class="sidebar">
<p class="first sidebar-title">Logika Lists</p>
<p class="last">In Logika a list is an ordered sequence of elements, starting at 0.
A list has a length (size) property which represent the number of elements it may
contain.  Logika uses <code class="docutils literal"><span class="pre">()</span></code> to index lists rather than the more common
<code class="docutils literal"><span class="pre">[]</span></code> used for array indexing in C# or Java.</p>
</div>
<p>A data-structure example looks like this: For a list, <code class="docutils literal"><span class="pre">r</span></code>, we can assert that
every element of <code class="docutils literal"><span class="pre">r</span></code> is positive:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀i ((i &gt;= 0 ∧ i &lt; r.size) →  r(i) &gt; 0)
</pre></div>
</div>
<p>That is, for every index int, <code class="docutils literal"><span class="pre">i</span></code>, in the range of <code class="docutils literal"><span class="pre">0</span></code> up to (but not
including) <code class="docutils literal"><span class="pre">r.size</span></code> (the length of <code class="docutils literal"><span class="pre">r</span></code>), the indexed element <code class="docutils literal"><span class="pre">r(i)</span></code> is
greater than <code class="docutils literal"><span class="pre">0</span></code>.
The previous statement is often written in a “shorthand” like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀i: 0 &lt;= i &lt; r.size, r(i) &gt; 0
</pre></div>
</div>
<p>which we later use in many of our programming examples.</p>
<p>The <code class="docutils literal"><span class="pre">∃</span></code> quantifier helps us write propositions about specific individuals
in a domain, where the name of the individual is unimportant or unknown.
For example, we can say that <code class="docutils literal"><span class="pre">Lassie</span></code> has a mother like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∃x isMotherOf(x, Lassie)           // isMother(parent, child)
</pre></div>
</div>
<p>(“There exists some <code class="docutils literal"><span class="pre">x</span></code> such that <code class="docutils literal"><span class="pre">x</span></code> is the mother of <code class="docutils literal"><span class="pre">Lassie</span></code>”.)
Here is how we write that every individual in the domain has a mother:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀x∃y isMotherOf(y, x)
</pre></div>
</div>
<p>For the domain of integers, we can make assertions like these:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∃x (x * x = x)
∃y (y + 2 = 9)
∀x (x &gt; 1) →  (∃y (y &gt; 0 and y + 1 = x))
</pre></div>
</div>
<p>For the list <code class="docutils literal"><span class="pre">r</span></code>, we can say that <code class="docutils literal"><span class="pre">r</span></code> holds at least one negative int like
this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∃i (i &gt;= 0 ∧ i &lt; r.size ∧ r(i) &lt; 0)
</pre></div>
</div>
<p>(The shorthand version is <code class="docutils literal"><span class="pre">∃i:</span> <span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">r.size,</span> <span class="pre">r(i)</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>.)
Lots more examples will follow.</p>
<p>With the new format of primitive propositions, we can write proofs like before:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>isHuman(Socrates) →  isMortal(Socrates), isHuman(Socrates)  |-  isMortal(Socrates) ∧ isHuman(Socrates)
{
  1. isHuman(Socrates) →  isMortal(Socrates)   premise
  2. isHuman(Socrates)                         premise
  3. isMortal(Socrates)                        → e 1 2
  4. isMortal(Socrates) ∧ isHuman(Socrates)    ∧i 3 2
}
</pre></div>
</div>
<p>But more importantly, we will learn to prove claims like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀x(isHuman(x) →  isMortal(x)),  isHuman(Socrates)  |-  isMortal(Socrates)
</pre></div>
</div>
<div class="section" id="the-universal-quantifier-and-its-deduction-rules">
<h2>4.1. The Universal Quantifier and Its Deduction Rules<a class="headerlink" href="#the-universal-quantifier-and-its-deduction-rules" title="Permalink to this headline">¶</a></h2>
<p>Like the other logical operators, <code class="docutils literal"><span class="pre">∀</span></code> has an introduction rule and an
elimination rule.
It works best to introduce the rules via examples.
First, here is the most famous claim in logic:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">All</span> <span class="n">humans</span> <span class="n">are</span> <span class="n">mortal</span><span class="o">.</span>
<span class="n">Socrates</span> <span class="ow">is</span> <span class="n">human</span><span class="o">.</span>
<span class="n">Therefore</span><span class="p">,</span> <span class="n">Socrates</span> <span class="ow">is</span> <span class="n">mortal</span><span class="o">.</span>
</pre></div>
</div>
<p>We express this ancient claim like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀x (isHuman(x) →  isMortal(x)),  isHuman(Socrates) |- isMortal(Socrates)
</pre></div>
</div>
<p>Clearly, we require a kind of matching/binding rule to prove that the human
individual, <code class="docutils literal"><span class="pre">Socrates</span></code>, is mortal. The rule is <code class="docutils literal"><span class="pre">∀e</span></code>
(“all elimination”):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀x (isHuman(x) →  isMortal(x)),  isHuman(Socrates) |- isMortal(Socrates)
{
  1. ∀x (isHuman(x) →  isMortal(x))            premise
  2. isHuman(Socrates)                         premise
  3. isHuman(Socrates) →  isMortal(Socrates)   ∀e 1 Socrates
  4. isMortal(Socrates)                        → e 3 2
}
</pre></div>
</div>
<p>Line 3 shows that the claim on Line 1, <em>which holds for all individuals in the
domain</em>, can apply specifically to <code class="docutils literal"><span class="pre">Socrates</span></code>, an individual member of the
domain.
We use the new knowledge on Line 3 to reach the conclusion on Line 4.</p>
<div class="sidebar">
<p class="first sidebar-title">Substitution Notation</p>
<p class="last">We will use <code class="docutils literal"><span class="pre">[v/x]P(x)</span></code>  to mean: use <code class="docutils literal"><span class="pre">v</span></code> for all
occurrences of <code class="docutils literal"><span class="pre">x</span></code> in <code class="docutils literal"><span class="pre">P(x)</span></code>.</p>
</div>
<p><code class="docutils literal"><span class="pre">∀e</span></code> tailors a general claim, prefixed by <code class="docutils literal"><span class="pre">∀x</span></code>, to any individual
element (who replaces the <code class="docutils literal"><span class="pre">x</span></code>).
We see this in Line 3 above.
Here is the rule’s schematic:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>     ∀x P(x)
∀e: -----------
       P(v)        that is, [v/x]P(x),
                   where  v  is an individual
                   in the domain
</pre></div>
</div>
<p>In the domain of integers, from the premise, <code class="docutils literal"><span class="pre">∀i</span> <span class="pre">(i</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&gt;</span> <span class="pre">i)</span></code>, we apply <code class="docutils literal"><span class="pre">∀e</span></code> to
deduce <code class="docutils literal"><span class="pre">[3/i](i</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&gt;</span> <span class="pre">i)</span></code>, that is, <code class="docutils literal"><span class="pre">3</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&gt;</span> <span class="pre">3</span></code>.</p>
<p>The other deduction rule, <code class="docutils literal"><span class="pre">∀i</span></code> (“all-introduction”), deduces propositions
that are prefixed by <code class="docutils literal"><span class="pre">∀</span></code>.
Here is a motivating example, in the domain of integers:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀x((x + 1) &gt; x),  ∀x(x &gt; (x - 1))  |-  ∀x((x + 1) &gt; x ∧ x &gt; (x - 1))
</pre></div>
</div>
<p>In its prepositional logic mode, Logika will not process the numerical
comparisons.  Everything evaluated must evaluate to True or False.  We can
get arround this limitation by writing uninterpreted functions where:
gt(y,x) returns true if y&gt;x, inc(x) returns x + 1 and  dec(x) returns x - 1.
<em>Recalll that uninterpreted functions are assumed to return the required type.</em></p>
<p>Or:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀x gt(inc(x), x), ∀x gt(x, dec(x)) |- ∀x gt(inc(x), x) ∧ gt(x, dec(x))
</pre></div>
</div>
<p>That is, we wish to prove that for every possible integer, the integer is smaller than
its successor and larger than its predecessor.
How do we do this?</p>
<p>Clearly, we will not inspect all of <code class="docutils literal"><span class="pre">...,</span> <span class="pre">-2,</span> <span class="pre">-1,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">...</span></code> and verify that
<code class="docutils literal"><span class="pre">(-2</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">&gt;</span> <span class="pre">-2</span> <span class="pre">∧</span> <span class="pre">-2</span> <span class="pre">&lt;</span> <span class="pre">(-2</span> <span class="pre">-</span> <span class="pre">1),</span> <span class="pre">(-1</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">&gt;</span> <span class="pre">-1</span> <span class="pre">∧</span> <span class="pre">-1</span> <span class="pre">&lt;</span> <span class="pre">(-1</span> <span class="pre">-</span> <span class="pre">1),</span> <span class="pre">(0</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">∧</span> <span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">(0</span> <span class="pre">-</span> <span class="pre">1)</span></code>,
etc.!
Instead, we write a single, generic, general-purpose argument — a
“case analysis” — that applies to whichever, arbitrary int we would ever
consider.
Let <code class="docutils literal"><span class="pre">a</span></code> stand for the arbitrary int we will discuss.  The choice of <code class="docutils literal"><span class="pre">a</span></code>
(instead of <code class="docutils literal"><span class="pre">b</span></code> etc) is somewhat arbitrary. One can select any letter provided
it has not been used before in the scope of the proof or sub-proof.  We use to
term “fresh” to indicate such a letter selection.
The case analysis appears in the proof like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀x gt(inc(x), x), ∀x gt(x, dec(x)) |- ∀x gt(inc(x), x) ∧ gt(x, dec(x))
{
  1. ∀x gt(inc(x), x)                      premise
  2. ∀x gt(x, dec(x))                      premise
  3. {
       4. a
       5. gt(inc(a), a)                    ∀e 1 a
       6. gt(a, dec(a))                    ∀e 2 a
       7. gt(inc(a), a)  ∧  gt(a, dec(a))  ∧i 5 6
     }
  8. ∀x gt(inc(x), x)  ∧  gt(x, dec(x))    ∀i 3
}
</pre></div>
</div>
<p>Lines 3-7 are the generic argument: let <code class="docutils literal"><span class="pre">a</span></code> be the arbitrary/anybody integer
we discuss.
By Lines 1 and 2, we must have that <code class="docutils literal"><span class="pre">(a</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">&gt;</span> <span class="pre">a</span></code> and that <code class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">(a</span> <span class="pre">-</span> <span class="pre">1)</span></code>.
Line 6 uses <code class="docutils literal"><span class="pre">∧i</span></code> to show a has the property <code class="docutils literal"><span class="pre">(a</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">&gt;</span> <span class="pre">a</span> <span class="pre">∧</span> <span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">(a</span> <span class="pre">-</span> <span class="pre">1)</span></code>.</p>
<p>Since the argument in Lines 3-7 is not specific to any specific integer, we can
use the argument on <em>all</em> the individual integers – that is, we can substitute
<code class="docutils literal"><span class="pre">-2</span></code> for <code class="docutils literal"><span class="pre">a</span></code> and the argument holds;
we can substitute <code class="docutils literal"><span class="pre">-1</span></code> for <code class="docutils literal"><span class="pre">a</span></code> and the argument holds;
we can substitute <code class="docutils literal"><span class="pre">0</span></code> for <code class="docutils literal"><span class="pre">a</span></code> and the argument holds; and so on!</p>
<p>Line 8 is justified by the new deduction rule, <code class="docutils literal"><span class="pre">∀i</span></code>, which asserts that
the generic case analysis in Lines 3-7 applies to all the individual integers.
Here is the rule’s schematic:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>     { a              (a is fresh)
       . . . P(a) }
∀i: ---------------
         ∀x P(x)      (That is,  P(x) is [x/a]P(a).
                            Thus,  a  _does not appear_ in  P(x),  and
                            every premise and assumption visible
                            to  ∀x P(x)   _does not mention_  a)
</pre></div>
</div>
<p>To repeat this important idea: The rule says, to prove a claim of form,
<code class="docutils literal"><span class="pre">∀x</span> <span class="pre">P(x)</span></code>, we undertake a case analysis:
we prove property <code class="docutils literal"><span class="pre">P(a)</span></code> for an <em>arbitrary member</em>, <code class="docutils literal"><span class="pre">a</span></code>, of domain <code class="docutils literal"><span class="pre">D</span></code>.
(Call the element, “Mx <code class="docutils literal"><span class="pre">a</span></code>” — Mx arbitrary — Mx anybody —
Mx anonymous).
Since Mx <code class="docutils literal"><span class="pre">a</span></code> is a complete unknown, it stands for “everyone” in domain D.
<em>We know that we can substitute whichever domain element</em>, <code class="docutils literal"><span class="pre">d</span></code>, <em>from domain</em>
<code class="docutils literal"><span class="pre">D</span></code> <em>we want into the proof and we get a proof of</em> <code class="docutils literal"><span class="pre">P(d)</span></code>.
In this way, we have proofs of <code class="docutils literal"><span class="pre">P</span></code> <em>for all</em> elements of domain <code class="docutils literal"><span class="pre">D</span></code>.</p>
<p>Here is the same idea, used in a proof about a domain of people:
“Everyone is healthy; everyone is happy.
Therefore, everyone is both healthy and happy”:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀x isHealthy(x), ∀y isHappy(y)  |-  ∀z(isHealthy(z) ∧ isHappy(z))
{

  1. ∀x isHealthy(x)                 premise
  2. ∀y isHappy(y)                   premise
  3. {
       4. a
       5. isHealthy(a)               ∀e 1 a
       6. isHappy(a)                 ∀e 2 a
       7. isHealthy(a) ∧ isHappy(a)  ∧i 5 6
  }
  8. ∀z(isHealthy(z) ∧ isHappy(z))   ∀i 3
}
</pre></div>
</div>
<p>Say that we have a domain of living beings.
This next example requires nested cases</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>All humans are mortal
All mortals have a soul
Therefore, all humans have soul
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀x (isHuman(x) →  isMortal(x)), ∀y (isMortal(y) →  hasSoul(y))  |-  ∀x (isHuman(x) →  hasSoul(x))
{
  1. ∀x (isHuman(x) →  isMortal(x))       premise
  2. ∀y (isMortal(y) →  hasSoul(y))       premise
  3. {
       4. a
       5. {
            6. isHuman(a)                 assume
            7. isHuman(a) →  isMortal(a)  ∀e 1 a
            8. isMortal(a)                → e 7 6
            9. isMortal(a) →  hasSoul(a)  ∀e 2 a
            10. hasSoul(a)                → e 9 8
       }
       11.  isHuman(a) →  hasSoul(a)      → i 5
  }
  12.  ∀x (isHuman(x) →  hasSoul(x))      ∀i 3
}
</pre></div>
</div>
<p>Line 4 states that we use <code class="docutils literal"><span class="pre">a</span></code> to stand for an arbitrary individual of the
domain.
Line 6 starts a nested case, which assumes <code class="docutils literal"><span class="pre">a</span></code> is human.
Then we can prove that a has a soul, hence by <code class="docutils literal"><span class="pre">→</span> <span class="pre">i</span></code>,
<code class="docutils literal"><span class="pre">isHuman(a)</span> <span class="pre">→</span>&#160; <span class="pre">hasSoul(a)</span></code>.
Since the outer case is stated in terms of the arbitrary, anonymous individual,
<code class="docutils literal"><span class="pre">a</span></code>, we can finish the proof on Line 12 by <code class="docutils literal"><span class="pre">∀i</span></code>.</p>
<p>Here is a last, important example.
Let the domain be the members of one family.
We can prove this truism</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>Every (individual) family member who is healthy is also happy.
Therefore, if all the family members are healthy, then all the members are happy.
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀x (healthy(x) →  happy(x))  |-  (∀y healthy(y)) →  (∀x happy(x))
{
  1. ∀x healthy(x) →  happy(x)          premise
  2. {
       3. ∀y healthy(y)                 assume
       4. {
            5. a
            6. healthy(a)               ∀e 3 a
            7. healthy(a) →  happy(a)   ∀e 1 a
            8. happy(a)                 → e 7 6
       }
       9. ∀ x happy(x)                  ∀i 4
  }
  10. (∀y healthy(y)) →  (∀x happy(x))  → i 2
}
</pre></div>
</div>
<p>We commence by assuming all the family is healthy (Line 3).
Then, we consider an arbitrary/anonymous family member, <code class="docutils literal"><span class="pre">a</span></code>, and show that
<code class="docutils literal"><span class="pre">healthy(a)</span></code> is a fact (from Line 3).
Then we deduce <code class="docutils literal"><span class="pre">happy(a)</span></code>.
Since <code class="docutils literal"><span class="pre">a</span></code> stands for anyone/everyone in the family, we use <code class="docutils literal"><span class="pre">∀i</span></code> to
conclude on Line 7 that all family members are happy.
Line 10 finishes.</p>
<p>Consider the converse claim; is it valid?</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>If all the family members are healthy, then all are happy.
Therefore, for every (individual) family member, if (s)he is healthy then
(s)he is also happy.
</pre></div>
</div>
<p>Well, no – perhaps the family is so close-knit that, if one one family member
is unhealthy; then other, healthy, family members might well be unhappy with
worry.
This is a subtle point, so take a moment and think about it!</p>
<p>Let’s try to prove the dubious claim and see where we get stuck:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>(∀y healthy(y)) →  (∀x happy(x)) |- ∀x (healthy(x) →  happy(x))
{
  1. (∀y healthy(y)) → (∀x happy(x))   premise
  2. {
       3. a                   assume
       4. {
            5. healthy(a)     assume     // WE ARE TRYING TO PROVE happy(a)?!
       }
  }
  6. ∀y healthy(y)            ∀i 2??     // NO--WE ARE TRYING TO FINISH THE OUTER
                                         //  OUTER BLOCK BEFORE THE INNER ONE
                                         // IS FINISHED!
</pre></div>
</div>
<p>No matter how you might try, you will see that the “block structure” of the
proofs warns us when we are making invalid deductions.
It is impossible to prove this claim.</p>
<div class="section" id="more-examples">
<h3>4.1.1. More Examples<a class="headerlink" href="#more-examples" title="Permalink to this headline">¶</a></h3>
<p>We state some standard exercises with <code class="docutils literal"><span class="pre">∀</span></code>, where the domains and
predicates are unimportant:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀x f(x) |- ∀y f(y)
{
  1. ∀x f(x)    premise
  2. {
       3. a
       4. f(a)  ∀e 1 a
  }
  5. ∀y f(y)    ∀i 2
}
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀z (f(z) ∧ g(z)) |- (∀x f(x)) ∧ (∀y g(y))
{
  1. ∀z (f(z) ∧ g(z))        premise
  2. {
       3. a
       4. f(a) ∧ g(a)        ∀e 1 a
       5. f(a)               ∧e1 4
  }
  6. ∀x f(x)                 ∀i 2
  7. {
       8. b
       9. f(b) ∧ g(b)        ∀e 1 b
       10. g(b)              ∧e2 9
  }
  11. ∀y g(y)                ∀i 7

  12. (∀x f(x)) ∧ (∀y g(y))  ∧i 6 11
}
</pre></div>
</div>
<p>The earlier example about healthy and happy families illustrates an important
structural relationship between <code class="docutils literal"><span class="pre">∀</span></code> and <code class="docutils literal"><span class="pre">→</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀x (f(x) →  g(x)) |- (∀x f(x)) →  (∀x g(x))
</pre></div>
</div>
<p>can be proved, but the converse cannot.</p>
<p>This last one is reasonable but the proof is a bit tricky because of the nested
subproofs:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀x∀y f(x,y)  |-  ∀y∀x f(x,y)
{
  1. ∀x∀y f(x,y)         premise
  2. {
       3. b
       4. {
            5. a
            6. ∀y f(a,y)  ∀e 1 a
            7. f(a,b)     ∀e 6 b
        }
        8. ∀x f(x,b)      ∀i 4
  }
  9. ∀y∀x f(x,y)          ∀i 2
}
</pre></div>
</div>
</div>
<div class="section" id="tactics-for-the-rules">
<h3>4.1.2. Tactics for the ∀-rules<a class="headerlink" href="#tactics-for-the-rules" title="Permalink to this headline">¶</a></h3>
<p>As in the previous chapter, we now give advice as to when to use the <code class="docutils literal"><span class="pre">∀i</span></code>
and <code class="docutils literal"><span class="pre">∀e</span></code> rules.</p>
<ul>
<li><p class="first">(***) <code class="docutils literal"><span class="pre">∀i</span></code>-tactic:
To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">∀x</span> <span class="pre">P(x)</span></code>,</p>
<ol class="arabic simple">
<li>assume <code class="docutils literal"><span class="pre">a</span></code>, for a new, anonymous “Mx <code class="docutils literal"><span class="pre">a</span></code>”</li>
<li>prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">P(a)</span></code></li>
<li>finish with <code class="docutils literal"><span class="pre">∀i</span></code>.</li>
</ol>
<p>The proof structure looks like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>1.  Premises         premise
i. {
     j.  a
          (fill in)
     k.  P(a)
}
l. ∀x P(x)           ∀i i

This tactic was applied in Lines 2-9 of the previous (correct) example
proof.
</pre></div>
</div>
</li>
<li><p class="first">(*) <code class="docutils literal"><span class="pre">∀e</span></code>-tactic:
To prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">∀x</span> <span class="pre">P(x)</span> <span class="pre">|-</span> <span class="pre">Q</span></code>, then for an individual, <code class="docutils literal"><span class="pre">i</span></code>, that
appears in the proof so far, use the <code class="docutils literal"><span class="pre">∀e</span></code> rule to deduce the new fact,
<code class="docutils literal"><span class="pre">P(i)</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>1.  Premises        premise
2.  ∀x P(x)         premise
    . . .
j.  P(i)            ∀e 2
       (fill in)
k.  Q
</pre></div>
</div>
<p>This tactic should be used only when it is clear that the new fact makes a
significant step forwards to finishing the proof.
Steps 4 and 5 of the previous (correct) example proof used this tactic.</p>
</li>
</ul>
</div>
<div class="section" id="other-ways-of-proving-propositions-with-the-universal-quantifier">
<h3>4.1.3. Other Ways of Proving Propositions with The Universal Quantifier<a class="headerlink" href="#other-ways-of-proving-propositions-with-the-universal-quantifier" title="Permalink to this headline">¶</a></h3>
<p>How do we prove an assertion of the form, <code class="docutils literal"><span class="pre">∀x</span> <span class="pre">P(x)</span></code>?
We just saw that <code class="docutils literal"><span class="pre">∀i</span></code> can do this for any domain whatsoever.
But there are, in fact, three different approaches, depending on the form of
domain we use:</p>
<ul>
<li><p class="first">Approach 1: use conjunctions for a finite domain</p>
<p>Say that the domain we study is a <em>finite set</em>, <code class="docutils literal"><span class="pre">D</span> <span class="pre">=</span> <span class="pre">{e0,</span> <span class="pre">e1,</span> <span class="pre">...,</span> <span class="pre">ek}</span></code>.
(An example domain is the days of the week,
<code class="docutils literal"><span class="pre">{sun,</span> <span class="pre">mon,</span> <span class="pre">tues,</span> <span class="pre">weds,</span> <span class="pre">thurs,</span> <span class="pre">fri,</span> <span class="pre">sat}</span></code>.)</p>
<p>This makes <code class="docutils literal"><span class="pre">∀x</span> <span class="pre">P(x)</span></code> just an abbreviation itself of this much-longer
assertion:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>P(e0) ∧ P(e1) ∧ ... ∧ P(ek)
</pre></div>
</div>
<p>For example, when the domain is the days of the week, the assertion,
<code class="docutils literal"><span class="pre">∀d</span> <span class="pre">isBurgerKingDay(d)</span></code>, abbreviates:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>isBurgerKingDay(sun) ∧ isBurgerKingDay(mon) ∧ ... ∧ isBurgerKingDay(sat)
</pre></div>
</div>
<p>To prove such a <code class="docutils literal"><span class="pre">∀x</span> <span class="pre">P(x)</span></code> for a finite domain <code class="docutils literal"><span class="pre">D</span></code>, we must prove
<code class="docutils literal"><span class="pre">P(ei)</span></code>, for each and every <code class="docutils literal"><span class="pre">ei</span></code> in <code class="docutils literal"><span class="pre">D</span></code>.</p>
<p>We can use this approach when we are analyzing all the elements of a
finite-length list.
Say that list <code class="docutils literal"><span class="pre">r</span></code> has length 4.
We can say that the domain of its indexes is <code class="docutils literal"><span class="pre">{0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3}</span></code>.
So, if we wish to prove that <code class="docutils literal"><span class="pre">∀</span> <span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">4,</span> <span class="pre">r(i)</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, we need only
prove that <code class="docutils literal"><span class="pre">r(0)</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">∧</span> <span class="pre">r(1)</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">∧</span> <span class="pre">r(2)</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">∧</span> <span class="pre">r(3)</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
</li>
<li><p class="first">Approach 2: for the domain of nonnegative ints, use mathematical induction</p>
<p>The domain, <code class="docutils literal"><span class="pre">Nat</span> <span class="pre">=</span> <span class="pre">{0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">...</span> <span class="pre">}</span></code> is infinite, so we cannot use the
previous technique to prove properties like <code class="docutils literal"><span class="pre">∀</span> <span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0,</span> <span class="pre">(n</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">&gt;</span> <span class="pre">n</span></code> –
we would have to write separate proofs that
<code class="docutils literal"><span class="pre">0</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&gt;</span> <span class="pre">0,</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&gt;</span> <span class="pre">1,</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&gt;</span> <span class="pre">2,</span> <span class="pre">...</span></code>, forever.
But we <em>can</em> use mathematical induction.</p>
</li>
<li><p class="first">Approach 3: for any domain, finite or infinite whatsoever, use the
<code class="docutils literal"><span class="pre">∀i</span></code>-law</p>
<p>Finally, we might be using a large domain that is not as organized as the
nonnegatives, <code class="docutils literal"><span class="pre">0,1,2,...</span></code>.
Maybe the domain is the domain of all humans or all the citizens of Peru or
the members of the Republican party or all the objects on Planet Earth.
How can we prove <code class="docutils literal"><span class="pre">∀</span> <span class="pre">x</span> <span class="pre">P(x)</span></code> for such huge collections?</p>
<p>To prove a claim of form, <code class="docutils literal"><span class="pre">∀x</span> <span class="pre">P(x)</span></code>, for an arbitrary domain, we
undertake a kind of case analysis: we prove property <code class="docutils literal"><span class="pre">P(a)</span></code> for an
<em>arbitrary member</em>, <code class="docutils literal"><span class="pre">a</span></code>, of domain <code class="docutils literal"><span class="pre">D</span></code>.
(Call the element, “Mx <code class="docutils literal"><span class="pre">a</span></code>” — Mx arbitrary — Mx anybody —
Mx anonymous).
Since Mx <code class="docutils literal"><span class="pre">a</span></code> is a complete unknown, it stands for “everyone” in doman
<code class="docutils literal"><span class="pre">D</span></code>.
<em>We know that we can substitute whichever domain element,</em> <code class="docutils literal"><span class="pre">d</span></code> <em>from domain</em>
<code class="docutils literal"><span class="pre">D</span></code>, <em>we want into the proof and we get a proof of</em> <code class="docutils literal"><span class="pre">P(d)</span></code>.
In this way, we have proofs of <code class="docutils literal"><span class="pre">P</span></code> <em>for all</em> elements of domain <code class="docutils literal"><span class="pre">D</span></code>.</p>
<p>This is the idea behind the <code class="docutils literal"><span class="pre">∀i</span></code>-rule.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="the-existential-quantifier">
<h2>4.2. The Existential Quantifier<a class="headerlink" href="#the-existential-quantifier" title="Permalink to this headline">¶</a></h2>
<p>The existential quantifier, <code class="docutils literal"><span class="pre">∃</span></code>, means
“there exists” or “there is”.
We use this phrase when we do not care about the name of the individual involved
in our claim.
Here are examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>There is a mouse in the house:  ∃m (isMouse(m) ∧ inHouse(m))
    (We don&#39;t care about the mouse&#39;s name.)

Someone ate my cookie:   ∃x ateMyCookie(x)

There is a number that equals its own square:  ∃n  n == n*n

For every int, there is an int that is smaller:  ∀x ∃y y &lt; x
</pre></div>
</div>
<p>If we have a fact about an individual in a domain, we can use the fact to deduce
a fact that begins with an existential quantifier.
For example, if we know that:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>isHuman(Socrates) ∧ isMortal(Socrates)
</pre></div>
</div>
<p>surely we can conclude that:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∃h (isHuman(h) ∧ isMortal(h))
</pre></div>
</div>
<p>that is, “there is someone who is human and mortal”.
The identity of the human is no longer important to us.
In the next section, we see that the <code class="docutils literal"><span class="pre">∃i</span></code>-rule makes such deductions.</p>
<div class="section" id="the-existential-introduction-rule">
<h3>4.2.1. The Existential-Introduction Rule<a class="headerlink" href="#the-existential-introduction-rule" title="Permalink to this headline">¶</a></h3>
<p>Often <code class="docutils literal"><span class="pre">∃</span></code> is used to “hide” secret information.
Consider these Pat Sajack musings from a typical game of Wheel of Fortune:</p>
<ul>
<li><p class="first">Pat thinks: “There is an ‘E’ covered over on Square 14 of the game board”.
In predicate logic, this can be written:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>isCovered(Square14) ∧ holds(Square14,&#39;E&#39;).
</pre></div>
</div>
</li>
<li><p class="first">Pat thinks: “Wait – I can’t say that on TV! Perhaps I can say,
There is a vowel covered on Square 14 of the game board”.
In predicate logic, this is written:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>isCovered(Square14) ∧ (∃c isVowel(c) ∧ holds(Square14,c)).
</pre></div>
</div>
<p>In this way, Pat does not reveal the letter to the game players and TV
viewers.</p>
</li>
<li><p class="first">Because it isn’t fair to tell the players which squares hold vowels, Pat
announces on the air,
“There is a vowel that is still covered on the game board”:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∃s (isSquare(s) ∧ isCovered(s) ∧ (∃c isVowel(c) ∧ holds(s,c)))
</pre></div>
</div>
<p>This statement hides the specific square and letter that Pat is thinking
about.</p>
</li>
</ul>
<p>Pat’s announcement was deduced from its predecessors by means of the
<code class="docutils literal"><span class="pre">∃i</span></code>-rule, which we see in a moment.</p>
<p>What can a game player do with Pat’s uttered statement?
A player might deduce these useful facts:</p>
<ul>
<li><p class="first">There is a square still covered: <code class="docutils literal"><span class="pre">∃s</span> <span class="pre">isSquare(s)</span> <span class="pre">∧</span> <span class="pre">isCovered(s)</span></code></p>
</li>
<li><p class="first">There is a vowel: <code class="docutils literal"><span class="pre">∃c</span> <span class="pre">isVowel(c)</span></code></p>
</li>
<li><p class="first">There is a covered letter, <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">E</span></code>, <code class="docutils literal"><span class="pre">I</span></code>, <code class="docutils literal"><span class="pre">O</span></code>, <code class="docutils literal"><span class="pre">U</span></code> (assuming the
vowels are exactly <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">E</span></code>, <code class="docutils literal"><span class="pre">I</span></code>, <code class="docutils literal"><span class="pre">O</span></code>, <code class="docutils literal"><span class="pre">U</span></code>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∃s isSquare(s) ∧ isCovered(s) ∧
  (holds(s,&#39;A&#39;) ∨ holds(s,&#39;E&#39;) ∨ holds(s,&#39;I&#39;) ∨ holds(s,&#39;O&#39;) ∨ holds(s,&#39;U&#39;))
</pre></div>
</div>
</li>
</ul>
<p>Although the game player does not know the letter and square that Pat Sajak
“hid” with his statement, the player can still make useful deductions.
We will use the <code class="docutils literal"><span class="pre">∃e</span></code> rule to deduce these style of propositions.</p>
<div class="section" id="introduction-rule">
<h4>∃-Introduction Rule<a class="headerlink" href="#introduction-rule" title="Permalink to this headline">¶</a></h4>
<p>The rule for <code class="docutils literal"><span class="pre">∃i</span></code> has this format:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>       P(d)         where  d  is an individual in the domain D
∃i: -----------
      ∃x P(x)
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">∃i</span></code> rule says, if we locate an individual <code class="docutils literal"><span class="pre">d</span></code> (a “witness”, as it
is called by logicians) that makes <code class="docutils literal"><span class="pre">P</span></code> true, then surely we can say there
exists <em>someone</em> that has <code class="docutils literal"><span class="pre">P</span></code> and hide the identity of the individual/witness.</p>
<p>The rule was used in the previous section in a tiny example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>isHuman(Socrates), isMortal(Socrates) |- ∃h (isHuman(h) ∧ isMortal(h))
{
  1. isHuman(Socrates)                        premise
  2. isMortal(Socrates)                       premise
  3. isHuman(Socrates) ∧ isMortal(Socrates)   ∧i 1 2
  4. ∃h (isHuman(h) ∧ isMortal(h))            ∃i 3 Socrates
}
</pre></div>
</div>
<p>Since <code class="docutils literal"><span class="pre">Socrates</span></code> is an individual that is both human and mortal, we deduce
Line 3.
Line 4 “hides” <code class="docutils literal"><span class="pre">Socrates</span></code>’ name.</p>
<p>Let’s do a Wheel-Of-Fortune example: Pat Sajak uses two premises and the
<code class="docutils literal"><span class="pre">∃i</span></code> rule to deduce a new conclusion:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>isVowel(e), holds(Square14,e) |- ∃c(isVowel(c) ∧ ∃s holds(s,c))
{
  1. isVowel(e)                       premise
  2. holds(Square14,e)                premise
  3. ∃s holds(s,e)                    ∃i 2 Square14
  4. isVowel(e) ∧ ∃s holds(s,e)       ∧i 1 3
  5. ∃c(isVowel(c) ∧ ∃s holds(s,c))   ∃i 4 e
}
</pre></div>
</div>
<p>Line 3 hides the number of the square (“there is a square that holds ‘e’”), and
Line 5 hides the ‘e’ (“there is a letter that is a vowel and there is a square
that holds the letter”).</p>
<p>From the same two premises we can also prove this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>isVowel(e), holds(Square14,e) |- ∃c∃s(isVowel(c) ∧ holds(s,c))
{
  1. isVowel(e)                       premise
  2. holds(Square14,e)                premise
  3. isVowel(e) ∧ holds(Square14,e)   ∧i 1 2
  4. ∃s(isVowel(e) ∧ holds(s,e))      ∃i 3 Square14
  5. ∃c∃s(isVowel(c) ∧ holds(s,c))    ∃i 4 e
}
</pre></div>
</div>
<p>This reads, “there are a letter and square such that the letter is a vowel and
the square holds the letter”.
The proposition differs slightly from the previous one, but the two seem to have
identical information content.
(When we learn the <code class="docutils literal"><span class="pre">∃e</span></code>-rule, we can prove the two conclusions have
identical content.)</p>
</div>
<div class="section" id="the-elimination-rule">
<h4>The ∃-Elimination Rule<a class="headerlink" href="#the-elimination-rule" title="Permalink to this headline">¶</a></h4>
<p>Since the <code class="docutils literal"><span class="pre">∃i</span></code>-rule constructs propositions that begin with <code class="docutils literal"><span class="pre">∃</span></code>, the
<code class="docutils literal"><span class="pre">∃e</span></code>-rule disassembles propositions that begin with <code class="docutils literal"><span class="pre">∃</span></code>.
The new rule employs a subtle case analysis.</p>
<p>Here is a quick example (in the universe of things on planet Earth), to get our
bearings:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">All</span> <span class="n">humans</span> <span class="n">are</span> <span class="n">mortal</span>
<span class="n">Someone</span> <span class="ow">is</span> <span class="n">human</span>
<span class="n">Therefore</span><span class="p">,</span> <span class="n">someone</span> <span class="ow">is</span> <span class="n">mortal</span>
</pre></div>
</div>
<p>We don’t know the name of the individual human, but it does not matter –
we can still conclude someone is mortal.
The steps we will take go like this</p>
<ul class="simple">
<li>Since “someone is human” and since we do not know his/her name, we will
just make up our own name for them – “Mx A”. So, we assume that “Mr. A is human”</li>
<li>We use the logic rules we already know to prove that “Mr. A is mortal”.</li>
<li>Therefore <em>“someone is mortal” and their name does not matter</em>.</li>
</ul>
<p>This approach is coded into the last logic law, <code class="docutils literal"><span class="pre">∃e</span></code> (exists-elimination).</p>
<p>Say we have a premise of the form, <code class="docutils literal"><span class="pre">∃x</span> <span class="pre">P(x)</span></code>.
Since we <em>do not know the name</em> of the individual “hidden” behind the
<code class="docutils literal"><span class="pre">∃x</span></code>,
we make up a name for it, say <code class="docutils literal"><span class="pre">a</span></code>, and discuss what must follow from the
assumption that <code class="docutils literal"><span class="pre">P(a)</span></code> holds true:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>                  {a  P(a)   assume       // where  a  is a new, fresh name
      ∃x P(x)      ...  Q           }     // a  MUST NOT appear in  Q
∃e: -----------------------------------
                     Q
</pre></div>
</div>
<p>That is, if we can deduce <code class="docutils literal"><span class="pre">Q</span></code> from <code class="docutils literal"><span class="pre">P(a)</span></code>, and we do not mention <code class="docutils literal"><span class="pre">a</span></code> within
<code class="docutils literal"><span class="pre">Q</span></code>, then it means <code class="docutils literal"><span class="pre">Q</span></code> can be deduced no matter what name the hidden
individual has.
So, <code class="docutils literal"><span class="pre">Q</span></code> follows from <code class="docutils literal"><span class="pre">∃x</span> <span class="pre">P(x)</span></code>.</p>
<p>We can work the previous example, with <code class="docutils literal"><span class="pre">∃e</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">All</span> <span class="n">humans</span> <span class="n">are</span> <span class="n">mortal</span>
<span class="n">Someone</span> <span class="ow">is</span> <span class="n">human</span>
<span class="n">Therefore</span><span class="p">,</span> <span class="n">someone</span> <span class="ow">is</span> <span class="n">mortal</span>
</pre></div>
</div>
<p>We make up the name, <code class="docutils literal"><span class="pre">a</span></code>, for the individual whose name we do not know, and
do a case analysis:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀h(isHuman(h) →  isMortal(h)), ∃x isHuman(x) |- ∃y isMortal(y)
{
  1. ∀h(isHuman(h) →  isMortal(h))   premise
  2. ∃x isHuman(x)                   premise
  3. {
       4. a   isHuman(a)             assume
       5. isHuman(a) →  isMortal(a)  ∀e 1 a
       6. isMortal(a)                → e 5 4
       7. ∃y isMortal(y)             ∃i 6 a
  }
  8. ∃y isMortal(y)                  ∃e 2 3
}
</pre></div>
</div>
<p>Line 4 proposes the name <code class="docutils literal"><span class="pre">a</span></code> and the assumption that <code class="docutils literal"><span class="pre">isHuman(a)</span></code>.
The case analysis leads to Line 7, which says that someone is mortal.
(We never learned the individual’s name!)
Since Line 7 does not explicitly mention the made-up name, <code class="docutils literal"><span class="pre">a</span></code>, we use Line 8
to repeat Line 7 – without knowing the name of the individual “hiding” inside
Line 2, we made a case analysis in Lines 4-7 that prove the result, anyway.
This is how <code class="docutils literal"><span class="pre">∃e</span></code> works.</p>
<p>To repeat: The <code class="docutils literal"><span class="pre">∃e</span></code> rule describes how to discuss an anonymous individual
(a witness) without knowing/revealing its identity:
Assume the witness’s name is Mx <code class="docutils literal"><span class="pre">a</span></code> (“Mx Anonymous”) and that
Mx <code class="docutils literal"><span class="pre">a</span></code> makes <code class="docutils literal"><span class="pre">P</span></code> true.
Then, we deduce some fact, <code class="docutils literal"><span class="pre">Q</span></code>, that holds <em>even though we don’t know who is
Mx</em> <code class="docutils literal"><span class="pre">a</span></code>.
The restriction on the <code class="docutils literal"><span class="pre">∃e</span></code> rule (<code class="docutils literal"><span class="pre">Q</span></code> cannot mention <code class="docutils literal"><span class="pre">a</span></code>) enforces
that we have no extra information about the identity of Mx <code class="docutils literal"><span class="pre">a</span></code> – the name
<code class="docutils literal"><span class="pre">a</span></code> must not leave the sub-proof.</p>
<p>Here is a Wheel-of-Fortune example that uses <code class="docutils literal"><span class="pre">∃e</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∃c (isVowel(c) ∧ ∃s holds(s,c)) |-  ∃d isVowel(d)
{
  1. ∃c (isVowel(c) ∧ ∃s holds(s,c))     premise
  2. {
     3. a   isVowel(a) ∧ ∃s holds(s,a)   assume
     4. isVowel(a)                       ∧e1 3
     5. ∃d isVowel(d)                    ∃i 4 a
  }
  6. ∃d isVowel(d)                       ∃e 1 2
}
</pre></div>
</div>
<p>We do not know the identity of the vowel held in an unknown square, but this
does not prevent us from concluding that there is a vowel.</p>
</div>
<div class="section" id="standard-examples">
<h4>Standard Examples<a class="headerlink" href="#standard-examples" title="Permalink to this headline">¶</a></h4>
<p>For practice, we do some standard examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∃x p(x) |- ∃y p(y)
{
  1. ∃x p(x)          premise
  2. {
       3. a    p(a)   assume
       4. ∃y p(y)     ∃i 3 a
  }
  5. ∃y p(y)          ∃e 1 2
}
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>∃x(f(x) ∧ g(x)) |- (∃y f(y)) ∧ (∃z g(z))
{
  1. ∃x(f(x) ∧ g(x))             premise
  2. {
       3. a    f(a) ∧ g(a)        assume
       4. f(a)                    ∧e1 3
       5. ∃y f(y)                 ∃i 4 a
       6. g(a)                    ∧e2 3
       7. ∃z g(z)                 ∃i 6 a
       8. (∃y f(y)) ∧ (∃z g(z))   ∧i 5 7
  }
  9.  (∃y f(y)) ∧ (∃z g(z))       ∃e 1 2
}
</pre></div>
</div>
<p>Notice that you cannot prove the converse:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>(∃y f(y)) ∧ (∃z g(z)) |- ∃x(f(x) ∧ g(x)).
</pre></div>
</div>
<p>For example, say that the universe of discussion is a zoo with monkeys and tigers.
Let f(x)== isTiger(x) and g(x)==isMonkey(x).  Then clearly
<code class="docutils literal"><span class="pre">(∃y</span> <span class="pre">f(y))</span> <span class="pre">∧</span> <span class="pre">(∃z</span> <span class="pre">g(z))</span></code> is a true premise–at least one zoo animal is a tiger
and at least one is a monkey.
But <code class="docutils literal"><span class="pre">∃x(f(x)</span> <span class="pre">∧</span> <span class="pre">g(x))</span></code> does not follow (we refuse to acknowledge tiger-monkeys as
a zoo animal).</p>
<p>The following proof uses the <code class="docutils literal"><span class="pre">ve</span></code>-tactic – a cases analysis.
See the assumptions at lines 3 and 6, based on Line 2:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∃x (p(x) V q(x))  |-  (∃x p(x)) V (∃x q(x))
{
  1. ∃x (p(x) V q(x))                   premise
  2. {
       3. a   p(a) V q(a)               assume
       4. {
            5. p(a)                     assume
            6. ∃x p(x)                  ∃i 5 a
            7. (∃x p(x)) V (∃x q(x))    Vi1 6
       }
       8. {
            9. q(a)                     assume
            10. ∃x q(x)                 ∃i 9 a
            11. (∃x p(x)) V (∃x q(x))   Vi2 10
       }
       12.    (∃x p(x)) V (∃x q(x))     Ve 3 4 8
  }
  13. (∃x p(x)) V (∃x q(x))             ∃e 1 2
}
</pre></div>
</div>
<p>As an exercise, prove the converse of the above:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>(∃x p(x)) V (∃x q(x)) |- ∃x (p(x) V q(x)).
</pre></div>
</div>
</div>
<div class="section" id="an-important-example">
<h4>An Important Example<a class="headerlink" href="#an-important-example" title="Permalink to this headline">¶</a></h4>
<p>We finish with this crucial example.
We use the domain of people:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∃x ∀y isBossOf(x,y)        // isBossOf(boss, subordinate)
</pre></div>
</div>
<p>Read this as, “there is someone who is the boss of everyone”.
From this strong fact we can prove that everyone has a boss, that is,
<code class="docutils literal"><span class="pre">∀u∃v</span> <span class="pre">isBossOf(v,u)</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∃x∀y isBossOf(x,y) |- ∀u∃v isBossOf(v,u)
{
  1. ∃x∀y isBossOf(x,y)           premise
  2. {
       3. b   ∀y isBossOf(b,y)    assume
       4. {
            5. a
            6. isBossOf(b,a)      ∀e 3 a
            7. ∃v isBossOf(v,a)   ∃i 6 b
       }
       8. ∀u∃v isBossOf(v,u)      ∀i 4
  }
  9. ∀u∃v isBossOf(v,u)           ∃e 1 2
}
</pre></div>
</div>
<p>In the above proof, we let <code class="docutils literal"><span class="pre">b</span></code> be our made-up name for the boss-of-everyone.
So, we have the assumption that <code class="docutils literal"><span class="pre">∀y</span> <span class="pre">isBossOf(b,y)</span></code>.
Next, we let <code class="docutils literal"><span class="pre">a</span></code> be “anybody at all” who we might examine in the domain of
people.
The proof exposes that the boss of “anybody at all” in the domain must always be
<code class="docutils literal"><span class="pre">b</span></code>.
<code class="docutils literal"><span class="pre">∀i</span></code> and then <code class="docutils literal"><span class="pre">∃i</span></code> finish the proof.</p>
<p>Here is the proof worked again, with the subproofs swapped:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∃x∀y isBossOf(x,y) |- ∀u∃v isBossOf(v,u)
{
  1. ∃x∀y isBossOf(x,y)                 premise
  2. {
       3. a
       4. {
            5. b     ∀y isBossOf(b,y)   assume
            6. isBossOf(b,a)            ∀e 5 a
            7. ∃v isBossOf(v,a)         ∃i 6 b
       }
       8. ∃v isBossOf(v,a)              ∃e 1 4
  }
  9. ∀u∃v isBossOf(v,u)                 ∀i 2
}
</pre></div>
</div>
<p>Can we prove the converse?
That is, if everyone has a boss, then there is one boss who is the boss of
everyone?</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀u∃v isBossOf(v,u) |- ∃x∀y isBossOf(x,y) ???
</pre></div>
</div>
<p>No – we can try, but we get stuck:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∀u∃v isBossOf(v,u) |- ∃x∀y isBossOf(x,y)
{
  1. ∀u∃v isBossOf(v,u)             premise
  2. {
       3. a
       4. ∃v isBossOf(v,a)          ∀e 1 a
       5. {
            6. b    isBossOf(b,a)   assume
       }
  6. ∀y isBoss(b,y)                 ∀i 2  NO--THIS PROOF IS TRYING TO FINISH
                                          THE OUTER SUBPROOF WITHOUT FINISHING
                                          THE INNER ONE FIRST.
</pre></div>
</div>
<p>We see that the “block structure” of the proofs warns us when we are making
invalid deductions.</p>
<p>It is interesting that we <em>can</em> prove the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∃x∀y isBossOf(x,y) |- ∃z isBossOf(z,z)
</pre></div>
</div>
<p>(“if someone is the boss of everyone, then someone is their own boss”):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>∃x∀y isBossOf(x,y) |- ∃z isBossOf(z,z)
{
  1. ∃x∀y isBossOf(x,y)           premise
  2. {
       3. b    ∀y isBossOf(b,y)   assume
       4. isBossOf(b,b)           ∀e 3 b
       5. ∃z isBossOf(z,z)        ∃i 4 b
  }
  6. ∃z isBossOf(z,z)             ∃e 1 2
}
</pre></div>
</div>
<p>Line 4 exposes that the “big boss”, <code class="docutils literal"><span class="pre">b</span></code>, <em>must</em> be its own boss.</p>
</div>
<div class="section" id="domains-and-models">
<h4>Domains and Models<a class="headerlink" href="#domains-and-models" title="Permalink to this headline">¶</a></h4>
<p>The examples of bosses and workers illustrate these points:</p>
<ol class="arabic">
<li><p class="first"><em>You must state the domain of individuals when you state premises</em>.
In the bosses-workers examples, the domain is a collection of people.
Both the bosses and the workers belong to that domain.
Here are three drawings of possible different domains, where an arrow,
<code class="docutils literal"><span class="pre">person1</span></code> –→  <code class="docutils literal"><span class="pre">person2</span></code>, means that <code class="docutils literal"><span class="pre">person1</span></code> is the boss of
<code class="docutils literal"><span class="pre">person2</span></code>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="34%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><img alt="../../_images/boss1.png" class="first last" src="../../_images/boss1.png" />
</td>
<td><img alt="../../_images/boss2.png" class="first last" src="../../_images/boss2.png" />
</td>
<td><img alt="../../_images/boss2a.png" class="first last" src="../../_images/boss2a.png" />
</td>
</tr>
</tbody>
</table>
<p>Notice that <code class="docutils literal"><span class="pre">∀u∃v</span> <span class="pre">isBossOf(v,u)</span></code> (“everyone has a boss” or “for all persons
there exists at least one person who is their boss”) holds
true for the first two domains but not the third.  In the third, the person
in the top middle has no boss.</p>
<p><code class="docutils literal"><span class="pre">∃x∀y</span> <span class="pre">isBossOf(x,y)</span></code> (“there is a boss of everybody” or “there exists a
person who is the boss of all persons”) holds true for only the second domain.</p>
</li>
<li><p class="first"><em>When we make a proof of</em> <code class="docutils literal"><span class="pre">P</span> <span class="pre">|-</span> <span class="pre">Q</span></code> <em>and</em> <code class="docutils literal"><span class="pre">P</span></code> <em>holds true for a domain,
then</em> <code class="docutils literal"><span class="pre">Q</span></code> <em>must also hold true for that same domain</em>.
We proved that <code class="docutils literal"><span class="pre">∃x∀y</span> <span class="pre">isBossOf(x,y)</span> <span class="pre">|-</span> <span class="pre">∃z</span> <span class="pre">isBossOf(z,z)</span></code>, and
sure enough, in the second example domain, <code class="docutils literal"><span class="pre">∃z</span> <span class="pre">isBossOf(z,z)</span></code> holds
true.</p>
<p>Our logic system is designed to work in this way!
When we do a logic proof, we are generating new facts that must hold true for
any domain for which the premises hold true.
This property is called <em>soundness of the logic</em>, and we will examine it more
closely in a later section in this chapter.</p>
</li>
<li><p class="first"><em>A domain can have infinitely many individuals</em>.
Here is a drawing of a domain of infinitely many people, where each person
bosses the person to their right:</p>
<img alt="../../_images/boss3.png" src="../../_images/boss3.png" />
<p>In this domain, <code class="docutils literal"><span class="pre">∀u∃v</span> <span class="pre">isBossOf(v,u)</span></code> holds true as does
<code class="docutils literal"><span class="pre">∀u∃v</span> <span class="pre">isBossOf(u,v)</span></code> (“everyone bosses someone”), but
<code class="docutils literal"><span class="pre">∃z</span> <span class="pre">isBossOf(z,z)</span></code> does not hold true.</p>
</li>
</ol>
<p>The third example domain is famous – it is just the integer domain, where
<code class="docutils literal"><span class="pre">isBossOf</span></code> is actually <code class="docutils literal"><span class="pre">&gt;</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">.</span> <span class="o">.</span> <span class="o">.</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">3</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">&lt;</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
</pre></div>
</div>
<p>Indeed, one of the main applications of logic is proving properties of numbers.
This leads to a famous question:
Is it possible to write a collection of premises from which we can deduce
(make proofs of) all the logical properties that hold true for the domain of
integers?</p>
<p>The answer is NO.
In the 1920s, Kurt Goedel, a German PhD student, proved that the integers, along
with <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, are so complex that it is impossible to ever
formulate a finite set (or even an algorithmically defined infinite set) of
premises that generate all the true properties of the integers.
Goedel’s result, known as the <em>First Incompleteness Theorem</em>, set mathematics
back on its heels and directly led to the formulation of theoretical computer
science (of which this course is one small part).
There is more material about Goedel’s work at the end of this chapter.</p>
</div>
<div class="section" id="id1">
<h4>Tactics for The ∃-Rules<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>There are two tactics; neither is easy to master:</p>
<ul>
<li><p class="first">(***) <code class="docutils literal"><span class="pre">∃e</span></code>-tactic:
To prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">∃x</span> <span class="pre">P(x)</span> <span class="pre">|-</span> <span class="pre">Q</span></code>,</p>
<ol class="arabic simple">
<li>assume <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">P(a)</span></code>, where <code class="docutils literal"><span class="pre">a</span></code> is a brand new anonymous name</li>
<li>prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">P(a)</span> <span class="pre">|-</span> <span class="pre">Q</span></code></li>
<li>apply <code class="docutils literal"><span class="pre">∃e</span></code></li>
</ol>
<p>The proof looks like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>1.  Premises        premise
2.  ∃x P(x)         premise
i.  {
      j. a   P(a)   assume
         (fill in)
      k. Q          // Q does not mention  a!
}
l.  Q               ∃e 2 i
</pre></div>
</div>
</li>
<li><p class="first">(*) <code class="docutils literal"><span class="pre">∃i</span></code>-tactic:
To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">∃x</span> <span class="pre">P(x)</span></code>, try to prove <code class="docutils literal"><span class="pre">P(e)</span></code> for some <code class="docutils literal"><span class="pre">e</span></code> that
already appears in the partially completed proof.
Finish with <code class="docutils literal"><span class="pre">∃i</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>1.  Premises        premise
  . . .
i. ...e...
        (fill in)
j.  P(e)
k.  ∃x P(x)         ∃i j e
</pre></div>
</div>
</li>
</ul>
<p>Look at the Wheel-of-Fortune proofs for instances where these tactics were
applied.</p>
</div>
</div>
</div>
<div class="section" id="equivalences-in-predicate-logic">
<h2>4.3. Equivalences in Predicate Logic<a class="headerlink" href="#equivalences-in-predicate-logic" title="Permalink to this headline">¶</a></h2>
<p>Here are some important equivalences in predicate logic.
(We include the <code class="docutils literal"><span class="pre">pbc</span></code>-rule to prove the third and fourth ones.)</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">∀x</span> <span class="pre">∀y</span> <span class="pre">P(x,y)</span> <span class="pre">⇔</span> <span class="pre">∀y</span> <span class="pre">∀x</span> <span class="pre">P(x,y)</span></code></li>
<li><code class="docutils literal"><span class="pre">∃x</span> <span class="pre">∃y</span> <span class="pre">P(x,y)</span> <span class="pre">⇔</span> <span class="pre">∃y</span> <span class="pre">∃x</span> <span class="pre">P(x,y)</span></code></li>
<li><code class="docutils literal"><span class="pre">¬</span> <span class="pre">(∀x</span> <span class="pre">P(x))</span> <span class="pre">⇔</span> <span class="pre">∃x</span> <span class="pre">¬</span> <span class="pre">P(x)</span></code></li>
<li><code class="docutils literal"><span class="pre">¬</span> <span class="pre">(∃x</span> <span class="pre">P(x))</span> <span class="pre">⇔</span> <span class="pre">∀x</span> <span class="pre">¬</span> <span class="pre">P(x)</span></code></li>
<li><code class="docutils literal"><span class="pre">Q</span> <span class="pre">∧</span> <span class="pre">(∀x</span> <span class="pre">P(x))</span> <span class="pre">⇔</span> <span class="pre">∀x</span> <span class="pre">(Q</span> <span class="pre">∧</span> <span class="pre">P(x))</span> <span class="pre">(where</span> <span class="pre">x</span> <span class="pre">does</span> <span class="pre">not</span> <span class="pre">appear</span> <span class="pre">in</span> <span class="pre">Q)</span></code></li>
<li><code class="docutils literal"><span class="pre">Q</span> <span class="pre">v</span> <span class="pre">(∀x</span> <span class="pre">P(x))</span> <span class="pre">⇔</span> <span class="pre">∀x</span> <span class="pre">(Q</span> <span class="pre">V</span> <span class="pre">P(x))</span> <span class="pre">(where</span> <span class="pre">x</span> <span class="pre">does</span> <span class="pre">not</span> <span class="pre">appear</span> <span class="pre">in</span> <span class="pre">Q)</span></code></li>
<li><code class="docutils literal"><span class="pre">Q</span> <span class="pre">∧</span> <span class="pre">(∃x</span> <span class="pre">P(x))</span> <span class="pre">⇔</span> <span class="pre">∃x</span> <span class="pre">(Q</span> <span class="pre">∧</span> <span class="pre">P(x))</span> <span class="pre">(where</span> <span class="pre">x</span> <span class="pre">does</span> <span class="pre">not</span> <span class="pre">appear</span> <span class="pre">in</span> <span class="pre">Q)</span></code></li>
<li><code class="docutils literal"><span class="pre">Q</span> <span class="pre">V</span> <span class="pre">(∃x</span> <span class="pre">P(x))</span> <span class="pre">⇔</span> <span class="pre">∃x</span> <span class="pre">(Q</span> <span class="pre">V</span> <span class="pre">P(x))</span> <span class="pre">(where</span> <span class="pre">x</span> <span class="pre">does</span> <span class="pre">not</span> <span class="pre">appear</span> <span class="pre">in</span> <span class="pre">Q)</span></code></li>
</ul>
</div>
<div class="section" id="soundness-and-completeness-of-deduction-rules">
<h2>4.4. Soundness and Completeness of Deduction Rules<a class="headerlink" href="#soundness-and-completeness-of-deduction-rules" title="Permalink to this headline">¶</a></h2>
<p>Once again, it is time to consider what propositions mean and how it is that
<code class="docutils literal"><span class="pre">∀i</span></code>, <code class="docutils literal"><span class="pre">∀e</span></code>, <code class="docutils literal"><span class="pre">∃i</span></code>, <code class="docutils literal"><span class="pre">∃e</span></code> preserve meaning.</p>
<p>At this point, it would be good to review the section on models.
There, we saw that the connectives, <code class="docutils literal"><span class="pre">∧</span></code>, <code class="docutils literal"><span class="pre">V</span></code>, <code class="docutils literal"><span class="pre">¬</span></code>, <code class="docutils literal"><span class="pre">→</span></code> were understood
in terms of truth tables.
Also, the primitive propositions were just letters like <code class="docutils literal"><span class="pre">P</span></code>, <code class="docutils literal"><span class="pre">Q</span></code>, and <code class="docutils literal"><span class="pre">R</span></code>,
which were interpreted as either True or False.</p>
<p>Within predicate logic, we use predicates, like <code class="docutils literal"><span class="pre">isMortal()</span></code> and <code class="docutils literal"><span class="pre">&gt;</span></code>, to
build propositions, and we might also use functions, like <code class="docutils literal"><span class="pre">+</span></code>, within the
predicates.
We must give meanings to all predicates and functions so that we can decide
whether propositions like <code class="docutils literal"><span class="pre">isMortal(God)</span></code> and <code class="docutils literal"><span class="pre">(3+1)&gt;x</span></code> are True or False.
The act of giving meanings to the predicates and functions is called an
<em>interpretation</em>.</p>
<div class="section" id="interpretations">
<h3>4.4.1. Interpretations<a class="headerlink" href="#interpretations" title="Permalink to this headline">¶</a></h3>
<p>When we write propositions in a logic, we use predicates and function symbols
(e.g., <code class="docutils literal"><span class="pre">∀i</span> <span class="pre">(i*2)&gt;i</span></code>).
An interpretation gives the meaning of</p>
<ol class="arabic simple">
<li>the underlying domain – what set of elements it names;</li>
<li>each function symbol – what answers it computes from its arguments from the
domain; and</li>
<li>each predicate – which combinations of arguments from the domain lead to
True answers and False answers.</li>
</ol>
<p>Here is an example.
Say we have the function symbols, <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, and predicate
symbols, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">=</span></code>.
What do these names and symbols mean?
We must interpret them.</p>
<ul class="simple">
<li>The standard interpretation of arithmetic is that int names the set of all
integers; <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">/</span></code> name integer addition, subtraction,
multiplication, and division, and <code class="docutils literal"><span class="pre">=</span></code> and <code class="docutils literal"><span class="pre">&gt;</span></code> name integer equality
comparison and integer less-than comparison.
With this interpretation of arithmetic, we can interpret propositions.
For example, <code class="docutils literal"><span class="pre">∀i</span> <span class="pre">(i*2)&gt;i</span></code> interprets to False, and
<code class="docutils literal"><span class="pre">∃j</span> <span class="pre">(j*j)=j</span></code> interprets to True.
If we use any extra, “constant names”, (e.g., <code class="docutils literal"><span class="pre">pi</span></code>), we must give meanings
to the constants, also.</li>
<li>Now, given function names <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, and predicates, <code class="docutils literal"><span class="pre">=</span></code>,
<code class="docutils literal"><span class="pre">&gt;</span></code>, we can choose to interpret them in another way.
For example, we might interpret the underlying domain as just the nonnegative
integers.
We can interpret <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">=</span></code> as the usual operations on
ints, but we must give a different meaning to <code class="docutils literal"><span class="pre">-</span></code>.
We might define <code class="docutils literal"><span class="pre">m</span> <span class="pre">-</span> <span class="pre">n</span> <span class="pre">==</span> <span class="pre">0</span></code>, whenever <code class="docutils literal"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">m</span></code>.</li>
<li>Yet another interpretation is to say that the domain is just <code class="docutils literal"><span class="pre">{0,1}</span></code>;
the functions are the usual arithmetic operations on 0,1, modulo 2;
and <code class="docutils literal"><span class="pre">&gt;</span></code> is defined <code class="docutils literal"><span class="pre">1</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> (and that’s it).</li>
</ul>
<p>These three examples show that the symbols in a logic can be interpreted in
multiple different ways.
(In the chapter propositional logic, we called an interpretation a
“context”.
In this chapter, we see that a “context” is quite complex – domain, functions,
and predicates.)</p>
<p>Here is a second example.
There are no functions, and the predicates are <code class="docutils literal"><span class="pre">isMortal(_)</span></code>,
<code class="docutils literal"><span class="pre">isLeftHanded(_)</span></code>, <code class="docutils literal"><span class="pre">isMarriedTo(_,_)</span></code>.
An interpretation might make all (living) members of the human race as the
domain;
make <code class="docutils literal"><span class="pre">isMortal(h)</span></code> True for every human, <code class="docutils literal"><span class="pre">h</span></code>;
make <code class="docutils literal"><span class="pre">isLeftHanded(j)</span></code> True for exactly those humans, <code class="docutils literal"><span class="pre">j</span></code>, who are left
handed;
and set <code class="docutils literal"><span class="pre">isMarriedTo(m,f)</span></code> True for all pairs of humans <code class="docutils literal"><span class="pre">m</span></code>, <code class="docutils literal"><span class="pre">f</span></code>, who have
their marriage document in hand.</p>
<p>You get the idea….</p>
<p>We can ask whether a proposition is True within <em>one</em> specific interpretation,
and we can ask whether a proposition is True within <em>all possible</em>
interpretations.
This leads to the notions of soundness and completeness for predicate logic:</p>
<p>A sequent, <code class="docutils literal"><span class="pre">P_1,</span> <span class="pre">P_2,</span> <span class="pre">...,</span> <span class="pre">P_n</span> <span class="pre">|-</span> <span class="pre">Q</span></code> is <em>valid in an interpretation</em>, <code class="docutils literal"><span class="pre">I</span></code>,
provided that when all of <code class="docutils literal"><span class="pre">P_1,</span> <span class="pre">P_2,</span> <span class="pre">...,</span> <span class="pre">P_n</span></code> are True in interpretation
<code class="docutils literal"><span class="pre">I</span></code>, so is <code class="docutils literal"><span class="pre">Q</span></code>.
The sequent is valid exactly when it is valid in all possible interpretations.
We have these results for the rules of propositional logic plus
<code class="docutils literal"><span class="pre">∀i</span></code>, <code class="docutils literal"><span class="pre">∀e</span></code>, <code class="docutils literal"><span class="pre">∃i</span></code>, <code class="docutils literal"><span class="pre">∃e</span></code>:</p>
<ol class="arabic simple">
<li><em>soundness</em>:
When we use the deduction rules to prove that <code class="docutils literal"><span class="pre">P_1,</span> <span class="pre">P_2,</span> <span class="pre">...,</span> <span class="pre">P_n</span> <span class="pre">|-</span> <span class="pre">Q</span></code>,
then the sequent is valid (in all possible interpretations).</li>
<li><em>completeness</em>:
When <code class="docutils literal"><span class="pre">P_1,</span> <span class="pre">P_2,</span> <span class="pre">...,</span> <span class="pre">P_n</span> <span class="pre">|-</span> <span class="pre">Q</span></code> is valid (in all possible interpretations),
then we can use the deduction rules to prove the sequent.</li>
</ol>
<p>Note that, if <code class="docutils literal"><span class="pre">P_1,</span> <span class="pre">P_2,</span> <span class="pre">...,</span> <span class="pre">P_n</span> <span class="pre">|-</span> <span class="pre">Q</span></code> is valid in just one specific
interpretation, we are not guaranteed that our rules will prove it.
This is a famous trouble spot: For centuries, mathematicians were searching for
a set of deduction rules that could be used to build logic proofs of all the
True propositions of arithmetic, that is, the language of int, <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>,
<code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">=</span></code>.
No appropriate rule set was devised.</p>
<p>In the early 20th century, Kurt Gödel showed that it is <em>impossible</em> to
formulate a sound set of rules customized for arithmetic that will prove exactly
the True facts of arithmetic.
Gödel showed this by formulating True propositions in arithmetic notation that
talked about the computational power of the proof rules themselves, making it
impossible for the proof rules to reason completely about themselves.
The form of proposition he coded in logic+arithmetic stated
“I cannot be proved”.
If this proposition is False, it means the proposition can be proved.
But this would make the rule set unsound, because it proved a False claim.
The only possibility is that the proposition is True (and it cannot be proved).
Hence, the proof rules remain sound but are incomplete.</p>
<p>Gödel’s construction, called <em>diagonalization</em>, opened the door to the modern
theory of computer science, called computability theory, where techniques from
logic are used to analyze computer programs.
Computability theory tells us what problems computers cannot solve, and why, and
so we shouldn’t try.
(For example, it is impossible to build a program-termination checker that works
on all programs – the checker won’t work on itself!)
There is also an offshoot of computability theory, called computational
complexity theory, that studies what can be solved and how fast an algorithm can
solve it.  These subjects can be studied in CIS 570 and CIS 575 respectively.</p>
<p>Given an interpretation of a predicate logic, we can say that the “meaning” of a
proposition is exactly the set of interpretations in which the
proposition is True.
This returns us to the Boolean-algebra model of logic.
Or, we can organize the interpretations so that an interpretation grows in its
domain and knowledge over time.
This takes us to the Kripke models.
Or, we can introduce two new programming constructs, the <em>abstract data type</em>
and the <em>parametric polymorphic function</em> and extend the Heyting interpretation.</p>
<p>All of these are possible and are studied in a typical second course on logic.</p>
</div>
</div>
<div class="section" id="summary">
<h2>4.5. Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>Here are the rules for the quantifiers, stated in terms of their tactics:</p>
<ul>
<li><p class="first">(***) <code class="docutils literal"><span class="pre">∀i</span></code>: use to prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">∀x</span> <span class="pre">P(x)</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>1.  Premises         premise
i. {
     j.  a
          (fill in)
     k.  P(a)
}
l. ∀x P(x)           ∀i i
</pre></div>
</div>
</li>
<li><p class="first">(***) <code class="docutils literal"><span class="pre">∃e</span></code>-tactic: use to prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">∃x</span> <span class="pre">P(x)</span> <span class="pre">|-</span> <span class="pre">Q</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>1.  Premises        premise
2.  ∃x P(x)         premise
i.  {
      j. a   P(a)   assume
         (fill in)
      k. Q          // Q does not mention  a!
}
l.  Q               ∃e 2 i
</pre></div>
</div>
</li>
<li><p class="first">(*) <code class="docutils literal"><span class="pre">∀e</span></code>-tactic: use to prove Premises, <code class="docutils literal"><span class="pre">∀x</span> <span class="pre">P(x)</span> <span class="pre">|-</span> <span class="pre">Q</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>1.  Premises        premise
2.  ∀x P(x)         premise
  . . .
j.  P(i)            ∀e 2     // where individual  i  appears earlier in the proof
       (fill in)
k.  Q
</pre></div>
</div>
</li>
<li><p class="first">(*) <code class="docutils literal"><span class="pre">∃i</span></code>-tactic: use to prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">∃x</span> <span class="pre">P(x)</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>1.  Premises        premise
  . . .
i. ...e...
        (fill in)
j.  P(e)
k.  ∃x P(x)         ∃i j e
</pre></div>
</div>
</li>
</ul>
<hr class="docutils" />
<p align=right><small><em>
This note was adapted from David Schmidt's CIS 301, 2008,
<a href="http://people.cis.ksu.edu/¬ schmidt/301s14/Lectures/6quantT.html">Chapter 6</a>
course note.
</em></small></p>
</em></small></p>
<p align=right><small><em>
It was updated in 2018 by Dr John Hatcliff and George Lavezzi <br>
to conform with Logika syntax and more closely match <br>
KSU's CIS 301 course as taught in Spring 2018.
</em></small></p></div>
</div>


    </div>
      
  </div>
</div>

  </body>
</html>