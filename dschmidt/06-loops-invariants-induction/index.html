
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>6. Loops and Loop Invariants &#8212; Sireum Logika</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sireum.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../_static/logika.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="7. Functions and Procedures" href="../07-functions-procedures/index.html" />
    <link rel="prev" title="5. Programming Logic for Assignments and Conditionals" href="../05-programming-logic/index.html" />
  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          Logika</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../doc/01-getting-started/index.html">Download</a></li>
                <li><a href="../../doc/index.html">Documentation</a></li>
                <li><a href="../index.html">Course Notes</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html"> <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#"> <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">6. Loops and Loop Invariants</a><ul>
<li><a class="reference internal" href="#while-loops">6.1. While Loops</a><ul>
<li><a class="reference internal" href="#law-for-while-loops-claim-transformation">6.1.1. Law for While-Loops (Claim Transformation)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples-of-invariant-discovery">6.2. Examples of Invariant Discovery</a><ul>
<li><a class="reference internal" href="#multiplication-as-repeated-addition">6.2.1. Multiplication as Repeated Addition</a></li>
<li><a class="reference internal" href="#division-as-repeated-subtraction">6.2.2. Division as Repeated Subtraction</a></li>
<li><a class="reference internal" href="#averaging-test-scores">6.2.3. Averaging Test Scores</a></li>
<li><a class="reference internal" href="#squaring-an-array-s-numbers">6.2.4. Squaring an Array’s Numbers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#logika-solution-modes">6.3. Logika Solution Modes</a><ul>
<li><a class="reference internal" href="#auto-mode">6.3.1. Auto-mode</a></li>
<li><a class="reference internal" href="#symexe-mode">6.3.2. Symexe-mode</a></li>
<li><a class="reference internal" href="#pitfalls-of-auto-and-symexe">6.3.3. Pitfalls of Auto and Symexe</a></li>
</ul>
</li>
<li><a class="reference internal" href="#loop-termination-and-total-correctness">6.4. Loop Termination and Total Correctness</a></li>
<li><a class="reference internal" href="#sequences-and-the-use-of-universal-and-existential-assertions">6.5. Sequences and the use of Universal and Existential Assertions</a><ul>
<li><a class="reference internal" href="#sequences">6.5.1. Sequences</a><ul>
<li><a class="reference internal" href="#types-and-constructors">Types and Constructors</a></li>
<li><a class="reference internal" href="#operations-and-properties">Operations and Properties</a></li>
<li><a class="reference internal" href="#law-for-sequence-element-assignment-claim-transformation">Law for Sequence Element Assignment (Claim Transformation)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#use-of-quantifiers">6.5.2. Use of Quantifiers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary">6.6. Summary</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <br/>
<font color="darkgray">
<big><big><b>
Logika: Programming Logics
</b></big></big>
</font>
<br/>
<font color="black">
<big><big><big><big><b>
6. Loop, Invariants, Induction
</b></big></big></big></big>
</font><div class="section" id="loops-and-loop-invariants">
<span id="loops-invariants-induction"></span><h1>6. Loops and Loop Invariants<a class="headerlink" href="#loops-and-loop-invariants" title="Permalink to this headline">¶</a></h1>
<p>At the end of the last chapter we discussed how a conditional branching
creates two “paths” for the logic to flow thru and they are combined
in a <strong>disjunction</strong> after the condition. A <em>loop</em> is a command that restarts itself
over and over while the loop condition remains true.</p>
<p>In order to analyze loop behavior we will need to know: what is true before the
loop executes, what is done inside the loop and what true after the loop,
regardless of how many times the loop executes.
At the end of the loop, the <strong>conjunction</strong> of the negation of the loop-condition
and property called the loop-invariant are true.</p>
<p>The loop’s <em>invariant</em> is a statement about what is true before you begin the
body of the loop and after iteration of the loop-body.  Put another way,
the loop-invariant <strong>must</strong> be true each time you go to check the loop condition;
it is true the first time you check to see if you go into the loop, and still
still true the last time you check and “skip” the loop.</p>
<a class="reference internal image-reference" href="../../_images/06-image-10.png"><img alt="../../_images/06-image-10.png" src="../../_images/06-image-10.png" style="width: 537.6px; height: 384.0px;" /></a>
<div class="section" id="while-loops">
<h2>6.1. While Loops<a class="headerlink" href="#while-loops" title="Permalink to this headline">¶</a></h2>
<p>Consider the factorial <code class="docutils literal notranslate"><span class="pre">n!</span></code>.  We can understand factorial as a repeated
product: for integer <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>n! == 1 * 2 * 3 * ...up to... * n
</pre></div>
</div>
<div class="sidebar">
<p class="first sidebar-title">While-loop syntax and <em>modifies</em></p>
<p>Syntaxt is similar to C#</p>
<p>However, a while statement <em>must</em> be immediately followed by a Logika
proof block.  This may contain an invariant clause, which catalogs
any invariant claims (invariants are optional).  The block must contain
a modifies clause.</p>
<p>In Logika, when a loop (also a function) modifies a variable from an outside
or higher level scope it must explicitly state that in a Logika proof
block immediately following the <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">()</span> <span class="pre">{</span></code> line.  Since any loop counter
or other sentinel value is declared outside the loop, the loop must either
modify the value or loop forever.</p>
<p class="last">In this case line 9 states that both i and fac may be modified in the loop.</p>
</div>
<p>It is easy to write a loop program that computes the repeated product:</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.sireum.logika._</span>
<span class="n">val</span> <span class="n">n</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s2">&quot;Type a nonnegative int: &quot;</span><span class="p">)</span>
<span class="n">assume</span><span class="p">(</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">var</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">var</span> <span class="n">fac</span><span class="p">:</span> <span class="n">Z</span>  <span class="o">=</span> <span class="mi">1</span>

<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
<span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">    modifies i, fac</span>
<span class="s2">    }&quot;&quot;&quot;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">fac</span> <span class="o">=</span> <span class="n">fac</span> <span class="o">*</span> <span class="n">i</span>
    <span class="p">}</span>

</pre></div>
</td></tr></table></div>
<p>The loop adjoins the multiplications, <code class="docutils literal notranslate"><span class="pre">*1</span></code>, <code class="docutils literal notranslate"><span class="pre">*2</span></code>, <code class="docutils literal notranslate"><span class="pre">*3</span></code>, etc., to the
running total, <code class="docutils literal notranslate"><span class="pre">fac</span></code>, until the loop reaches <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">n</span></code>.
Consider some execution cases:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>n == 0: the loop repeats 0 times: it computes  fac == 1  ==  0!
n == 1: the loop repeats 1 time:  it computes  fac == 1 * 1  ==  1!
n == 2: the loop repeats 2 times: it computes  fac == (1 * 1) * 2  ==  2!
n == 3: the loop repeats 3 times: it computes  fac == (1 * 1 * 2) * 3  ==  3!
n == 4: the loop repeats 4 times: it computes  fac == (1 * 1 * 2 * 3) * 4  ==  4!
. . .
the loop repeats k+1 times: it computes  fac == (k!) * (k+1)  ==  (k+1)!
</pre></div>
</div>
<p>For input, <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">4</span></code>, the loop computes correctly <code class="docutils literal notranslate"><span class="pre">4!</span></code> in 4 iterations
because the loop computes correctly <code class="docutils literal notranslate"><span class="pre">3!</span></code> in 3 iterations –
<em>the fourth loop iteration builds upon the work of the previous three</em>.
This is the standard use of a loop: each loop iteration builds on the previous
iterations to move one step closer to the final goal.</p>
<p>We should always ask this crucial question about every loop we write:</p>
<blockquote>
<div>Say that the loop has been running for some iterations; what has it accomplished so far?</div></blockquote>
<p>For the factorial example, the response is:
“after <code class="docutils literal notranslate"><span class="pre">i</span></code> iterations, variable <code class="docutils literal notranslate"><span class="pre">fac</span></code> has the value, <code class="docutils literal notranslate"><span class="pre">i!</span></code>, that is,
<code class="docutils literal notranslate"><span class="pre">fac</span> <span class="pre">==</span> <span class="pre">i!</span></code>.”</p>
<p>This answer is important, because it reveals the strategy the loop uses to reach
its goal in stages: as <code class="docutils literal notranslate"><span class="pre">i</span></code> counts upwards towards <code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">fac</span> <span class="pre">==</span> <span class="pre">i!</span></code>
repeatedly holds true.
Because the loop stops when <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">n</span></code>, this means the loop will achieve its
goal: <code class="docutils literal notranslate"><span class="pre">fac</span> <span class="pre">==</span> <span class="pre">n!</span></code>.</p>
<p>The answer to the “crucial question” listed above is the loop’s
<em>invariant property</em>. Now, why is it an invariant?</p>
<p>This is because <em>the output from the loop’s prior iterations flows into the
loop’s next iteration</em>.
So, whatever is accomplished looks the same, iteration after iteration after
iteration.
This is a logical property that can be proved.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Logika Programming <em>fact</em></p>
<p>A <em>fact</em> statement can be used to introduce global (named) axioms and
(pure) proof functions (whose behaviors are specified via axioms)
to help with specifying contracts.  It is important to note that, as the name
implies, Logika treats these axioms as facts–if you make an error in the
definition, Logika will dutifully enforce that error everywhere in the program.</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.sireum.logika._</span>
<span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">  fact // axioms</span>
<span class="s2">    def factorial(n: Z): Z</span>
<span class="s2">    fZero. factorial(0) == 1</span>
<span class="s2">    fPos.  ∀x: Z  x &gt; 0 → factorial(x) == factorial(x - 1) * x</span>
<span class="s2">}&quot;&quot;&quot;</span>
</pre></div>
</td></tr></table></div>
<p>Lets go through this quickly.  In this class, facts will be given to you, you
are only expected to know how to use them.</p>
<p>On line 4 we see <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">factorial(n:Z):</span> <span class="pre">Z</span></code>.  This tells you that the <em>fact</em> is
named <code class="docutils literal notranslate"><span class="pre">factorial</span></code>, it has one named argument <code class="docutils literal notranslate"><span class="pre">n</span></code>, which is an integer, and
that factorial itself evaluates to an integer (think of this as a return type).</p>
<p class="last">Line 5 is the first rule, <code class="docutils literal notranslate"><span class="pre">fZero.</span> <span class="pre">factorial(0)</span> <span class="pre">==</span> <span class="pre">1</span></code>.  This rule, used as a
justification, allows you to state <code class="docutils literal notranslate"><span class="pre">factorial(0)</span> <span class="pre">==</span> <span class="pre">1</span></code> as a claim.
Using this new claim, you can prove additional things through substitution.
Be sure you understand the <code class="docutils literal notranslate"><span class="pre">fPos</span></code> rule.  This is a syntactical form and semantical
meaning you will see often in programming logic.</p>
</div>
<p>We deduce the invariant property on the factorial-loop body like this:</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.sireum.logika._</span>

<span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">  fact // axioms</span>
<span class="s2">    def factorial(n: Z): Z</span>
<span class="s2">    fZero. factorial(0) = 1</span>
<span class="s2">    fPos.  ∀x: Z  x &gt; 0 → factorial(x) = factorial(x - 1) * x</span>
<span class="s2">}&quot;&quot;&quot;</span>


<span class="n">val</span> <span class="n">n</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">var</span> <span class="n">i</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">var</span> <span class="n">fac</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">      1. i == 0              premise</span>
<span class="s2">      2. i &gt;= 0              algebra 1</span>
<span class="s2">      3. fac == 1            premise</span>
<span class="s2">      4. factorial(0) == 1   fact fZero</span>
<span class="s2">      5. factorial(i) == 1   subst2 1 4</span>
<span class="s2">      6. fac = factorial(i)  algebra 3 5</span>
<span class="s2">      }&quot;&quot;&quot;</span>
<span class="o">//</span> <span class="n">begin</span> <span class="o">--</span> <span class="n">fac</span> <span class="o">==</span> <span class="n">factorial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="o">//</span><span class="n">first</span> <span class="s2">&quot;update&quot;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">            1. i_old == 0              premise</span>
<span class="s2">            2. i = i_old + 1           premise</span>
<span class="s2">            3. i_old &gt;= 0              premise</span>
<span class="s2">            4. i &gt; 0                   algebra 1 2 3</span>
<span class="s2">            5. fac = factorial(i_old)  premise</span>
<span class="s2">            6. fac = factorial(i-1)    algebra 5 2</span>
<span class="s2">      }&quot;&quot;&quot;</span>

    <span class="n">fac</span> <span class="o">=</span> <span class="n">fac</span> <span class="o">*</span> <span class="n">i</span>
     <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">          1. fac_old = factorial(i-1)     premise</span>
<span class="s2">          2. fac = fac_old * i            premise</span>
<span class="s2">          3. i &gt; 0                        premise</span>
<span class="s2">          4. ∀x: Z  x &gt; 0 → factorial(x) =</span>
<span class="s2">                 factorial(x - 1) * x     fact fPos</span>
<span class="s2">          5. i &gt; 0 → factorial(i) =</span>
<span class="s2">                 factorial(i - 1) * i     ∀e 4 i</span>
<span class="s2">          6. factorial(i) =</span>
<span class="s2">               factorial(i - 1) * i       →e 5 3</span>
<span class="s2">          7. factorial(i) =</span>
<span class="s2">               fac_old * i                algebra 6 1</span>
<span class="s2">          8. fac = factorial(i)           algebra 7 2</span>
<span class="s2">     }&quot;&quot;&quot;</span>
    <span class="o">//</span> <span class="n">End</span> <span class="n">first</span> <span class="n">update</span> <span class="o">--</span> <span class="n">fac</span> <span class="o">==</span> <span class="n">factorial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

         <span class="o">//</span><span class="n">second</span> <span class="s2">&quot;update&quot;</span>
         <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
           <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">                 1. i_old &gt; 0              premise</span>
<span class="s2">                 2. i = i_old + 1           premise</span>
<span class="s2">                 3. i_old &gt;= 0              premise</span>
<span class="s2">                 4. i &gt; 0                   algebra 1 2 3</span>
<span class="s2">                 5. fac = factorial(i_old)  premise</span>
<span class="s2">                 6. fac = factorial(i-1)    algebra 5 2</span>
<span class="s2">           }&quot;&quot;&quot;</span>

         <span class="n">fac</span> <span class="o">=</span> <span class="n">fac</span> <span class="o">*</span> <span class="n">i</span>
          <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">               1. fac_old = factorial(i-1)     premise</span>
<span class="s2">               2. fac = fac_old * i            premise</span>
<span class="s2">               3. i &gt; 0                        premise</span>
<span class="s2">               4. ∀x: Z  x &gt; 0 → factorial(x) =</span>
<span class="s2">                      factorial(x - 1) * x     fact fPos</span>
<span class="s2">                5. i &gt; 0 → factorial(i) =</span>
<span class="s2">                       factorial(i - 1) * i     ∀e 4 i</span>
<span class="s2">                6. factorial(i) =</span>
<span class="s2">                     factorial(i - 1) * i       →e 5 3</span>
<span class="s2">                7. factorial(i) =</span>
<span class="s2">                     fac_old * i                algebra 6 1</span>
<span class="s2">                8. fac = factorial(i)           algebra 7 2</span>
<span class="s2">          }&quot;&quot;&quot;</span>
         <span class="o">//</span> <span class="n">End</span> <span class="n">second</span> <span class="n">update</span> <span class="o">--</span> <span class="n">fac</span> <span class="o">==</span> <span class="n">factorial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="o">//</span> <span class="n">Third</span> <span class="n">update</span> <span class="ow">is</span> <span class="n">exact</span> <span class="n">copy</span> <span class="n">of</span> <span class="n">second</span>
</pre></div>
</td></tr></table></div>
<p>This little example is just the loop repeated twice. What we see is both at
the begining and after each update, <code class="docutils literal notranslate"><span class="pre">fac</span> <span class="pre">==</span> <span class="pre">factorial(i)</span></code>.
Notice how the knowledge generated by completing one iteration “feeds into”
the next iteration.
And, after each iteration, that knowledge is that <code class="docutils literal notranslate"><span class="pre">fac</span> <span class="pre">==</span> <span class="pre">factorial(i)</span></code>.</p>
<div class="sidebar">
<p class="first sidebar-title">Logika Loop Invariants</p>
<blockquote>
<div>The optional keyword <em>invariant</em> goes in the while-loop proof, before the
<em>modifies</em> clause.  Each requirement can go on its own line.  Use of the
<em>invariant</em> clause allows you to use the invariant(s) in the proof block
immediately following the while-loop.</div></blockquote>
<p><strong>Loop-termination</strong></p>
<blockquote class="last">
<div>A robust proof of a loop would include the proof that loop must terminate.
The mechanics and thought process behind proving loop termination will be
deferred to a later time.  However, it is important for the student
to realize if a loop does not terminate, Logika may verify claims that are
not necessarily true.  A semantic error in programing can lead to unsound
conclusions.</div></blockquote>
</div>
<p>A working Logika program would look something like</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.sireum.logika._</span>
<span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">  fact // axioms</span>
<span class="s2">    def factorial(n: Z): Z</span>
<span class="s2">    fZero. factorial(0) == 1</span>
<span class="s2">    fPos.  ∀x: Z  x &gt; 0 → factorial(x) == factorial(x - 1) * x</span>
<span class="s2">}&quot;&quot;&quot;</span>

<span class="n">val</span> <span class="n">n</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s2">&quot;Type a nonnegative int: &quot;</span><span class="p">)</span>
<span class="n">assume</span><span class="p">(</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">var</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">var</span> <span class="n">fac</span><span class="p">:</span> <span class="n">Z</span>  <span class="o">=</span> <span class="mi">1</span>
<span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">     1. i == 0             premise</span>
<span class="s2">     2. fac == 1           premise</span>
<span class="s2">     3. factorial(0) == 1   fact fZero</span>
<span class="s2">     4. factorial(i) == fac algebra 1 2 3</span>
<span class="s2">     5. i &gt;= 0              algebra 1</span>
<span class="s2">    }&quot;&quot;&quot;</span>

<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
<span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">     invariant factorial(i) = fac</span>
<span class="s2">               i &gt;= 0</span>
<span class="s2">     modifies i, fac</span>
<span class="s2">}&quot;&quot;&quot;</span>
<span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">      1. factorial(i) == fac premise</span>
<span class="s2">}&quot;&quot;&quot;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">        0. i_old &gt;= 0                       premise</span>
<span class="s2">        1. factorial(i_old) == fac          premise</span>
<span class="s2">        2. i = i_old + 1                    premise</span>
<span class="s2">        3. factorial(i - 1) == fac          algebra 1 2</span>
<span class="s2">        4. i &gt; 0                            algebra 0 2</span>
<span class="s2">    }&quot;&quot;&quot;</span>
    <span class="n">fac</span> <span class="o">=</span> <span class="n">fac</span> <span class="o">*</span> <span class="n">i</span>
    <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">          1. factorial(i - 1) == fac_old    premise</span>
<span class="s2">          2. fac == fac_old * i             premise</span>
<span class="s2">          3. fac == factorial(i - 1) * i    algebra 1 2</span>
<span class="s2">          4. ∀x: Z  x &gt; 0 → factorial(x) =</span>
<span class="s2">                    factorial(x - 1) * x    fact fPos</span>
<span class="s2">          5. i&gt;0 → factorial(i) =</span>
<span class="s2">                 factorial(i - 1) * i       ∀e 4 i</span>
<span class="s2">          6. i &gt; 0                          premise</span>
<span class="s2">          7. factorial(i) =</span>
<span class="s2">                  factorial(i - 1) * i      →e 5 6</span>
<span class="s2">          8. fac = factorial(i)             algebra 3 7</span>
<span class="s2">        }&quot;&quot;&quot;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Pay particular attention to lines 17 and 18, where we prove the invariant is true
before entering the loop the first time.  Similarly, lines 47 and 50 re-establish
the invariant before we try to loop again.  Thus, we prove the loop invariant
holds each time we check the loop-condition and possibly proceed through the
loop-body.</p>
<p>Of course, on each loop the loop counter, <code class="docutils literal notranslate"><span class="pre">i</span></code>, gets larger by one, meaning
that we are closer to achieving the final goal, but the changing values of
<code class="docutils literal notranslate"><span class="pre">fac</span></code> and <code class="docutils literal notranslate"><span class="pre">i</span></code> ensure that <code class="docutils literal notranslate"><span class="pre">fac</span> <span class="pre">==</span> <span class="pre">factorial(i)</span></code> remains true:
“after <code class="docutils literal notranslate"><span class="pre">i</span></code> iterations, <code class="docutils literal notranslate"><span class="pre">fac</span></code> has value <code class="docutils literal notranslate"><span class="pre">factorial(i)</span></code>.”</p>
<p><em>The invariant property documents the loop’s structure – how the loop achieves
its goal</em>.</p>
<p>As exciting as that discussion was, the loop-invariant is a means to an end,
not the end itself.  What is it we are trying to achieve?  In this example, we
would like to be able to prove that fac == n-factorial.  As <em>facts</em> cannot
be used in assertions, what we will really assert is <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">n</span></code>, and then we know
from our invariant that fac == n-factorial.  Consider:</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.sireum.logika._</span>
<span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">  fact // axioms</span>
<span class="s2">    def factorial(n: Z): Z</span>
<span class="s2">    fZero. factorial(0) == 1</span>
<span class="s2">    fPos.  ∀x: Z  x &gt; 0 → factorial(x) == factorial(x - 1) * x</span>
<span class="s2">}&quot;&quot;&quot;</span>
<span class="o">//</span> <span class="n">omitting</span>  <span class="n">manual</span> <span class="n">proofs</span> <span class="n">through</span> <span class="n">end</span> <span class="n">of</span> <span class="n">loop</span>
<span class="n">val</span> <span class="n">n</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s2">&quot;Type a nonnegative int: &quot;</span><span class="p">)</span>
<span class="n">assume</span><span class="p">(</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">var</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">var</span> <span class="n">fac</span><span class="p">:</span> <span class="n">Z</span>  <span class="o">=</span> <span class="mi">1</span>

<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
<span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">     invariant factorial(i) = fac</span>
<span class="s2">               i &gt;= 0</span>
<span class="s2">     modifies i, fac</span>
<span class="s2">}&quot;&quot;&quot;</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">fac</span> <span class="o">=</span> <span class="n">fac</span> <span class="o">*</span> <span class="n">i</span>
<span class="p">}</span>
<span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">     1. ¬ (i &lt; n)            premise  //negation of loop condition</span>
<span class="s2">     2. i &gt;= 0               premise  // invariant</span>
<span class="s2">     3. factorial(i) = fac   premise  // invariant</span>

<span class="s2">     //. i = n               some justification but probably algebra or subst</span>
<span class="s2">}&quot;&quot;&quot;</span>
<span class="k">assert</span><span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>For certain, when the loop quits after <code class="docutils literal notranslate"><span class="pre">i</span></code> iterations, we know that
the invariant holds.
But we also know that the loop’s test has gone false, that is, <code class="docutils literal notranslate"><span class="pre">~(i</span> <span class="pre">&lt;</span> <span class="pre">n)</span></code>,
that is, <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&gt;=n</span></code>.  However these facts are not enough to prove <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">n</span></code>.
In this case we say our invariant is too weak, it theoretically admits too many
possibilities.</p>
<div class="sidebar">
<p class="first sidebar-title">Hey wait a minute</p>
<p class="last">You might want to call foul here and claim it is obvious from reading the entire
program that <code class="docutils literal notranslate"><span class="pre">i</span></code> <strong>must</strong> be <code class="docutils literal notranslate"><span class="pre">n</span></code>.  Please recall the axiom that <strong>The obvious
is the enemy of the provable.</strong> The end goal is to prove the effect you want
using only the negation of the loop-condition and the invariant.  You need
to pack all the facts you need into these two expressions.</p>
</div>
<p>The solution is to <strong>strengthen</strong> the invariant, make is so it allows fewer
possibilities after the loop.  In particular, we will want to strengthen the
invariant so the only possible value of <code class="docutils literal notranslate"><span class="pre">i</span></code> is <code class="docutils literal notranslate"><span class="pre">n</span></code>.  We can do this by
adding a condition to the invariant such that values of i &gt; n are not allowed.</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.sireum.logika._</span>
<span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">  fact // axioms</span>
<span class="s2">    def factorial(n: Z): Z</span>
<span class="s2">    fZero. factorial(0) == 1</span>
<span class="s2">    fPos.  ∀x: Z  x &gt; 0 → factorial(x) == factorial(x - 1) * x</span>
<span class="s2">}&quot;&quot;&quot;</span>
<span class="o">//</span> <span class="n">omitting</span>  <span class="n">manual</span> <span class="n">proofs</span> <span class="n">through</span> <span class="n">end</span> <span class="n">of</span> <span class="n">loop</span>
<span class="n">val</span> <span class="n">n</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s2">&quot;Type a nonnegative int: &quot;</span><span class="p">)</span>
<span class="n">assume</span><span class="p">(</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">var</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">var</span> <span class="n">fac</span><span class="p">:</span> <span class="n">Z</span>  <span class="o">=</span> <span class="mi">1</span>

<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
<span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">     invariant factorial(i) = fac</span>
<span class="s2">               i &gt;= 0</span>
<span class="s2">               i &lt;= n</span>
<span class="s2">     modifies i, fac</span>
<span class="s2">}&quot;&quot;&quot;</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">fac</span> <span class="o">=</span> <span class="n">fac</span> <span class="o">*</span> <span class="n">i</span>
<span class="p">}</span>
<span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">     1. ¬ (i &lt; n)            premise  //negation of loop condition</span>
<span class="s2">     2. i &gt;= 0               premise  // invariant</span>
<span class="s2">     3. factorial(i) = fac   premise  // invariant</span>
<span class="s2">     4. i &lt;= n               premise  // invariant</span>
<span class="s2">     5. i &gt;= n               algebra 1</span>
<span class="s2">     6. i = n                algebra 4 5</span>
<span class="s2">}&quot;&quot;&quot;</span>
<span class="k">assert</span><span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The added condition to the invariant at line 18 does the trick.  Updating the
proof sections so it will verify is left for you as an optional exercise.</p>
<p>Here is a summary of the main points just made:</p>
<ul>
<li><p class="first"><strong>A loop is a function that repeatedly calls itself.</strong>
<strong>(It is a</strong> <em>tail-recursive</em> <strong>function.)</strong></p>
</li>
<li><p class="first"><strong>The loop’s invariant states a strategy for accomplishing a goal:</strong></p>
<blockquote>
<div><p>the loop has been running for awhile; what has it accomplished so far?</p>
</div></blockquote>
</li>
<li><p class="first"><strong>The loop’s invariant is exactly the precondition for executing the loop’s
body, and it is exactly the postcondition of what is generated by executing
the loop’s body.</strong></p>
</li>
<li><p class="first"><strong>When the loop terminates, the falsity of the termination test coupled with
the invariant should imply that the loop has achieved its goal.</strong></p>
</li>
</ul>
<p>Even if you forget all about algebra and proofs, whenever you write a loop,
<em>document the loop with its invariant stated in words</em>.
If you are unable to state in words the invariant, then you don’t understand
yourself what your loop is doing.</p>
<div class="section" id="law-for-while-loops-claim-transformation">
<h3>6.1.1. Law for While-Loops (Claim Transformation)<a class="headerlink" href="#law-for-while-loops-claim-transformation" title="Permalink to this headline">¶</a></h3>
<p>Here is the law we use for deducing the properties of a while-loop.
It uses an invariant assertion, <code class="docutils literal notranslate"><span class="pre">I</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;{</span>
<span class="sd">   ...</span>
<span class="sd">   I</span>
<span class="sd">}&quot;&quot;&quot;</span>  <span class="o">//</span> <span class="n">we</span> <span class="n">must</span> <span class="n">prove</span> <span class="n">this</span> <span class="bp">True</span> <span class="n">before</span> <span class="n">the</span> <span class="n">loop</span> <span class="ow">is</span> <span class="n">entered</span>
      <span class="o">//</span> <span class="n">because</span> <span class="n">it</span> <span class="n">must</span> <span class="n">be</span> <span class="n">true</span> <span class="n">before</span> <span class="n">checking</span> <span class="n">B</span>
<span class="k">while</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">       invariant  I</span>
<span class="s2">       modifies  VARLIST   // the variables updated in  C</span>
<span class="s2">  }&quot;&quot;&quot;</span>
  <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">        1. B   premise     // inside loop, so B must be true</span>
<span class="s2">        2. I   premise     // the premises for the loop&#39;s body</span>
<span class="s2">       ...</span>
<span class="s2">  }&quot;&quot;&quot;</span>
  <span class="n">C</span>
  <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">       ...</span>
<span class="s2">       I      // we must prove  I  at the end of the body</span>
<span class="s2">              // because it must be true before re-checking B</span>
<span class="s2">  }&quot;&quot;&quot;</span>
<span class="p">}</span>  <span class="o">//</span> <span class="n">end</span> <span class="n">loop</span>

<span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">      1. ~B    premise</span>
<span class="s2">      2. I     premise</span>
<span class="s2">      ...</span>
<span class="s2">}&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>That is, to deduce the knowledge produced by a while-loop (when we do not know
in advance how many times the loop will iterate), we must deduce an invariant
<code class="docutils literal notranslate"><span class="pre">I</span></code> that:</p>
<ol class="arabic simple">
<li>is proved true before the first time we check the loop condition</li>
<li>is proved true at the end of the loop’s body</li>
</ol>
<p>Then, no matter how many times (0,1,2,…) the loop repeats, we know that <code class="docutils literal notranslate"><span class="pre">I</span></code>
must hold true when the loop stops.
We also know <code class="docutils literal notranslate"><span class="pre">~B</span></code> holds when the loop stops.</p>
<a class="reference internal image-reference" href="../../_images/06-image-20.png"><img alt="../../_images/06-image-20.png" src="../../_images/06-image-20.png" style="width: 946.8px; height: 319.8px;" /></a>
<p>Because the loop will update some variables in its body, we must know these
variables’ names, so that any premises other than the loop invariant that enter
the loop body that mention these variables are cancelled.</p>
<p>A challenge lies in formulating the appropriate invariant that states what the
loop is accomplishing while it repeats.
Invariant discovery is an art form; there cannot exist a mechanical algorithm to
do this.
(This is a key result of computability theory, the study of what problems are
mechanically solvable.)
So, we now study how to discover loop invariants.</p>
</div>
</div>
<div class="section" id="examples-of-invariant-discovery">
<h2>6.2. Examples of Invariant Discovery<a class="headerlink" href="#examples-of-invariant-discovery" title="Permalink to this headline">¶</a></h2>
<p>A key intellectual task in programming is stating a loop’s invariant.
The invariant tells us “what the loop is doing” as it iterates – progresses in
small steps – towards its goal.</p>
<p><strong>IMPORTANT: Saying what “the loop is doing” is different from saying what the
loop “will do” before it starts or what the loop “has done” after it has
finished.</strong>
We must ask the crucial question:</p>
<blockquote>
<div>Say that the loop has been running for a while – what has it accomplished so far?</div></blockquote>
<p>The answer to this question, whether stated in English or algebra, is the
invariant, the loop’s true meaning.</p>
<p>Following are some examples of invariant discovery.</p>
<div class="section" id="multiplication-as-repeated-addition">
<h3>6.2.1. Multiplication as Repeated Addition<a class="headerlink" href="#multiplication-as-repeated-addition" title="Permalink to this headline">¶</a></h3>
<div class="sidebar">
<p class="first sidebar-title">Common Mistake  – Read The Darn Program</p>
<p class="last">It is common for time-pressed students to jump in and start throwing
claims, justifications and rules at the problem without first
critically reading and understanding the program. If you don’t understand
what program’s goal is and how it goes about achieving it , it is hard
to prove it is correct.  This is particular true once you start using
data structures.</p>
</div>
<p>Most people forget that the Greeks and Arabs intended multiplication to be just
repeated addition.
So, what does this program calculate for <code class="docutils literal notranslate"><span class="pre">z</span></code> when it finishes?
What is the loop’s invariant?
(How does the loop reach its goal?)</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.sireum.logika._</span>

<span class="n">val</span> <span class="n">x</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s2">&quot;Type an int: &quot;</span><span class="p">)</span>
<span class="n">val</span> <span class="n">y</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s2">&quot;Type another: &quot;</span><span class="p">)</span>
<span class="n">var</span> <span class="n">z</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">var</span> <span class="n">count</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">         modifies z, count</span>
<span class="s2">    }&quot;&quot;&quot;</span>
    <span class="n">println</span> <span class="p">(</span><span class="s2">&quot;(a) x =&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s2">&quot; y =&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot; count =&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="s2">&quot; z =&quot;</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="n">y</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">}</span>
<span class="n">println</span> <span class="p">(</span><span class="s2">&quot;(b) x =&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s2">&quot; y =&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot; count =&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="s2">&quot; z =&quot;</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">==</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Apparently, this program computes <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code> and saves it in <code class="docutils literal notranslate"><span class="pre">z</span></code>.
To understand, we execute a test case and watch what is printed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Type</span> <span class="n">an</span> <span class="nb">int</span><span class="p">:</span> <span class="mi">3</span>
<span class="n">Type</span> <span class="n">another</span><span class="p">:</span> <span class="mi">4</span>
<span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>  <span class="n">y</span> <span class="o">=</span> <span class="mi">4</span>  <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>  <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>  <span class="n">y</span> <span class="o">=</span> <span class="mi">4</span>  <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>  <span class="n">z</span> <span class="o">=</span> <span class="mi">4</span>
<span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>  <span class="n">y</span> <span class="o">=</span> <span class="mi">4</span>  <span class="n">count</span> <span class="o">=</span> <span class="mi">2</span>  <span class="n">z</span> <span class="o">=</span> <span class="mi">8</span>
<span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>  <span class="n">y</span> <span class="o">=</span> <span class="mi">4</span>  <span class="n">count</span> <span class="o">=</span> <span class="mi">3</span>  <span class="n">z</span> <span class="o">=</span> <span class="mi">12</span>
</pre></div>
</div>
<p>The trace information in each row shows this pattern between the values of the
variables:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">count</span> <span class="o">*</span> <span class="n">y</span>  <span class="o">==</span> <span class="n">z</span>
</pre></div>
</div>
<p>This is what the loop is doing — what it means — <code class="docutils literal notranslate"><span class="pre">z</span></code> holds the value of
<code class="docutils literal notranslate"><span class="pre">count</span> <span class="pre">*</span> <span class="pre">y</span></code>.
Because the loop stops when <code class="docutils literal notranslate"><span class="pre">count</span> <span class="pre">==</span> <span class="pre">x</span></code>, we conclude that <code class="docutils literal notranslate"><span class="pre">z</span> <span class="pre">==</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code>.</p>
<div class="sidebar">
<p class="first sidebar-title">This program has an error</p>
<p class="last">Did you catch it? What happens if x == -3? It should be obvious the loop
will never terminate.   We’ll fix this with an <em>assume()</em> as we move forward.</p>
</div>
<p>We can apply logic laws to prove that <code class="docutils literal notranslate"><span class="pre">count</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">==</span> <span class="pre">z</span> <span class="pre">∧</span> <span class="pre">count</span> <span class="pre">&lt;=</span> <span class="pre">x</span></code> is
invariant for the loop’s body:</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.sireum.logika._</span>

<span class="n">val</span> <span class="n">x</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s2">&quot;Type a positive int: &quot;</span><span class="p">)</span>
<span class="n">assume</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">val</span> <span class="n">y</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s2">&quot;Type any int : &quot;</span><span class="p">)</span>
<span class="n">var</span> <span class="n">z</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">var</span> <span class="n">count</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">    1. z == 0         premise</span>
<span class="s2">    2. count = 0      premise</span>
<span class="s2">    3. x &gt;= 0         premise</span>
<span class="s2">    4. z = count * y  algebra 1 2</span>
<span class="s2">    5. count &lt;= x     algebra 2 3</span>
<span class="s2">}&quot;&quot;&quot;</span>

<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">         invariant z = count * y</span>
<span class="s2">                   count &lt;= x</span>
<span class="s2">         modifies z, count</span>
<span class="s2">    }&quot;&quot;&quot;</span>
    <span class="n">println</span> <span class="p">(</span><span class="s2">&quot;(a) x =&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s2">&quot; y =&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot; count =&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="s2">&quot; z =&quot;</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="n">y</span>
    <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">        1. z = z_old + y        premise</span>
<span class="s2">        2. z_old = count * y    premise</span>
<span class="s2">        3. z = y * (count +1)   algebra 1 2</span>
<span class="s2">    }&quot;&quot;&quot;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">        1. z = y * ( count_old +1)  premise</span>
<span class="s2">        2. count = count_old + 1    premise</span>
<span class="s2">        3. count_old &lt;= x           premise</span>
<span class="s2">        4. count_old != x           premise</span>
<span class="s2">        5. count &lt;= x               algebra 2 3 4</span>
<span class="s2">        6. z = count * y            algebra  1 2</span>
<span class="s2">    }&quot;&quot;&quot;</span>
<span class="p">}</span>
<span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">     1. count &lt;= x     premise</span>
<span class="s2">     2. ¬(count != x)  premise</span>
<span class="s2">     3. count = x      algebra 1 2</span>
<span class="s2">     4. z = count * y  premise</span>
<span class="s2">     5. x * y = z      algebra 3 4</span>
<span class="s2">}&quot;&quot;&quot;</span>
<span class="n">println</span> <span class="p">(</span><span class="s2">&quot;(b) x =&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s2">&quot; y =&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot; count =&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="s2">&quot; z =&quot;</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

<span class="k">assert</span><span class="p">(</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">==</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="division-as-repeated-subtraction">
<h3>6.2.2. Division as Repeated Subtraction<a class="headerlink" href="#division-as-repeated-subtraction" title="Permalink to this headline">¶</a></h3>
<p>Maybe you remember that division was invented to represent repeated subtraction,
e.g., “how many times can you subtract 4 from 20?
(5) — 4 goes into 20 five times — 20 divided by 4 is 5 (with remainder 0)”.</p>
<p>Here is the program that does repeated subtraction like division is meant to do:</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.sireum.logika._</span>

<span class="n">var</span> <span class="n">n</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s2">&quot;Type an nonegative int: &quot;</span><span class="p">)</span>
<span class="n">var</span> <span class="n">d</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s2">&quot;Type a positive int: &quot;</span><span class="p">)</span>
<span class="n">assume</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span>  <span class="o">&amp;</span>  <span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">var</span> <span class="n">q</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">var</span> <span class="n">r</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">n</span>

<span class="k">while</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">         //invariant  ???</span>
<span class="s2">         modifies q, r</span>
<span class="s2">    }&quot;&quot;&quot;</span>
    <span class="n">println</span><span class="p">(</span><span class="s2">&quot;(a) n =&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot; d =&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="s2">&quot; q =&quot;</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s2">&quot; r =&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">d</span>
<span class="p">}</span>
<span class="k">assert</span> <span class="p">(</span> <span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;(b) n =&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot; d =&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="s2">&quot; q =&quot;</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s2">&quot; r =&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot; divided by &quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="s2">&quot; is &quot;</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s2">&quot; with remainder &quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Here is a sample execution with trace information printed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Type</span> <span class="n">an</span> <span class="n">nonegative</span> <span class="nb">int</span><span class="p">:</span> <span class="mi">14</span>
<span class="n">Type</span> <span class="n">a</span> <span class="n">positive</span> <span class="nb">int</span><span class="p">:</span> <span class="mi">3</span>
<span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">14</span>  <span class="n">d</span> <span class="o">=</span> <span class="mi">3</span>  <span class="n">q</span> <span class="o">=</span> <span class="mi">0</span>  <span class="n">r</span> <span class="o">=</span> <span class="mi">14</span>
<span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">14</span>  <span class="n">d</span> <span class="o">=</span> <span class="mi">3</span>  <span class="n">q</span> <span class="o">=</span> <span class="mi">1</span>  <span class="n">r</span> <span class="o">=</span> <span class="mi">11</span>
<span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">14</span>  <span class="n">d</span> <span class="o">=</span> <span class="mi">3</span>  <span class="n">q</span> <span class="o">=</span> <span class="mi">2</span>  <span class="n">r</span> <span class="o">=</span> <span class="mi">8</span>
<span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">14</span>  <span class="n">d</span> <span class="o">=</span> <span class="mi">3</span>  <span class="n">q</span> <span class="o">=</span> <span class="mi">3</span>  <span class="n">r</span> <span class="o">=</span> <span class="mi">5</span>
<span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">14</span>  <span class="n">d</span> <span class="o">=</span> <span class="mi">3</span>  <span class="n">q</span> <span class="o">=</span> <span class="mi">4</span>  <span class="n">r</span> <span class="o">=</span> <span class="mi">2</span>
<span class="mi">14</span> <span class="n">divided</span> <span class="n">by</span> <span class="mi">3</span> <span class="ow">is</span> <span class="mi">4</span> <span class="k">with</span> <span class="n">remainder</span> <span class="mi">2</span>
</pre></div>
</div>
<p>This is a “numbers game”, where we are allowed to use only <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">-</span></code> on
the numbers.
The underlying strategy (invariant) at point <code class="docutils literal notranslate"><span class="pre">(a)</span></code> is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">     invariant  (d * q) + r == n</span>
<span class="s2">     modifies q, r</span>
<span class="s2">}&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>When the loop quits, that is, when there is no longer enough value in <code class="docutils literal notranslate"><span class="pre">r</span></code> to
allow yet one more subtraction of <code class="docutils literal notranslate"><span class="pre">q</span></code>, then the result is exactly the
quotient-remainder that results from dividing <code class="docutils literal notranslate"><span class="pre">n</span></code> by <code class="docutils literal notranslate"><span class="pre">d</span></code>.  The proof is left
as an exercise.</p>
</div>
<div class="section" id="averaging-test-scores">
<h3>6.2.3. Averaging Test Scores<a class="headerlink" href="#averaging-test-scores" title="Permalink to this headline">¶</a></h3>
<p>Even a task like summing scores and computing their average depends on a loop
invariant.  We will approach this using  accumulators for scores and the number
of scores.</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.sireum.logika._</span>
<span class="n">var</span> <span class="n">acc</span> <span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>  <span class="o">//</span> <span class="n">accumulator</span>
<span class="n">var</span> <span class="n">cnt</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>   <span class="o">//</span> <span class="n">number</span> <span class="n">of</span> <span class="n">entered</span> <span class="n">scores</span>
<span class="n">var</span> <span class="n">scr</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>   <span class="o">//</span> <span class="n">value</span> <span class="n">of</span> <span class="n">current</span> <span class="n">entered</span> <span class="n">score</span>
<span class="n">var</span> <span class="n">average</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">        invariant  ???</span>
<span class="s2">        modifies acc, cnt, scr</span>
<span class="s2">        }&quot;&quot;&quot;</span>
    <span class="n">scr</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s2">&quot;Enter score , or -1 to quit&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">scr</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="p">)</span>  <span class="p">{</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">scr</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">average</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">/</span> <span class="n">cnt</span>
            <span class="p">}</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="s2">&quot; scores were entered with an average of &quot;</span><span class="p">,</span> <span class="n">average</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>If we examine the loop at an arbitrary iteration, we see that <code class="docutils literal notranslate"><span class="pre">acc</span></code> holds the
sum of the value of each previously entered valid score, and cnt contains the
number of valid scores entered.</p>
<p>When a valid score is entered, the “new” value of the accumulator should equal
the old value plus the score.   At first blush this seems straight forward</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>acc = acc + scr
l&quot;&quot;&quot;{
     1. acc = acc_old + scr    premise
}&quot;&quot;&quot;
</pre></div>
</div>
<p>But recall that <code class="docutils literal notranslate"><span class="pre">acc_old</span></code> only has a scope of the proof block following the
assignment.  Thus <code class="docutils literal notranslate"><span class="pre">invariant</span> <span class="pre">acc</span> <span class="pre">=</span> <span class="pre">acc_old</span> <span class="pre">+</span> <span class="pre">scr</span></code> will not work.  We will need
extra variables to explicitly keep track of the previous loop-iteration’s values.
Next we note that “if a valid score is entered ” means we have an implication, so
<code class="docutils literal notranslate"><span class="pre">acc</span> <span class="pre">=</span> <span class="pre">prevA</span> <span class="pre">+</span> <span class="pre">scr</span></code> must be conditioned on <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">&gt;=0</span></code>.</p>
<p>The above arguments apply to the count variable as well.  This leads to</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.sireum.logika._</span>
<span class="n">var</span> <span class="n">acc</span> <span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>    <span class="o">//</span> <span class="n">accumulator</span>
<span class="n">var</span> <span class="n">pAcc</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">acc</span>  <span class="o">//</span> <span class="n">the</span> <span class="n">accumulator</span> <span class="n">value</span> <span class="n">of</span> <span class="n">previous</span> <span class="n">loop</span><span class="o">-</span><span class="n">iteration</span>
<span class="n">var</span> <span class="n">cnt</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>     <span class="o">//</span> <span class="n">number</span> <span class="n">of</span> <span class="n">entered</span> <span class="n">scores</span>
<span class="n">var</span> <span class="n">pCnt</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>   <span class="o">//</span> <span class="n">number</span> <span class="n">of</span> <span class="n">previous</span> <span class="n">entered</span> <span class="n">scores</span>
<span class="n">var</span> <span class="n">scr</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>     <span class="o">//</span> <span class="n">value</span> <span class="n">of</span> <span class="n">current</span> <span class="n">entered</span> <span class="n">score</span>
<span class="n">var</span> <span class="n">average</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="p">(</span><span class="n">scr</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">        invariant   acc = pAcc + scr ∨ scr &lt; 0</span>
<span class="s2">                    cnt = pCnt + 1 ∨ scr &lt; 0</span>
<span class="s2">                    pCnt &gt; -1 -&gt; cnt &gt;=0</span>
<span class="s2">        modifies acc, pAcc, cnt, scr, pCnt</span>
<span class="s2">        }&quot;&quot;&quot;</span>
    <span class="n">scr</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s2">&quot;Enter score , or -1 to quit&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">scr</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="p">)</span>  <span class="p">{</span>
        <span class="n">pAcc</span> <span class="o">=</span> <span class="n">acc</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">scr</span>
        <span class="n">pCnt</span> <span class="o">=</span> <span class="n">cnt</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">pCnt</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cnt</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">average</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">/</span> <span class="n">cnt</span>
            <span class="p">}</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="s2">&quot; scores were entered with an average of &quot;</span><span class="p">,</span> <span class="n">average</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The proof is left
as an exercise.</p>
</div>
<div class="section" id="squaring-an-array-s-numbers">
<h3>6.2.4. Squaring an Array’s Numbers<a class="headerlink" href="#squaring-an-array-s-numbers" title="Permalink to this headline">¶</a></h3>
<p>Say that <code class="docutils literal notranslate"><span class="pre">a</span></code> is a sequence of ints, and say we write a loop that squares each of
<code class="docutils literal notranslate"><span class="pre">a</span></code>’s elements and stores the information in sequence <code class="docutils literal notranslate"><span class="pre">b</span></code>:</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.sireum.logika._</span>
<span class="n">var</span> <span class="n">a</span> <span class="p">:</span> <span class="n">ZS</span> <span class="o">=</span> <span class="n">ZS</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">var</span> <span class="n">b</span><span class="p">:</span> <span class="n">ZS</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">clone</span>  <span class="o">//</span> <span class="n">creates</span> <span class="ow">in</span> <span class="n">b</span> <span class="k">as</span> <span class="n">a</span> <span class="n">copy</span> <span class="n">of</span> <span class="n">a</span>
<span class="n">var</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">        invariant  ???</span>
<span class="s2">        modifies i, b</span>
<span class="s2">    }&quot;&quot;&quot;</span>
    <span class="n">b</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">}</span>
<span class="n">println</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>In words, the loop’s invariant is that</p>
<blockquote>
<div>while the loop is running, <code class="docutils literal notranslate"><span class="pre">b</span></code>’s elements, from 0 up to <code class="docutils literal notranslate"><span class="pre">i</span></code>,
are the square of <code class="docutils literal notranslate"><span class="pre">a</span></code>’s, and the rest are unchanged.</div></blockquote>
<p>We express this using the logical operator forall (<code class="docutils literal notranslate"><span class="pre">∀</span></code>).</p>
<p>First we will want to capture the idea that everything before <code class="docutils literal notranslate"><span class="pre">i</span></code> in sequence
<code class="docutils literal notranslate"><span class="pre">b</span></code> has been changed by the loop.  This is expressed by line 1 below.</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span>∀j:Z ( 0&lt;= j ∧ j&lt; i) → (b(j) == (a(j) * a(j)))
∀j:Z ( i&lt;= j ∧ j&lt; b.size) → (b(j) == a(j) )
b.size = a.size
</pre></div>
</td></tr></table></div>
<p>Lines 2 and 3 express what <strong>has not been changed</strong> by the loop.  All indices <code class="docutils literal notranslate"><span class="pre">i</span></code> and
above still equal a, and the sizes of the 2 sequences are the same.</p>
<div class="sidebar">
<p class="first sidebar-title">Sequence ∀ Syntax</p>
<dl class="docutils">
<dt>The statement <code class="docutils literal notranslate"><span class="pre">∀j:Z</span> <span class="pre">(</span> <span class="pre">0&lt;=</span> <span class="pre">j</span> <span class="pre">∧</span> <span class="pre">j&lt;</span> <span class="pre">i)</span> <span class="pre">→</span> <span class="pre">(b(j)</span> <span class="pre">==</span> <span class="pre">(a(j)</span> <span class="pre">*</span> <span class="pre">a(j)))</span></code> is parsed as</dt>
<dd><div class="first last line-block">
<div class="line">For all integer variables j,</div>
<div class="line">IF j &gt;=0 AND j &lt; i</div>
<div class="line">THEN b(j) == (a(j) * a(j))</div>
</div>
</dd>
</dl>
<p>You may ask, what happens when <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">0</span></code>?  In this case the Right Hand Side
of the implication <em>(0&lt;= j ∧ j&lt; i)</em> is false (there are no ints which
satisfy the condition), so the implications is said to be vacuously true.</p>
<p><code class="docutils literal notranslate"><span class="pre">∀j:Z</span> <span class="pre">(</span> <span class="pre">0&lt;=</span> <span class="pre">j</span> <span class="pre">∧</span> <span class="pre">j&lt;</span> <span class="pre">i)</span> <span class="pre">→</span> <span class="pre">(b(j)</span> <span class="pre">==</span> <span class="pre">(a(j)</span> <span class="pre">*</span> <span class="pre">a(j)))</span></code>  can be written
<code class="docutils literal notranslate"><span class="pre">∀j</span> <span class="pre">(</span> <span class="pre">0</span> <span class="pre">..</span> <span class="pre">&lt;</span> <span class="pre">i)</span> <span class="pre">b(j)</span> <span class="pre">==</span> <span class="pre">a(j)</span> <span class="pre">*</span> <span class="pre">a(j)</span></code></p>
<p class="last">This is covered more fully in this chapter’s section on Sequences.</p>
</div>
<p>For all <code class="docutils literal notranslate"><span class="pre">j</span></code> in the range from <code class="docutils literal notranslate"><span class="pre">0</span></code> to
<code class="docutils literal notranslate"><span class="pre">i-1,</span> <span class="pre">b(j)==</span> <span class="pre">a(j)</span> <span class="pre">*</span> <span class="pre">a(j)</span></code>; for all <code class="docutils literal notranslate"><span class="pre">j</span></code> in the range, <code class="docutils literal notranslate"><span class="pre">i</span></code> to
<code class="docutils literal notranslate"><span class="pre">b.size</span> <span class="pre">-</span> <span class="pre">1,</span> <span class="pre">b(j)</span> <span class="pre">==</span> <span class="pre">a</span> <span class="pre">(j)</span></code>; and we ensure the size of the arrays match.
This last statement is key, and we will see why in a moment.</p>
<p>This indicates clearly that sequence <code class="docutils literal notranslate"><span class="pre">b</span></code> is split into toe segments: one whose
elements are the square of <code class="docutils literal notranslate"><span class="pre">a</span></code> and one whose elements are not yet altered.</p>
<p>When the loop quits, it is because <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">b.size</span></code>.
In this situation, the range from <code class="docutils literal notranslate"><span class="pre">i</span></code> to <code class="docutils literal notranslate"><span class="pre">b.size-1</span></code> is empty – all the
array’s elements are squared.</p>
<p>Please note, a working invariant in Logika will require more than this key idea.
Here is a program that with an set of claims for the invariant which produces
the desired behavior. Below we’ll discuss why the “extra” claims are necessary.</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.sireum.logika._</span>
<span class="n">var</span> <span class="n">a</span> <span class="p">:</span> <span class="n">ZS</span> <span class="o">=</span> <span class="n">ZS</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">var</span> <span class="n">b</span><span class="p">:</span> <span class="n">ZS</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">clone</span>
<span class="n">var</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">        invariant  i &gt;= 0</span>
<span class="s2">                   i &lt;= b.size</span>
<span class="s2">                   a.size = b.size</span>
<span class="s2">                   //∀j:Z ( 0&lt;= j ∧ j&lt; i) → (b(j) == (a(j) * a(j)))  equal to line 12</span>
<span class="s2">                   ∀x: (0 ..&lt; i) (b(x) == a(x)* a(x))</span>
<span class="s2">                   ∀x: (i ..&lt; b.size) (b(x) == a(x))</span>
<span class="s2">        modifies i, b</span>
<span class="s2">    }&quot;&quot;&quot;</span>
    <span class="n">b</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">}</span>
<span class="n">println</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Logika will throw an error it we do not prove that all sequence-indexing operations
will be inside the sequent itseld.  Lets cover the potential of index-out-of-bounds
errors in <code class="docutils literal notranslate"><span class="pre">b</span></code> first.  Lines 8 and 9 ensure that at the start of every
loop-iteration, the variable <code class="docutils literal notranslate"><span class="pre">i</span></code> lies inside the indices of <code class="docutils literal notranslate"><span class="pre">b</span></code>.
Specifically, line 16 will not throw an
index-out-of-bounds error for sequence <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<p>However, Logika knows the loop <code class="docutils literal notranslate"><span class="pre">modifies</span> <span class="pre">b</span></code>; so the invariant must account
for the possibility of adding or deleting elements in <code class="docutils literal notranslate"><span class="pre">b</span></code>, i.e changing its size.
The invariant <code class="docutils literal notranslate"><span class="pre">a.size</span> <span class="pre">=</span> <span class="pre">b.size</span></code> on line 10 enforces a rule that <code class="docutils literal notranslate"><span class="pre">b</span></code>
is always the size of <code class="docutils literal notranslate"><span class="pre">a</span></code> at the start of every iteration, so line 16
will never get an index-out-of-bounds error from <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>Line 10 also helps us prove our goal.  Because the loop does not modify <code class="docutils literal notranslate"><span class="pre">a</span></code>, and
<code class="docutils literal notranslate"><span class="pre">b</span></code> is always the same size as <code class="docutils literal notranslate"><span class="pre">a</span></code>,
<code class="docutils literal notranslate"><span class="pre">∀j:Z</span> <span class="pre">(</span> <span class="pre">0&lt;=</span> <span class="pre">j</span> <span class="pre">∧</span> <span class="pre">j&lt;</span> <span class="pre">b.size)</span> <span class="pre">→</span> <span class="pre">(b(j)</span> <span class="pre">==</span> <span class="pre">(a(j)</span> <span class="pre">*</span> <span class="pre">a(j)))</span></code>  is true at the end of
the loop.  If <code class="docutils literal notranslate"><span class="pre">b</span></code> were
allowed to be smaller or bigger than <code class="docutils literal notranslate"><span class="pre">a</span></code>, indices in on sequence, but not the
other, would either throw an error or be ignored.  That is not the behavior we
want.  The proof is left as an exercise.</p>
</div>
</div>
<div class="section" id="logika-solution-modes">
<h2>6.3. Logika Solution Modes<a class="headerlink" href="#logika-solution-modes" title="Permalink to this headline">¶</a></h2>
<p>Up to now, we have been running Logika in “manual mode”</p>
<a class="reference internal image-reference" href="../../_images/06-image-30.png"><img alt="../../_images/06-image-30.png" src="../../_images/06-image-30.png" style="width: 587.6px; height: 342.40000000000003px;" /></a>
<p>We are now reaching the point where additional practice in manual mode may no
longer be a learning activity, and where the proof-blocks after claim transformations
can become dozens of lines long.  Logika offers two advanced modes which we periodically
use to reduce the number and length of required proof-blocks</p>
<div class="section" id="auto-mode">
<h3>6.3.1. Auto-mode<a class="headerlink" href="#auto-mode" title="Permalink to this headline">¶</a></h3>
<a class="reference internal image-reference" href="../../_images/06-image-30.png"><img alt="../../_images/06-image-30.png" src="../../_images/06-image-30.png" style="width: 509.0px; height: 532.0px;" /></a>
<p>This mode enables you to use <code class="docutils literal notranslate"><span class="pre">auto</span></code> in lieu of normal justification statements.
Consider the final proof for Multiplication as Repeated addition.  In manual
mode it required roughly 50 lines to complete.  In Auto mode</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.sireum.logika._</span>

<span class="n">val</span> <span class="n">x</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s2">&quot;Type a positive int: &quot;</span><span class="p">)</span>
<span class="n">assume</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">val</span> <span class="n">y</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s2">&quot;Type any int : &quot;</span><span class="p">)</span>
<span class="n">var</span> <span class="n">z</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">var</span> <span class="n">count</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">         invariant z = count * y</span>
<span class="s2">                   count &lt;= x</span>
<span class="s2">         modifies z, count</span>
<span class="s2">    }&quot;&quot;&quot;</span>
    <span class="n">println</span> <span class="p">(</span><span class="s2">&quot;(a) x =&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s2">&quot; y =&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot; count =&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="s2">&quot; z =&quot;</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="n">y</span>
    <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">        3. z = y * (count +1)   auto</span>
<span class="s2">    }&quot;&quot;&quot;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">        5. count &lt;= x               auto</span>
<span class="s2">        6. z = count * y            auto</span>
<span class="s2">    }&quot;&quot;&quot;</span>
<span class="p">}</span>

<span class="n">println</span> <span class="p">(</span><span class="s2">&quot;(b) x =&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s2">&quot; y =&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot; count =&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="s2">&quot; z =&quot;</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

<span class="k">assert</span><span class="p">(</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">==</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>it requires fewer than 30 lines.  This brevity is achieved with some loss of human
readability.  Why some manual proof lines can be omitted or why some auto proof-blocks
and lines are required may not be intuitively obvious.</p>
</div>
<div class="section" id="symexe-mode">
<h3>6.3.2. Symexe-mode<a class="headerlink" href="#symexe-mode" title="Permalink to this headline">¶</a></h3>
<p>Even more powerful is Symexe mode.  This mode allows you to reason about your
program based on invariants and method  pre-, post- and frame conditions.</p>
<a class="reference internal image-reference" href="../../_images/06-image-40.png"><img alt="../../_images/06-image-40.png" src="../../_images/06-image-40.png" style="width: 324.59999999999997px; height: 330.59999999999997px;" /></a>
<p>It reduces the multiplication problem to roughly 20 lines</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.sireum.logika._</span>

<span class="n">val</span> <span class="n">x</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s2">&quot;Type a positive int: &quot;</span><span class="p">)</span>
<span class="n">assume</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">val</span> <span class="n">y</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s2">&quot;Type any int : &quot;</span><span class="p">)</span>
<span class="n">var</span> <span class="n">z</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">var</span> <span class="n">count</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">         invariant z = count * y</span>
<span class="s2">                   count &lt;= x</span>
<span class="s2">         modifies z, count</span>
<span class="s2">    }&quot;&quot;&quot;</span>
    <span class="n">println</span> <span class="p">(</span><span class="s2">&quot;(a) x =&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s2">&quot; y =&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot; count =&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="s2">&quot; z =&quot;</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="n">y</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="n">println</span> <span class="p">(</span><span class="s2">&quot;(b) x =&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s2">&quot; y =&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot; count =&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="s2">&quot; z =&quot;</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

<span class="k">assert</span><span class="p">(</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">==</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="pitfalls-of-auto-and-symexe">
<h3>6.3.3. Pitfalls of Auto and Symexe<a class="headerlink" href="#pitfalls-of-auto-and-symexe" title="Permalink to this headline">¶</a></h3>
<p>When using these more advanced modes, it is not always obvious why Logika will
not verify.  Sometimes semantic errors in the program keep it from verifying; i.e.
Logika has found a corner or edge case for which the program does not account.
Other times the invariants and conditions do not actually prove the goal.
Inevitably, sometimes it will be both.</p>
<p>In either case an option is to turn off “Auto” and begin typing each proof-block
as if in manual mode (this can be done with Symexe enabled) until you find the
logical or programming error.</p>
</div>
</div>
<div class="section" id="loop-termination-and-total-correctness">
<h2>6.4. Loop Termination and Total Correctness<a class="headerlink" href="#loop-termination-and-total-correctness" title="Permalink to this headline">¶</a></h2>
<p><strong>THIS AREA BEING REFURBISHED FOR YOUR FUTURE ENJOYMENT</strong></p>
<a class="reference internal image-reference" href="../../_images/proofs.png"><img alt="../../_images/proofs.png" src="../../_images/proofs.png" style="width: 740px; height: 224px;" /></a>
<p>This image is licensed under a Creative Commons Attribution-NonCommercial
2.5 License. <a class="reference external" href="https://xkcd.com/1724/">https://xkcd.com/1724/</a></p>
</div>
<div class="section" id="sequences-and-the-use-of-universal-and-existential-assertions">
<h2>6.5. Sequences and the use of Universal and Existential Assertions<a class="headerlink" href="#sequences-and-the-use-of-universal-and-existential-assertions" title="Permalink to this headline">¶</a></h2>
<p>Computer scientists and other programmers often need to express some truths
(propositions) about all elements in a collection or sequence of objects.</p>
<div class="section" id="sequences">
<h3>6.5.1. Sequences<a class="headerlink" href="#sequences" title="Permalink to this headline">¶</a></h3>
<p>In this course, we use only on type of sequence, an ordered list. The general
rules for applying logic to collections can be abstracted from these examples
and applied to different types of collections as needed.</p>
<p>As the name implies, there are no “NULL” or gaps in a sequence. However it is
possible to make an empty sequence <code class="docutils literal notranslate"><span class="pre">(var</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">ZS</span> <span class="pre">=</span> <span class="pre">ZS())</span></code>.</p>
<div class="section" id="types-and-constructors">
<h4>Types and Constructors<a class="headerlink" href="#types-and-constructors" title="Permalink to this headline">¶</a></h4>
<p>In class we deal with two types of lists, lists of integers and lists of booleans.</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="28%" />
<col width="64%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>type</td>
<td>Description</td>
<td>constructor</td>
</tr>
<tr class="row-even"><td>ZS</td>
<td>List of integers</td>
<td>var &lt;var_name&gt;: ZS = ZS (&lt;int, int, …&gt;)</td>
</tr>
<tr class="row-odd"><td>BS</td>
<td>List of booleans</td>
<td>var &lt;var_name&gt;: BS = BS (&lt;bool, bool, ..&gt;)</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The version of Logika we use does not support sequences of sequences.</p>
</div>
<div class="section" id="operations-and-properties">
<h4>Operations and Properties<a class="headerlink" href="#operations-and-properties" title="Permalink to this headline">¶</a></h4>
<p>Given <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">a:</span> <span class="pre">ZS</span> <span class="pre">=</span> <span class="pre">ZS(1,2,3)</span></code>.  <code class="docutils literal notranslate"><span class="pre">a</span></code> = [1,2,3]</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Indexing
a(Z)</td>
<td><p class="first">Sequences are index from 0.
Logika will show an error if you have not proven that
a variable used for indexing does not lie within the
sequence’s range.</p>
<blockquote class="last">
<div>a(0)= 1</div></blockquote>
</td>
</tr>
<tr class="row-even"><td>a.size</td>
<td><p class="first">Sequences have a property providing their number of
elements.</p>
<blockquote class="last">
<div>a.size == 3</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td>Append
:+</td>
<td><p class="first">Sequences can have a value appended to their end.</p>
<blockquote class="last">
<div>a = a:+(4)  // a == [1, 2, 3, 4]</div></blockquote>
</td>
</tr>
<tr class="row-even"><td>Prepend
+:</td>
<td><p class="first">Sequences can have a value prepended to their front.</p>
<blockquote class="last">
<div>a= (0)+:a  // a = [ 0, 1, 2, 3]</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td>Reassignment</td>
<td><p class="first">Sequences instantiated as var can be reassigned.
This appears to be the only way to “shrink” a
sequence.</p>
<blockquote class="last">
<div>a = ZS(5,6)  // a = [ 5, 6]</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><dl class="first last docutils">
<dt>var b: ZS =</dt>
<dd>a.clone</dd>
</dl>
</td>
<td>Creates an exact copy of a for b.  Dirrect assignment
<code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">a</span></code>, is not permitted</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="law-for-sequence-element-assignment-claim-transformation">
<h4>Law for Sequence Element Assignment (Claim Transformation)<a class="headerlink" href="#law-for-sequence-element-assignment-claim-transformation" title="Permalink to this headline">¶</a></h4>
<p>To assign a value to an element <code class="docutils literal notranslate"><span class="pre">i</span></code> of a sequence a is very similar to
the assignment of non-sequence element.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>l&quot;&quot;&quot;{
     prove :
     0 &lt;= i      // must be stated with 0 on LHS
     i &lt; a.size
     P           // other claims involving a(i)
 }&quot;&quot;&quot;

 a(e1) = e2     // expr is type of sequence
 l&quot;&quot;&quot;{
     1. [a_old/a] P                    premise
     2. a.size = a_old.size            premise
     3. a([a_old/a]e1) = [a_old/a]e2   premise
         //  what changed in the sequence
     4. ∀i: (0 .. &lt; a.size)
          (i != [a_old/a]e1) →
               a(i)==a_old(i)          premise
         // what did not change in the sequence
  }&quot;&quot;&quot;
</pre></div>
</div>
<p>in the Logika-proof block immediately following a sequence element assignment,
Logika creates a local “sequence_old” for reference.  A concrete Logika
example (solved in auto mode) of this law is below:</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.sireum.logika._</span>
<span class="n">var</span> <span class="n">s</span><span class="p">:</span> <span class="n">ZS</span> <span class="o">=</span> <span class="n">ZS</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span>
<span class="n">val</span> <span class="n">j</span><span class="p">:</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>                                   <span class="o">//</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">     1. j == s(2)                  premise</span>
<span class="s2">     2. s(2) == 2                  auto</span>
<span class="s2">     3. s.size = 10                premise</span>
<span class="s2">     20. 0 &lt;= j                    algebra 1 2    // 0 &lt;= e1</span>
<span class="s2">     21. j &lt; s.size                algebra 1 3 2  // e1 &lt; a.size</span>
<span class="s2">     22. s(j) &lt; 5                  algebra 1 2    // P</span>
<span class="s2">}&quot;&quot;&quot;</span>

<span class="n">s</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>                                   <span class="o">//</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">l</span><span class="s2">&quot;&quot;&quot;{</span>
<span class="s2">     1. s_old(j) &lt; 5               premise        // P</span>
<span class="s2">     2. s_old(j) = 2               premise        // P</span>
<span class="s2">     3. s.size = s_old.size        premise        // a.size = a_old.size</span>
<span class="s2">     4. s(s_old(2)) = s_old(j) +1  premise        // a([a_old/a]e1)= [a_old/a]e2</span>
<span class="s2">     5. ∀i: (0 .. &lt; s.size)                       // ∀i: (0 .. &lt; a.size)</span>
<span class="s2">            (i != s_old(2)) →                     //    (i != [a_old/a]e1) →</span>
<span class="s2">              s(i)==s_old(i)       premise        //      a(i)==a_old(i)</span>
<span class="s2">}&quot;&quot;&quot;</span>
</pre></div>
</td></tr></table></div>
<p>Note the use of <code class="docutils literal notranslate"><span class="pre">auto</span></code> on line 2.  This eliminates roughly a dozen lines of
claim manipulations.  Proving an element in a sequence, created by <code class="docutils literal notranslate"><span class="pre">ZS(1,2,...)</span></code>
is equal to a value is a laborious process in manual mode.</p>
</div>
</div>
<div class="section" id="use-of-quantifiers">
<h3>6.5.2. Use of Quantifiers<a class="headerlink" href="#use-of-quantifiers" title="Permalink to this headline">¶</a></h3>
<p>The basic form of specifying some claim P(a(x)) holds for every member of the
sequence <code class="docutils literal notranslate"><span class="pre">a</span></code> are</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>∀&lt;var-name&gt;: &lt;var-type&gt; ( lower-bound ∧ upper-bound)  → P(a(x))

∀&lt;var-name&gt;( lower-bound .. upper-bound)  P(a(x))   // shorthand version
</pre></div>
</div>
<p>Where the lower- and upper-bounds are inclusive statements about where to start
and end looking through the sequence.  For example
<code class="docutils literal notranslate"><span class="pre">∀x:</span> <span class="pre">Z</span>&#160; <span class="pre">(</span> <span class="pre">x&gt;=0</span> <span class="pre">∧</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">a.size)</span>&#160; <span class="pre">→</span> <span class="pre">P(a(x))</span></code> would check every member of <code class="docutils literal notranslate"><span class="pre">a</span></code> to
see that P(a(x)) holds where as
<code class="docutils literal notranslate"><span class="pre">∀x:</span> <span class="pre">Z</span>&#160; <span class="pre">(</span> <span class="pre">0</span> <span class="pre">..</span> <span class="pre">&lt;</span> <span class="pre">(a.size/</span> <span class="pre">2))</span>&#160; <span class="pre">P(a(x))</span></code> would check the first half.
Logika will verify <code class="docutils literal notranslate"><span class="pre">∀</span></code>, if and only if P(a(x)) is proven true for every a(x) in the range.</p>
<p>Similarly, the forms for there exist are</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>∃&lt;var-name&gt;: &lt;var-type&gt; ( lower-bound ∧ upper-bound)  → P(a(x))

∃&lt;var-name&gt;( lower-bound .. upper-bound)  P(a(x))
</pre></div>
</div>
<p>Of course in this case at least 1 member of a(x) in the checked range must
satisfy P(a(x)) for Logika to verify.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Best Practice for Sequences</p>
<p class="last">It is best, when modifying a sequence in a loop (or function), to <em>always</em>
specify what changes and what remains the same, including the size of the sequence.
Failure to do so may lead to sound, but incomplete proofs.  If you have no errors,
Logika <em>will</em> verify sound but incompletely specified proofs.</p>
</div>
</div>
</div>
<div class="section" id="summary">
<h2>6.6. Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>The law for while-loops is</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;{ ... I }&quot;&quot;&quot;</span>
<span class="k">while</span> <span class="n">B</span> <span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  { invariant  I</span>
<span class="sd">    modifies   VARLIST   (those variables updated in  C) }</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  { 1. B   premise</span>
<span class="sd">    2. I   premise</span>
<span class="sd">    ... }</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">C</span>
  <span class="sd">&quot;&quot;&quot;{ ... I }&quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. ~B    premise</span>
<span class="sd">  2. I     premise</span>
<span class="sd">  ... }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<hr class="docutils" />
<p align=right><small><em>
This note was adapted from David Schmidt's CIS 301, 2008,
<a href="http://people.cis.ksu.edu/~schmidt/301s14/Lectures/4whileT.html">Chapter 4</a>
course note.
</em></small></p>
<p align=right><small><em>
It was updated in 2018 by Dr John Hatcliff and George Lavezzi <br>
to conform with Logika syntax and more closely match <br>
KSU's CIS 301 course as taught in Spring 2018.
</em></small></p></div>
</div>


    </div>
      
  </div>
</div>

  </body>
</html>