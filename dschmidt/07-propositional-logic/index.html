
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7. Applications of Propositional Logic to Program Proving &#8212; Sireum Logika</title>
    
    <link rel="stylesheet" href="../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootswatch-3.3.4/journal/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sireum.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.3.4/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../_static/logika.ico"/>
    <link rel="top" title="Sireum Logika" href="../../index.html" />
    <link rel="up" title="Logika: Programming Logics" href="../index.html" />
    <link rel="next" title="8. The Predicate-Logic Quantifiers" href="../08-predicate-logic/index.html" />
    <link rel="prev" title="6. Loops, Invariants, Induction" href="../06-loops-invariants-induction/index.html" />
  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          Logika</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../doc/index.html">Documentation</a></li>
                <li><a href="../index.html">Course Notes</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html"> <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#"> <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">7. Applications of Propositional Logic to Program Proving</a><ul>
<li><a class="reference internal" href="#propositions">7.1. Propositions</a></li>
<li><a class="reference internal" href="#inference-rules">7.2. Inference Rules</a></li>
<li><a class="reference internal" href="#and-introduction-and-and-elimination">7.3. And-Introduction and And-Elimination</a><ul>
<li><a class="reference internal" href="#rules">7.3.1. Rules</a></li>
<li><a class="reference internal" href="#examples">7.3.2. Examples</a></li>
<li><a class="reference internal" href="#tactics">7.3.3. Tactics</a></li>
<li><a class="reference internal" href="#the-rules-in-programming-logic">7.3.4. The <code class="docutils literal"><span class="pre">^</span></code>-rules in Programming Logic</a></li>
</ul>
</li>
<li><a class="reference internal" href="#or-introduction-and-or-elimination">7.4. Or-Introduction and Or-Elimination</a><ul>
<li><a class="reference internal" href="#id13">7.4.1. Rules</a></li>
<li><a class="reference internal" href="#id14">7.4.2. Examples</a></li>
<li><a class="reference internal" href="#id15">7.4.3. Tactics</a></li>
<li><a class="reference internal" href="#examples-from-programming-logic">7.4.4. Examples from Programming Logic</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implies-introduction-and-implies-elimination">7.5. Implies-Introduction and Implies-Elimination</a><ul>
<li><a class="reference internal" href="#id20">7.5.1. Rules</a></li>
<li><a class="reference internal" href="#id21">7.5.2. Examples</a></li>
<li><a class="reference internal" href="#id22">7.5.3. Tactics</a></li>
<li><a class="reference internal" href="#id31">7.5.4. Examples from Programming Logic</a></li>
</ul>
</li>
<li><a class="reference internal" href="#negation">7.6. Negation</a><ul>
<li><a class="reference internal" href="#id32">7.6.1. Rules</a></li>
<li><a class="reference internal" href="#id33">7.6.2. Examples</a></li>
<li><a class="reference internal" href="#tactic">7.6.3. Tactic</a></li>
<li><a class="reference internal" href="#id38">7.6.4. Examples from Programming Logic</a></li>
<li><a class="reference internal" href="#negation-introduction">7.6.5. Negation Introduction</a><ul>
<li><a class="reference internal" href="#rule">Rule</a></li>
<li><a class="reference internal" href="#id39">Examples</a></li>
<li><a class="reference internal" href="#id40">Tactic</a></li>
</ul>
</li>
<li><a class="reference internal" href="#proof-by-contradiction">7.6.6. Proof by Contradiction</a><ul>
<li><a class="reference internal" href="#id45">Rule</a></li>
<li><a class="reference internal" href="#id46">Examples</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#important-equivalences">7.7. Important Equivalences</a></li>
<li><a class="reference internal" href="#conjunctive-normal-form-cnf">7.8. Conjunctive Normal Form (CNF)</a><ul>
<li><a class="reference internal" href="#resolution-theorem-proving">7.8.1. Resolution Theorem Proving</a><ul>
<li><a class="reference internal" href="#implementing-cnf-and-resolution-theorem-proving-with-nested-lists">Implementing CNF and Resolution Theorem Proving with Nested Lists</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#models-of-propositional-logic-soundness-and-completeness">7.9. Models of Propositional Logic: Soundness and Completeness</a><ul>
<li><a class="reference internal" href="#truth-tables">7.9.1. Truth Tables</a></li>
<li><a class="reference internal" href="#boolean-lattices">7.9.2. Boolean Lattices</a><ul>
<li><a class="reference internal" href="#conjunction-disjunction-negation">Conjunction, Disjunction, Negation</a></li>
<li><a class="reference internal" href="#implication">Implication</a></li>
<li><a class="reference internal" href="#other-boolean-lattices">Other Boolean Lattices</a></li>
</ul>
</li>
<li><a class="reference internal" href="#data-structures-as-meanings-heyting-lattices">7.9.3. Data Structures as Meanings; Heyting Lattices</a><ul>
<li><a class="reference internal" href="#the-meaning-of-a-proposition-is-a-program">The Meaning of a Proposition is a Program</a></li>
<li><a class="reference internal" href="#heyting-lattices">Heyting Lattices</a></li>
</ul>
</li>
<li><a class="reference internal" href="#possible-worlds-kripke-structures">7.9.4. Possible-Worlds (Kripke) Structures</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary-of-rules-and-tactics">7.10. Summary of Rules and Tactics</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <br/>
<font color="darkgray">
<big><big><b>
Logika: Programming Logics
</b></big></big>
</font>
<br/>
<font color="black">
<big><big><big><big><b>
7. Applications of Propositional Logic to Program Proving
</b></big></big></big></big>
</font><div class="section" id="applications-of-propositional-logic-to-program-proving">
<span id="propositional-logic"></span><h1>7. Applications of Propositional Logic to Program Proving<a class="headerlink" href="#applications-of-propositional-logic-to-program-proving" title="Permalink to this headline">¶</a></h1>
<p>Symbolic logic is the study of assertions (declarative statements) using the
connectives, <em>and</em>, <em>or</em>, <em>not</em>, <em>implies</em>, <em>for all</em>, <em>there exists</em>.
It is a &#8220;starter language&#8221; for stating laws for other areas.
(Example: in algebra, we use symbolic logic to declare, &#8220;for all (every)
integer(s), <code class="docutils literal"><span class="pre">i</span></code>, there exists an integer <code class="docutils literal"><span class="pre">j</span></code> such that <code class="docutils literal"><span class="pre">j</span> <span class="pre">&gt;</span> <span class="pre">i</span></code>.)
Without symbolic logic, modern math, physics, philosophy, computing, and
electronics simply would not exist.</p>
<p>Anyone who works in one of the above-stated technical areas must be competent in
using symbolic logic, and in particular, in performing <em>deduction</em>.</p>
<p>Deduction is the synthesis of new facts &#8212; consequences &#8212; from known facts.
An example: a cases analysis of the assertion that <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">0</span> <span class="pre">v</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> lets us
deduce that <code class="docutils literal"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">0</span></code> and that <code class="docutils literal"><span class="pre">1.0/x</span></code> is a non-erroneous, floating-point
number.
Another example, stated in almost every logic text written in the last 50 years,
goes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">All</span> <span class="n">humans</span> <span class="n">are</span> <span class="n">mortal</span>
 <span class="ow">and</span>
<span class="n">Socrates</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">human</span><span class="o">.</span>

 <span class="n">Therefore</span><span class="p">,</span>
<span class="n">Socrates</span> <span class="ow">is</span> <span class="n">mortal</span><span class="o">.</span>
</pre></div>
</div>
<p>These examples of deduction go beyond what we can do with mere truth tables
alone, and the purpose of this chapter is to provide a set of <em>deduction rules</em>
(also known as <em>inference rules</em>) that you can use to deduce new facts.
The rules will be written so that they can be used in math, physics, computing,
etc.</p>
<p>Up to now, we have used informally symbolic logic and algebra to deduce
knowledge generated by computer programs.
That is, we have used:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">programmming</span><span class="o">-</span><span class="n">logic</span><span class="o">-</span><span class="n">rules</span><span class="o">-</span><span class="k">for</span><span class="o">-</span><span class="n">assign</span><span class="o">-</span><span class="k">if</span><span class="o">-</span><span class="n">functions</span><span class="o">-</span><span class="k">while</span>
  <span class="o">+</span>  <span class="n">algebra</span> <span class="n">laws</span>
       <span class="o">+</span>  <span class="n">a</span> <span class="n">few</span> <span class="n">symbolic</span><span class="o">-</span><span class="n">logic</span> <span class="n">rules</span> <span class="p">(</span><span class="o">^</span><span class="n">i</span><span class="p">,</span> <span class="o">^</span><span class="n">e</span><span class="p">,</span> <span class="n">ve</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>We will develop the symbolic-logic rules in detail.</p>
<div class="section" id="propositions">
<h2>7.1. Propositions<a class="headerlink" href="#propositions" title="Permalink to this headline">¶</a></h2>
<p>Symbolic logic manipulates <em>propositions</em>, which are assertions &#8211; declarative
statements that can be understood as &#8220;true&#8221; (it&#8217;s a fact) or &#8220;false&#8221;
(it&#8217;s wrong).</p>
<p>Examples of propositions from algebra are:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="n">y</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">4</span>
</pre></div>
</div>
<p>The third proposition is always understood as false, whereas the first two might
be true or false, depending on the values of <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code>.</p>
<p>Examples of propositions written in English are:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Socrates</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">human</span><span class="o">.</span>
<span class="n">The</span> <span class="n">sun</span> <span class="ow">is</span> <span class="n">shining</span><span class="o">.</span>
<span class="n">I</span> <span class="n">have</span> <span class="n">a</span> <span class="n">million</span> <span class="n">bucks</span> <span class="ow">in</span> <span class="n">my</span> <span class="n">pocket</span><span class="o">.</span>
</pre></div>
</div>
<p>In English, we can also write sentences that are not propositions:
&#8220;Will it rain tomorrow?&#8221; is a question and not a true-false proposition.
We will always stay within algebra and form true-false propositions from
arithmetic operators like <code class="docutils literal"><span class="pre">+</span></code> and <code class="docutils literal"><span class="pre">/</span></code> and comparison operators like <code class="docutils literal"><span class="pre">==</span></code>
and <code class="docutils literal"><span class="pre">&gt;</span></code>.
The operators,
<code class="docutils literal"><span class="pre">^</span></code> (math: ∧),
<code class="docutils literal"><span class="pre">v</span></code> (math: ∨),
<code class="docutils literal"><span class="pre">--&gt;</span></code> (math: →),
<code class="docutils literal"><span class="pre">~</span></code> (math: ¬),
are called <em>propositional connectives</em> because they connect together
propositions to make new propositions.
(Example: <code class="docutils literal"><span class="pre">(x</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">v</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">0)</span> <span class="pre">--&gt;</span> <span class="pre">~(2x</span> <span class="pre">=</span> <span class="pre">0)</span></code> is a proposition that connects
together <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>, and <code class="docutils literal"><span class="pre">2x</span> <span class="pre">=</span> <span class="pre">0</span></code> with <code class="docutils literal"><span class="pre">~</span></code>, <code class="docutils literal"><span class="pre">v</span></code>, and <code class="docutils literal"><span class="pre">--&gt;</span></code>.)</p>
<p>Later we will study <code class="docutils literal"><span class="pre">FORALL</span></code> (math: ∀) and
<code class="docutils literal"><span class="pre">EXIST</span></code> (math: ∃), which are more delicate than the
propositional connectives and are called <em>quantifiers</em>.</p>
</div>
<div class="section" id="inference-rules">
<h2>7.2. Inference Rules<a class="headerlink" href="#inference-rules" title="Permalink to this headline">¶</a></h2>
<p>The propositional connectives are a kind of data-structure language for building
propositional-data-structures from basic, primitive propositions.
For this reason, we must have laws for constructing the propositions and for
disassembling them.
These laws are called <em>inference rules</em> or <em>deduction rules</em>, and a <em>natural
deduction system</em> is a set of inference rules, such that for each connective,
there is a rule for constructing a proposition with a connective (this is called
an <em>introduction rule</em>) and there is a rule for disassembling a proposition with
the connective (this is called an <em>elimination rule</em>).</p>
<p>For the sections that follow, we will review the introduction and elimination
rules for each propositional connective, give examples of their use in proofs,
describe strategies for applying to rules, and present relevant applications in
programming logic.
When we present the rules, we will use the letters, <code class="docutils literal"><span class="pre">P</span></code>, <code class="docutils literal"><span class="pre">Q</span></code>, <code class="docutils literal"><span class="pre">R</span></code>, ...,
to represent propositions (rather than use <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, etc., as propositions).</p>
<p>The notation,</p>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>ASCII</td>
<td>Math</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">P0,</span> <span class="pre">P1,</span> <span class="pre">...,</span> <span class="pre">Pm</span> <span class="pre">|-</span> <span class="pre">Q</span></code></td>
<td><script type="math/tex">P_0, P_1, \ldots, P_m \vdash Q</script></script></td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<p>(read as, &#8220;<code class="docutils literal"><span class="pre">P0</span></code>, <code class="docutils literal"><span class="pre">P1</span></code>, ..., <code class="docutils literal"><span class="pre">Pm</span></code> <em>entails</em> <code class="docutils literal"><span class="pre">Q</span></code>&#8221;) is a claim &#8212;
a sequent &#8212; that asserts propositions <code class="docutils literal"><span class="pre">Pi</span></code> let us deduce <code class="docutils literal"><span class="pre">Q</span></code>.
The <code class="docutils literal"><span class="pre">Pi</span></code> are called <em>premises</em> and <code class="docutils literal"><span class="pre">Q</span></code> is called the <em>consequent</em>.
For example, <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y,</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">z</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">|-</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">z</span></code>.
It says, &#8220;when premises <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code> and <code class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">z</span> <span class="pre">+</span> <span class="pre">1</span></code> are accepted as facts
(true propositions), then consequent <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> is guaranteed to be a fact as
well.</p>
<p>When we state such a claim &#8212; a sequent &#8212; we must supply a <em>proof</em> to support
the claim.
We use deduction rules to make a proof.</p>
</div>
<div class="section" id="and-introduction-and-and-elimination">
<h2>7.3. And-Introduction and And-Elimination<a class="headerlink" href="#and-introduction-and-and-elimination" title="Permalink to this headline">¶</a></h2>
<p>It is easy to work with the conjunction connective, <code class="docutils literal"><span class="pre">^</span></code>
(math: ∧).
Clearly, <code class="docutils literal"><span class="pre">P,</span> <span class="pre">Q</span> <span class="pre">|-</span> <span class="pre">P</span> <span class="pre">^</span> <span class="pre">Q</span></code>, that is, when both <code class="docutils literal"><span class="pre">P</span></code> and <code class="docutils literal"><span class="pre">Q</span></code> are facts, then
so is the proposition, <code class="docutils literal"><span class="pre">P</span> <span class="pre">^</span> <span class="pre">Q</span></code>.
Dually, we accept that <code class="docutils literal"><span class="pre">P</span> <span class="pre">^</span> <span class="pre">Q</span> <span class="pre">|-</span> <span class="pre">P</span></code> as well as <code class="docutils literal"><span class="pre">P</span> <span class="pre">^</span> <span class="pre">Q</span> <span class="pre">|-</span> <span class="pre">Q</span></code>.
Here are the deduction rules that formalize these intuitions:</p>
<div class="section" id="rules">
<h3>7.3.1. Rules<a class="headerlink" href="#rules" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default"><div class="highlight"><pre><span></span>        <span class="n">P</span>   <span class="n">Q</span>               <span class="n">P</span> <span class="o">^</span> <span class="n">Q</span>            <span class="n">P</span> <span class="o">^</span> <span class="n">Q</span>
<span class="o">^</span><span class="n">i</span> <span class="p">:</span>  <span class="o">---------</span>     <span class="o">^</span><span class="n">e1</span> <span class="p">:</span> <span class="o">--------</span>     <span class="o">^</span><span class="n">e2</span> <span class="p">:</span> <span class="o">--------</span>
        <span class="n">P</span> <span class="o">^</span> <span class="n">Q</span>                 <span class="n">P</span>                 <span class="n">Q</span>
</pre></div>
</div>
<p>It is a tradition to draw the rules as a kind of &#8220;arithmetic sum-up expression&#8221;:
when we have proof of the propositions above the horizontal bar, then we deduce
a proof of the proposition below the bar.</p>
<p>The rules are used to build <em>proofs</em> of new facts from starting facts
(premises).
A proof is written as a sequence of deduction steps.
Here are some examples.</p>
</div>
<div class="section" id="examples">
<h3>7.3.2. Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">|-</span> <span class="n">R</span> <span class="o">^</span> <span class="p">(</span><span class="n">Q</span> <span class="o">^</span> <span class="n">P</span><span class="p">)</span>

<span class="mf">1.</span> <span class="n">P</span>                    <span class="n">premise</span> <span class="p">(</span><span class="n">a</span> <span class="n">starting</span> <span class="n">fact</span><span class="p">)</span>
<span class="mf">2.</span> <span class="n">Q</span>                    <span class="n">premise</span>
<span class="mf">3.</span> <span class="n">R</span>                    <span class="n">premise</span>
<span class="mf">4.</span> <span class="n">Q</span> <span class="o">^</span> <span class="n">P</span>                <span class="o">^</span><span class="n">i</span> <span class="mi">2</span><span class="p">,</span><span class="mi">1</span>
<span class="mf">5.</span> <span class="n">R</span> <span class="o">^</span> <span class="p">(</span><span class="n">Q</span> <span class="o">^</span> <span class="n">P</span><span class="p">)</span>          <span class="o">^</span><span class="n">i</span> <span class="mi">3</span><span class="p">,</span><span class="mi">4</span>
</pre></div>
</div>
<p>Read line 4 like this: &#8220;from the fact stated on line 2 and the fact stated on
line 1, we deduce <code class="docutils literal"><span class="pre">Q</span> <span class="pre">^</span> <span class="pre">P</span></code> by applying the <code class="docutils literal"><span class="pre">^i</span></code> law&#8221;.
Lines 4 and 5 construct new facts from the starting facts (premises) on
lines 1-3.
A proof generates new knowledge from existing knowledge by using deduction
rules.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">^</span> <span class="p">(</span><span class="n">Q</span> <span class="o">^</span> <span class="n">R</span><span class="p">)</span> <span class="o">|-</span>  <span class="n">R</span> <span class="o">^</span> <span class="n">P</span>

<span class="mf">1.</span> <span class="n">P</span> <span class="o">^</span> <span class="p">(</span><span class="n">Q</span> <span class="o">^</span> <span class="n">R</span><span class="p">)</span>        <span class="n">premise</span>
<span class="mf">2.</span> <span class="n">P</span>                  <span class="o">^</span><span class="n">e1</span> <span class="mi">1</span>
<span class="mf">3.</span> <span class="n">Q</span> <span class="o">^</span> <span class="n">R</span>              <span class="o">^</span><span class="n">e2</span> <span class="mi">1</span>
<span class="mf">4.</span> <span class="n">R</span>                  <span class="o">^</span><span class="n">e2</span> <span class="mi">3</span>
<span class="mf">5.</span> <span class="n">R</span> <span class="o">^</span> <span class="n">P</span>              <span class="o">^</span><span class="n">i</span> <span class="mi">4</span><span class="p">,</span><span class="mi">2</span>
</pre></div>
</div>
<p>The two examples seen so far suggest that a proposition like <code class="docutils literal"><span class="pre">R</span> <span class="pre">^</span> <span class="pre">P</span></code> is like
a pair, <code class="docutils literal"><span class="pre">(R,</span> <span class="pre">P)</span></code>, in Python that we can disassemble by indexing.
The <code class="docutils literal"><span class="pre">^e</span></code> rule does the indexing, and the <code class="docutils literal"><span class="pre">^i</span></code>-does the pair-building.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">|-</span> <span class="n">P</span> <span class="o">^</span> <span class="n">P</span>

<span class="mf">1.</span> <span class="n">P</span>            <span class="n">premise</span>
<span class="mf">2.</span> <span class="n">P</span> <span class="o">^</span> <span class="n">P</span>        <span class="o">^</span><span class="n">i</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span>
</pre></div>
</div>
<p>This example shows you can use a premise multiple times in a proof.</p>
<p>It is easy to prove <code class="docutils literal"><span class="pre">P</span> <span class="pre">^</span> <span class="pre">Q</span> <span class="pre">|-</span> <span class="pre">P</span></code> (use <code class="docutils literal"><span class="pre">^e1</span></code>), but we cannot prove
<code class="docutils literal"><span class="pre">P</span> <span class="pre">|-</span> <span class="pre">P</span> <span class="pre">^</span> <span class="pre">Q</span></code>.
This reminds us that deduction rules develop new knowledge, but the knowledge
might be weaker than the starting facts used to deduce the knowledge.
When we have propositions <code class="docutils literal"><span class="pre">P</span></code> and <code class="docutils literal"><span class="pre">Q</span></code> and we prove both
<code class="docutils literal"><span class="pre">P</span> <span class="pre">|-</span> <span class="pre">Q</span></code> and also <code class="docutils literal"><span class="pre">Q</span> <span class="pre">|-</span> <span class="pre">P</span></code>, we write
<code class="docutils literal"><span class="pre">P</span> <span class="pre">-||-</span> <span class="pre">Q</span></code> (math: <script type="math/tex">P \dashv\vdash Q</script></script>)
and say that <code class="docutils literal"><span class="pre">P</span></code> and <code class="docutils literal"><span class="pre">Q</span></code> are equivalent &#8211; they hold the &#8220;same amounts of
knowledge&#8221;.</p>
</div>
<div class="section" id="tactics">
<h3>7.3.3. Tactics<a class="headerlink" href="#tactics" title="Permalink to this headline">¶</a></h3>
<p>A <em>tactic</em> is a useful step towards proving a goal.
The rules for conjunction come with these two tactics, which we rate from
(*) to (<a href="#id1"><span class="problematic" id="id2">**</span></a><a href="#id3"><span class="problematic" id="id4">*</span></a>) based on their utility:</p>
<ul>
<li><p class="first">(<a href="#id5"><span class="problematic" id="id6">**</span></a><a href="#id7"><span class="problematic" id="id8">*</span></a>) <code class="docutils literal"><span class="pre">^i</span></code>-tactic: If your task is to prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">P</span> <span class="pre">^</span> <span class="pre">Q</span></code>, then</p>
<ol class="arabic simple">
<li>prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">P</span></code></li>
<li>prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">Q</span></code></li>
<li>use <code class="docutils literal"><span class="pre">^i</span></code>.</li>
</ol>
<p>The proof you are building looks like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="n">Premises</span>     <span class="n">premise</span>
     <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="n">i</span><span class="o">.</span> <span class="n">P</span>
     <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="n">j</span><span class="o">.</span> <span class="n">Q</span>
<span class="n">k</span><span class="o">.</span>  <span class="n">P</span> <span class="o">^</span> <span class="n">Q</span>   <span class="o">^</span><span class="n">i</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span>
</pre></div>
</div>
</li>
<li><p class="first">(**) <code class="docutils literal"><span class="pre">^e</span></code>-tactic: If your task is to prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">R</span></code> and you have as
a premise or proved fact in your partial proof, <code class="docutils literal"><span class="pre">P</span> <span class="pre">^</span> <span class="pre">Q</span></code>, then apply <code class="docutils literal"><span class="pre">^e</span></code>
to extract <code class="docutils literal"><span class="pre">P</span></code> and <code class="docutils literal"><span class="pre">Q</span></code> to use in the proof:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="n">Premises</span>    <span class="n">premise</span>
   <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
<span class="n">i</span><span class="o">.</span>   <span class="n">P</span> <span class="o">^</span> <span class="n">Q</span>     <span class="n">premise</span>
<span class="n">i</span><span class="o">+</span><span class="mf">1.</span> <span class="n">P</span>         <span class="o">^</span><span class="n">e1</span> <span class="n">i</span>
<span class="n">i</span><span class="o">+</span><span class="mf">2.</span> <span class="n">Q</span>         <span class="o">^</span><span class="n">e2</span> <span class="n">i</span>
    <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="n">j</span><span class="o">.</span>   <span class="n">R</span>
</pre></div>
</div>
</li>
</ul>
<p>Let&#8217;s apply the tactics to one of the previous examples:</p>
<ol class="arabic">
<li><p class="first">Prove <code class="docutils literal"><span class="pre">P</span> <span class="pre">^</span> <span class="pre">(Q</span> <span class="pre">^</span> <span class="pre">R)</span> <span class="pre">|-</span> <span class="pre">R</span> <span class="pre">^</span> <span class="pre">P</span></code>: Use the (<a href="#id9"><span class="problematic" id="id10">**</span></a><a href="#id11"><span class="problematic" id="id12">*</span></a>)-<code class="docutils literal"><span class="pre">^i</span></code> tactic to generate two
subgoals, <code class="docutils literal"><span class="pre">P</span> <span class="pre">^</span> <span class="pre">(Q</span> <span class="pre">^</span> <span class="pre">R)</span> <span class="pre">|-</span> <span class="pre">R</span></code> and also <code class="docutils literal"><span class="pre">P</span> <span class="pre">^</span> <span class="pre">(Q</span> <span class="pre">^</span> <span class="pre">R)</span> <span class="pre">|-</span> <span class="pre">P</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span>   <span class="n">P</span> <span class="o">^</span> <span class="p">(</span><span class="n">Q</span> <span class="o">^</span> <span class="n">R</span><span class="p">)</span>   <span class="n">premises</span>
       <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="n">i</span><span class="o">.</span>   <span class="n">R</span>
       <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="n">k</span><span class="o">.</span>   <span class="n">P</span>
<span class="n">k</span><span class="o">+</span><span class="mf">1.</span> <span class="n">R</span> <span class="o">^</span> <span class="n">P</span>         <span class="o">^</span><span class="n">i</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span>
</pre></div>
</div>
</li>
<li><p class="first">Since the (<strong>*)-tactic can&#8217;t be used on either subgoal, apply the (</strong>)-<code class="docutils literal"><span class="pre">^e</span></code>-tactic to the premise:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span>   <span class="n">P</span> <span class="o">^</span> <span class="p">(</span><span class="n">Q</span> <span class="o">^</span> <span class="n">R</span><span class="p">)</span>   <span class="n">premises</span>
<span class="mf">2.</span>   <span class="n">P</span>             <span class="o">^</span><span class="n">e1</span> <span class="mi">1</span>     <span class="p">(</span><span class="n">succeeded</span> <span class="ow">in</span> <span class="n">proving</span> <span class="n">subgoal</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="mf">3.</span>   <span class="n">Q</span> <span class="o">^</span> <span class="n">R</span>         <span class="o">^</span><span class="n">e2</span> <span class="mi">1</span>
     <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="n">i</span><span class="o">.</span>   <span class="n">R</span>
<span class="n">i</span><span class="o">+</span><span class="mf">1.</span> <span class="n">R</span> <span class="o">^</span> <span class="n">P</span>         <span class="o">^</span><span class="n">i</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span>
</pre></div>
</div>
</li>
<li><p class="first">We can prove the remaining subgoal by applying the <code class="docutils literal"><span class="pre">^e</span></code>-tactic once more:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span>   <span class="n">P</span> <span class="o">^</span> <span class="p">(</span><span class="n">Q</span> <span class="o">^</span> <span class="n">R</span><span class="p">)</span>   <span class="n">premises</span>
<span class="mf">2.</span>   <span class="n">P</span>             <span class="o">^</span><span class="n">e1</span> <span class="mi">1</span>     <span class="p">(</span><span class="n">succeeded</span> <span class="ow">in</span> <span class="n">proving</span> <span class="n">subgoal</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="mf">3.</span>   <span class="n">Q</span> <span class="o">^</span> <span class="n">R</span>         <span class="o">^</span><span class="n">e2</span> <span class="mi">1</span>
<span class="mf">4.</span>   <span class="n">R</span>             <span class="o">^</span><span class="n">e2</span> <span class="mi">3</span>     <span class="p">(</span><span class="n">succeeded</span> <span class="ow">in</span> <span class="n">proving</span> <span class="n">subgoal</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="mf">5.</span>   <span class="n">R</span> <span class="o">^</span> <span class="n">P</span>         <span class="o">^</span><span class="n">i</span> <span class="mi">4</span><span class="p">,</span><span class="mi">2</span>
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="the-rules-in-programming-logic">
<h3>7.3.4. The <code class="docutils literal"><span class="pre">^</span></code>-rules in Programming Logic<a class="headerlink" href="#the-rules-in-programming-logic" title="Permalink to this headline">¶</a></h3>
<p>From time to time, the <code class="docutils literal"><span class="pre">^i</span></code> and <code class="docutils literal"><span class="pre">^e</span></code> rules have appeared in the programming
examples in the previous chapters.
We can now make the connection &#8211; using the facts (premises) generated by the
program&#8217;s commands, we use algebra and the deduction rules to deduce key
information in our program analysis.
Here is a precise treatment of a simple deduction we did in an earlier chapter:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;{ x &gt; y  ^  y == 3 }&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. x = x_old - 1           premise (from the forwards-assignment law)</span>
<span class="sd">  2. x_old &gt; y ^ y = 3       premise (the fact that held before the assignment)</span>
<span class="sd">  3. x_old &gt; y               ^e1 2</span>
<span class="sd">  4. x &gt; y - 1               algebra 1 3</span>
<span class="sd">  5. y == 3                  ^e2 2</span>
<span class="sd">  6.  x &gt; y - 1  ^  y = 3    ^i 4,5</span>
<span class="sd">  (the last line of the proof must not mention any occurrence of  x_old) }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="or-introduction-and-or-elimination">
<h2>7.4. Or-Introduction and Or-Elimination<a class="headerlink" href="#or-introduction-and-or-elimination" title="Permalink to this headline">¶</a></h2>
<p>It is a bit trickier reasoning about disjunction, <code class="docutils literal"><span class="pre">v</span></code> (math: ∨),
because there are multiple meanings of the word in English.
We use the meaning &#8220;one or the other or both&#8221;.
This causes us to accept the entailments, <code class="docutils literal"><span class="pre">P</span> <span class="pre">|-</span> <span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q</span></code> and <code class="docutils literal"><span class="pre">Q</span> <span class="pre">|-</span> <span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q</span></code>
(as well as <code class="docutils literal"><span class="pre">P</span> <span class="pre">|-</span> <span class="pre">P</span> <span class="pre">v</span> <span class="pre">P</span></code>), which give us the two versions of the <code class="docutils literal"><span class="pre">vi</span></code>
deduction rule, seen below.</p>
<p>There must also be a rule for applying a fact of form, <code class="docutils literal"><span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q</span></code>, to deduce new
knowledge.
In real life, we call the rule &#8220;case analysis&#8221;.
For example, say that you have either 4 quarters in your pocket or 10 dimes in
your pocket.
In either case, you can buy a one-dollar coffee.
Why?
You do a case analysis:</p>
<ol class="arabic simple">
<li>In the case you have 4 quarters, that totals a dollar, and you can buy the
coffee;</li>
<li>In the case you have 10 dimes, that totals a dollar, and you can buy the
coffee.</li>
</ol>
<p>So, in both cases, you can buy the coffee.</p>
<p>This pattern of deduction is formalized in the <code class="docutils literal"><span class="pre">ve</span></code>-rule below.</p>
<div class="section" id="id13">
<h3>7.4.1. Rules<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default"><div class="highlight"><pre><span></span>                                                      <span class="o">...</span> <span class="n">P</span> <span class="n">assume</span>   <span class="o">...</span> <span class="n">Q</span> <span class="n">assume</span>
         <span class="n">P</span>                  <span class="n">Q</span>                 <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span>   <span class="o">...</span> <span class="n">R</span>          <span class="o">...</span> <span class="n">R</span>
<span class="n">vi1</span> <span class="p">:</span> <span class="o">--------</span>    <span class="n">vi2</span> <span class="p">:</span>  <span class="o">--------</span>        <span class="n">ve</span><span class="p">:</span> <span class="o">-------------------------------------</span>
       <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span>              <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span>                           <span class="n">R</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">ve</span></code>-rule is the deduction-rule form of case analysis: you assume <code class="docutils literal"><span class="pre">P</span></code>
and do deductions that prove <code class="docutils literal"><span class="pre">R</span></code> and then you assume <code class="docutils literal"><span class="pre">Q</span></code> and do another
sequence of deductions to reprove <code class="docutils literal"><span class="pre">R</span></code>.
Each case is a &#8220;subproof&#8221; that is indented with ellipses.
Once both cases are proved, you conclude <code class="docutils literal"><span class="pre">R</span></code> no matter what.</p>
</div>
<div class="section" id="id14">
<h3>7.4.2. Examples<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">|-</span> <span class="n">Q</span> <span class="n">v</span> <span class="n">P</span>

<span class="mf">1.</span> <span class="n">P</span>              <span class="n">premise</span>
<span class="mf">2.</span> <span class="n">Q</span> <span class="n">v</span> <span class="n">P</span>          <span class="n">vi2</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Perhaps it seems strange to &#8220;weaken&#8221; fact <code class="docutils literal"><span class="pre">P</span></code> by attaching <code class="docutils literal"><span class="pre">Q</span></code> to it.
Yet, we do this all the time.
For example, when we say, &#8220;today is Tuesday, so today is a weekday&#8221;, we have
weakened &#8220;today is Tuesday&#8221; to &#8220;today is Monday or Tuesday or ... or Friday&#8221;.
In math, we might have that <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, so we conclude that <code class="docutils literal"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">0</span></code>, that is,
<code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">|-</span> <span class="pre">(x</span> <span class="pre">&lt;</span> <span class="pre">0)</span> <span class="pre">v</span> <span class="pre">(x</span> <span class="pre">&gt;</span> <span class="pre">0)</span></code>.</p>
<p>What is more interesting is that proposition <code class="docutils literal"><span class="pre">Q</span></code> in the above proof can be any
proposition, and it need not be a true fact (<code class="docutils literal"><span class="pre">P</span></code> is the fact that matters
here).
For example, we can prove <code class="docutils literal"><span class="pre">2</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">|-</span> <span class="pre">(2</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">v</span> <span class="pre">(1</span> <span class="pre">==</span> <span class="pre">0)</span></code>.
This sequent is valid, because it is enough that <code class="docutils literal"><span class="pre">2</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">1</span></code> is a fact;
literally, <code class="docutils literal"><span class="pre">1</span> <span class="pre">==</span> <span class="pre">0</span></code> does not matter.</p>
<p>A similar result goes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">^</span> <span class="n">Q</span> <span class="o">|-</span> <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span>

<span class="mf">1.</span> <span class="n">P</span> <span class="o">^</span> <span class="n">Q</span>        <span class="n">premise</span>
<span class="mf">2.</span> <span class="n">P</span>            <span class="o">^</span><span class="n">e1</span> <span class="mi">1</span>
<span class="mf">3.</span> <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span>        <span class="n">vi1</span> <span class="mi">2</span>
</pre></div>
</div>
<p>For that matter, we reprove this result using <code class="docutils literal"><span class="pre">^e2</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">^</span> <span class="n">Q</span> <span class="o">|-</span> <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span>

<span class="mf">1.</span> <span class="n">P</span> <span class="o">^</span> <span class="n">Q</span>        <span class="n">premise</span>
<span class="mf">2.</span> <span class="n">Q</span>            <span class="o">^</span><span class="n">e2</span> <span class="mi">1</span>
<span class="mf">3.</span> <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span>        <span class="n">vi2</span> <span class="mi">2</span>
</pre></div>
</div>
<p>We cannot prove <code class="docutils literal"><span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q</span> <span class="pre">|-</span> <span class="pre">P</span> <span class="pre">^</span> <span class="pre">Q</span></code>, which clearly shows that the <code class="docutils literal"><span class="pre">vi</span></code> rule
generates &#8220;weaker knowledge&#8221; from its facts.</p>
<p>Here is a proof that uses case analysis &#8212; <code class="docutils literal"><span class="pre">ve</span></code> &#8212; to prove a useful sequent.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="n">v</span> <span class="n">Q</span><span class="p">,</span>  <span class="n">S</span>  <span class="o">|-</span> <span class="p">(</span><span class="n">P</span> <span class="o">^</span> <span class="n">S</span><span class="p">)</span> <span class="n">v</span> <span class="p">(</span><span class="n">Q</span> <span class="o">^</span> <span class="n">S</span><span class="p">)</span>

<span class="mf">1.</span> <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span>                    <span class="n">premise</span>
<span class="mf">2.</span> <span class="n">S</span>                        <span class="n">premise</span>

<span class="o">...</span> <span class="mf">3.</span> <span class="n">P</span>                    <span class="n">assumption</span>   <span class="p">(</span><span class="n">the</span> <span class="n">first</span> <span class="n">case</span> <span class="k">for</span> <span class="n">line</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">...</span> <span class="mf">4.</span> <span class="n">P</span> <span class="o">^</span> <span class="n">S</span>                <span class="o">^</span><span class="n">i</span> <span class="mi">3</span><span class="p">,</span><span class="mi">2</span>
<span class="o">...</span> <span class="mf">5.</span> <span class="p">(</span><span class="n">P</span> <span class="o">^</span> <span class="n">S</span><span class="p">)</span> <span class="n">v</span> <span class="p">(</span><span class="n">Q</span> <span class="o">^</span> <span class="n">S</span><span class="p">)</span>    <span class="n">vi1</span> <span class="mi">4</span>

<span class="o">...</span> <span class="mf">6.</span> <span class="n">Q</span>                    <span class="n">assumption</span>   <span class="p">(</span><span class="n">the</span> <span class="n">second</span> <span class="n">case</span> <span class="k">for</span> <span class="n">line</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">...</span> <span class="mf">7.</span> <span class="n">Q</span> <span class="o">^</span> <span class="n">S</span>                <span class="o">^</span><span class="n">i</span> <span class="mi">6</span><span class="p">,</span><span class="mi">2</span>
<span class="o">...</span> <span class="mf">8.</span> <span class="p">(</span><span class="n">P</span> <span class="o">^</span> <span class="n">S</span><span class="p">)</span> <span class="n">v</span> <span class="p">(</span><span class="n">Q</span> <span class="o">^</span> <span class="n">S</span><span class="p">)</span>    <span class="n">vi2</span> <span class="mi">7</span>

<span class="mf">9.</span>  <span class="p">(</span><span class="n">P</span> <span class="o">^</span> <span class="n">S</span><span class="p">)</span> <span class="n">v</span> <span class="p">(</span><span class="n">Q</span> <span class="o">^</span> <span class="n">S</span><span class="p">)</span>       <span class="n">ve</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="o">-</span><span class="mi">8</span>
</pre></div>
</div>
<p>Each case &#8212; the <code class="docutils literal"><span class="pre">P</span></code> case and the <code class="docutils literal"><span class="pre">Q</span></code> case &#8212; proved the same fact, so
we conclude that the fact holds no matter what.
The indentation with the ellipses are used here to show that we started a
subproof with an additional what-if premise (called an <em>assumption</em>) for a case
analysis.</p>
<p><em>Both subproofs must prove the same fact</em>, and then the <code class="docutils literal"><span class="pre">ve</span></code> rule finishes the
proof.
Here, line 9 states that, starting from the cases asserted on line 1, the proof
that <code class="docutils literal"><span class="pre">P</span></code> proves the goal is stated in lines 3-5 and the proof that <code class="docutils literal"><span class="pre">Q</span></code>
proves the goal is stated in lines 6-8.</p>
<p>The assumption on line 3 (and the one on line 6) acts like a local variable
inside a function &#8211; it can be used only within the function&#8217;s body.
This is because the assumption is a what-if premise that is used only for the
sake of discussion of the case.</p>
<p>It is common to draw boxes around the subproofs, like this, rather than indent
with ellipses:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span>                <span class="n">premise</span>
<span class="mf">2.</span> <span class="n">S</span>                    <span class="n">premise</span>
<span class="o">+--------------------------------------</span>
<span class="o">|</span> <span class="mf">3.</span> <span class="n">P</span>                  <span class="n">assumption</span>
<span class="o">|</span> <span class="mf">4.</span> <span class="n">P</span> <span class="o">^</span> <span class="n">S</span>              <span class="o">^</span><span class="n">i</span> <span class="mi">3</span><span class="p">,</span><span class="mi">2</span>
<span class="o">|</span> <span class="mf">5.</span> <span class="p">(</span><span class="n">P</span> <span class="o">^</span> <span class="n">S</span><span class="p">)</span> <span class="n">v</span> <span class="p">(</span><span class="n">Q</span> <span class="o">^</span> <span class="n">S</span><span class="p">)</span>  <span class="n">vi1</span> <span class="mi">4</span>
<span class="o">+--------------------------------------</span>
<span class="o">+--------------------------------------</span>
<span class="o">|</span> <span class="mf">6.</span> <span class="n">Q</span>                  <span class="n">assumption</span>
<span class="o">|</span> <span class="mf">7.</span> <span class="n">Q</span> <span class="o">^</span> <span class="n">S</span>              <span class="o">^</span><span class="n">i</span> <span class="mi">6</span><span class="p">,</span><span class="mi">2</span>
<span class="o">|</span> <span class="mf">8.</span> <span class="p">(</span><span class="n">P</span> <span class="o">^</span> <span class="n">S</span><span class="p">)</span> <span class="n">v</span> <span class="p">(</span><span class="n">Q</span> <span class="o">^</span> <span class="n">S</span><span class="p">)</span>  <span class="n">vi2</span> <span class="mi">7</span>
<span class="o">+-------------------------------------</span>
<span class="mf">9.</span>  <span class="p">(</span><span class="n">P</span> <span class="o">^</span> <span class="n">S</span><span class="p">)</span> <span class="n">v</span> <span class="p">(</span><span class="n">Q</span> <span class="o">^</span> <span class="n">S</span><span class="p">)</span>   <span class="n">vE</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="o">-</span><span class="mi">8</span>
</pre></div>
</div>
<p>Do as you please.</p>
<p>Finally, here is a simple but vital proof:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="n">v</span> <span class="n">P</span> <span class="o">|-</span> <span class="n">P</span>

<span class="mf">1.</span> <span class="n">P</span> <span class="n">v</span> <span class="n">P</span>         <span class="n">premise</span>

<span class="o">...</span>  <span class="mf">2.</span> <span class="n">P</span>            <span class="n">assumption</span>

<span class="o">...</span>  <span class="mf">3.</span> <span class="n">P</span>            <span class="n">assumption</span>

<span class="mf">4.</span> <span class="n">P</span>             <span class="n">ve</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">-</span><span class="mi">3</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h3>7.4.3. Tactics<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>There is one good tactic, and one not-so-good:</p>
<ul>
<li><p class="first">(<a href="#id16"><span class="problematic" id="id17">**</span></a><a href="#id18"><span class="problematic" id="id19">*</span></a>) <code class="docutils literal"><span class="pre">ve</span></code>-tactic: To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">R</span></code>, if <code class="docutils literal"><span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q</span></code> appears as a
premise or proved fact in the partial proof, then</p>
<ol class="arabic simple">
<li>prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">P</span> <span class="pre">|-</span> <span class="pre">R</span></code></li>
<li>prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">Q</span> <span class="pre">|-</span> <span class="pre">R</span></code></li>
<li>use the <code class="docutils literal"><span class="pre">ve</span></code>-rule to prove <code class="docutils literal"><span class="pre">R</span></code>.</li>
</ol>
<p>The proof is structured like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span>  <span class="n">Premises</span>     <span class="n">premise</span>
      <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
<span class="n">i</span><span class="o">.</span>  <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span>

<span class="o">...</span> <span class="n">j</span><span class="o">.</span> <span class="n">P</span>         <span class="n">assumption</span>
        <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="o">...</span> <span class="n">k</span><span class="o">.</span> <span class="n">R</span>

<span class="o">...</span> <span class="n">l</span><span class="o">.</span> <span class="n">Q</span>         <span class="n">assumption</span>
        <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="o">...</span> <span class="n">m</span><span class="o">.</span> <span class="n">R</span>

<span class="n">n</span><span class="o">.</span>     <span class="n">R</span>         <span class="n">ve</span> <span class="mi">2</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="o">-</span><span class="n">m</span>
</pre></div>
</div>
</li>
<li><p class="first">(*) <code class="docutils literal"><span class="pre">vi</span></code>-tactic: To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q</span></code>, pick either of <code class="docutils literal"><span class="pre">P</span></code> or
<code class="docutils literal"><span class="pre">Q</span></code>, and try to prove it.
Finish with <code class="docutils literal"><span class="pre">vi</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span>  <span class="n">Premises</span>     <span class="n">premise</span>
     <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="n">i</span><span class="o">.</span>  <span class="n">P</span>
<span class="n">j</span><span class="o">.</span>  <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span>        <span class="n">vi1</span> <span class="n">i</span>
</pre></div>
</div>
</li>
</ul>
<p>If you examine the previous proof example, you see that the proof was
constructed by applying the <code class="docutils literal"><span class="pre">ve</span></code> tactic, which made possible the use of the
<code class="docutils literal"><span class="pre">^i</span></code> tactic upon the two subgoals.
The <code class="docutils literal"><span class="pre">vi</span></code> tactic is used only when it is clear that it will yield progress
towards the goal.</p>
</div>
<div class="section" id="examples-from-programming-logic">
<h3>7.4.4. Examples from Programming Logic<a class="headerlink" href="#examples-from-programming-logic" title="Permalink to this headline">¶</a></h3>
<p>This function can accept two varieties of argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">reciprocal</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    { pre    (n &lt; 0) v (n &gt; 0)</span>
<span class="sd">      post   answer == 1.0 /n</span>
<span class="sd">      return answer }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">answer</span>

<span class="c1"># We show that the function&#39;s argument satisfies the precondition:</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. x == 5                  premise</span>
<span class="sd">  2. x &gt; 0                   algebra 1</span>
<span class="sd">  3. (x &gt; 0) v (x &lt; 0)       vi1 2 }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">reciprocal</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. y == 1.0/x              premise (by function-call law)</span>
<span class="sd">  2. x == 5                  premise (from above)</span>
<span class="sd">  3. x == 5  ^  y == 1.0/x   ^i 2,3</span>
<span class="sd">}</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Here is a little programming trick:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="mi">1</span>
<span class="k">else</span> <span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
</pre></div>
</div>
<p>At the end <code class="docutils literal"><span class="pre">x</span></code> is always nonnegative, because the if-command sets <code class="docutils literal"><span class="pre">y</span></code> to the
opposite parity (sign) as <code class="docutils literal"><span class="pre">x</span></code>.
We can use <code class="docutils literal"><span class="pre">ve</span></code> to prove this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="mi">1</span>
<span class="k">else</span> <span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;{ 1. (x &lt; 0 ^ y == -1)  v  (x &gt;=0 ^ y == 1)         premise (if-law) }&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. x == x_old * y                                    premise</span>
<span class="sd">  2. (x_old &lt; 0 ^ y == -1)  v  (x_old &gt;= 0 ^ y == 1)   premise</span>

<span class="sd">  ... 3. x_old &lt; 0 ^ y == -1                           assumption</span>
<span class="sd">  ... 4. x_old &lt; 0                                     ^e1 3</span>
<span class="sd">  ... 5. y == -1                                       ^e2 3</span>
<span class="sd">  ... 6. x_old * y &gt; 0                                 algebra 4 5</span>
<span class="sd">  ... 7. x &gt; 0                                         subst 1 6</span>
<span class="sd">  ... 8. x &gt;= 0                                        algebra 7</span>

<span class="sd">  ... 9. x_old &gt;=0 ^ y == 1                            assumption</span>
<span class="sd">  ... 10. x_old &gt;= 0                                   ^e1 9</span>
<span class="sd">  ... 11. y == 1                                       ^e2 10</span>
<span class="sd">  ... 12. xold * y &gt;= 0                                algebra 10  11</span>
<span class="sd">  ... 13. x &gt;= 0                                       subst 1 12</span>

<span class="sd">  14. x &gt;= 0                                           ve 2,3-8,9-13 }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>The proof matches exactly the informal reasoning why <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code> makes <code class="docutils literal"><span class="pre">x</span></code>
nonnegative at the end.</p>
</div>
</div>
<div class="section" id="implies-introduction-and-implies-elimination">
<h2>7.5. Implies-Introduction and Implies-Elimination<a class="headerlink" href="#implies-introduction-and-implies-elimination" title="Permalink to this headline">¶</a></h2>
<p>Remember that <code class="docutils literal"><span class="pre">--&gt;</span></code> (math: →) is a kind of &#8220;logical if-then&#8221;.
The word, &#8220;implies&#8221; has several shadings of meaning in spoken English, and there
are multiple meanings of the word in logic.
Here, we understand <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code> to assert that <code class="docutils literal"><span class="pre">P</span></code> holds knowledge sufficient
to deduce <code class="docutils literal"><span class="pre">Q</span></code> &#8211; so, whenever <code class="docutils literal"><span class="pre">P</span></code> is proved to be a fact, then <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code>
enables <code class="docutils literal"><span class="pre">Q</span></code> to be proved a fact, too.</p>
<p>With this understanding, it is easy to accept that <code class="docutils literal"><span class="pre">P</span></code>, <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span> <span class="pre">|-</span> <span class="pre">Q</span></code>;
this yields the <code class="docutils literal"><span class="pre">--&gt;e</span></code> rule.</p>
<p>But there must also be a rule for building propositions of the form,
<code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code>.
Say that a family of propositions, <code class="docutils literal"><span class="pre">P</span></code>, <code class="docutils literal"><span class="pre">R</span></code>, <code class="docutils literal"><span class="pre">S</span></code>, <code class="docutils literal"><span class="pre">T</span></code>, ... are enough to
prove proposition, <code class="docutils literal"><span class="pre">Q</span></code>.
Say we know that <code class="docutils literal"><span class="pre">R</span></code>, <code class="docutils literal"><span class="pre">S</span></code>, <code class="docutils literal"><span class="pre">T</span></code>, ... are facts.
Thus, if we only knew that <code class="docutils literal"><span class="pre">P</span></code> was a fact, too, then we would have <code class="docutils literal"><span class="pre">Q</span></code> as a
fact.
In this sense, <code class="docutils literal"><span class="pre">R</span></code>, <code class="docutils literal"><span class="pre">S</span></code>, <code class="docutils literal"><span class="pre">T</span></code>, ... <em>are enough to prove that</em> <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code>
<em>is a fact</em>.</p>
<p>Stated more precisely, the situation where <code class="docutils literal"><span class="pre">P,</span> <span class="pre">R,</span> <span class="pre">S,</span> <span class="pre">T,</span> <span class="pre">...</span> <span class="pre">|-</span> <span class="pre">Q</span></code> lets us
conclude that <code class="docutils literal"><span class="pre">R,</span> <span class="pre">S,</span> <span class="pre">T,</span> <span class="pre">...</span> <span class="pre">|-</span> <span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code>.
These two ideas, which go hand in hand, are formalized below.</p>
<div class="section" id="id20">
<h3>7.5.1. Rules<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default"><div class="highlight"><pre><span></span>        <span class="o">...</span> <span class="n">P</span> <span class="n">assume</span>
        <span class="o">...</span> <span class="n">Q</span>                     <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">Q</span>   <span class="n">P</span>
<span class="o">--&gt;</span><span class="n">i</span> <span class="p">:</span> <span class="o">-----------</span>       <span class="o">--&gt;</span><span class="n">e</span> <span class="p">:</span>  <span class="o">-----------------</span>
        <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">Q</span>                        <span class="n">Q</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">--&gt;i</span></code>-rule is a case analysis &#8211; it says, consider the case when <code class="docutils literal"><span class="pre">P</span></code> is
a fact.
(We don&#8217;t know this for certain; it is a case/possibility we want to discuss.)
If assuming <code class="docutils literal"><span class="pre">P</span></code> (plus using other facts we already have) leads to a proof of
<code class="docutils literal"><span class="pre">Q</span></code>, then we conclude that <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code> is a fact.</p>
</div>
<div class="section" id="id21">
<h3>7.5.2. Examples<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<p>Here are two simple uses of <code class="docutils literal"><span class="pre">--&gt;e</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">P</span> <span class="o">^</span> <span class="n">Q</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">R</span><span class="p">,</span>  <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">Q</span><span class="p">,</span>  <span class="n">P</span>  <span class="o">|-</span>  <span class="n">R</span>

<span class="mf">1.</span> <span class="p">(</span><span class="n">P</span> <span class="o">^</span> <span class="n">Q</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">R</span>           <span class="n">premise</span>
<span class="mf">2.</span> <span class="n">P</span>                       <span class="n">premise</span>
<span class="mf">3.</span> <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">Q</span>                 <span class="n">premise</span>
<span class="mf">4.</span> <span class="n">Q</span>                       <span class="o">--&gt;</span><span class="n">e</span> <span class="mi">3</span><span class="p">,</span><span class="mi">2</span>
<span class="mf">5.</span> <span class="n">P</span> <span class="o">^</span> <span class="n">Q</span>                   <span class="o">^</span><span class="n">i</span> <span class="mi">2</span><span class="p">,</span><span class="mi">4</span>
<span class="mf">6.</span> <span class="n">R</span>                       <span class="o">--&gt;</span><span class="n">e</span> <span class="mi">1</span><span class="p">,</span><span class="mi">5</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">P</span> <span class="n">v</span> <span class="n">Q</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">R</span><span class="p">,</span>  <span class="n">Q</span> <span class="o">|-</span>  <span class="n">R</span>

<span class="mf">1.</span> <span class="p">(</span><span class="n">P</span> <span class="n">v</span> <span class="n">Q</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">R</span>           <span class="n">premise</span>
<span class="mf">2.</span> <span class="n">Q</span>                       <span class="n">premise</span>
<span class="mf">3.</span> <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span>                   <span class="n">vi2</span> <span class="mi">2</span>
<span class="mf">4.</span> <span class="n">R</span>                       <span class="o">--&gt;</span><span class="n">e</span> <span class="mi">1</span><span class="p">,</span><span class="mi">3</span>
</pre></div>
</div>
<p>Here is an example that uses <code class="docutils literal"><span class="pre">--&gt;i</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span><span class="p">,</span>  <span class="p">(</span><span class="n">Q</span> <span class="o">^</span> <span class="n">P</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">R</span>  <span class="o">|-</span>  <span class="n">Q</span> <span class="o">--&gt;</span> <span class="n">R</span>

<span class="mf">1.</span> <span class="n">P</span>                       <span class="n">premise</span>
<span class="mf">2.</span> <span class="p">(</span><span class="n">Q</span> <span class="o">^</span> <span class="n">P</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">R</span>           <span class="n">premise</span>

<span class="o">...</span> <span class="mf">3.</span> <span class="n">Q</span>                   <span class="n">assumption</span>
<span class="o">...</span> <span class="mf">4.</span> <span class="n">Q</span> <span class="o">^</span> <span class="n">P</span>               <span class="o">^</span><span class="n">i</span> <span class="mi">3</span><span class="p">,</span><span class="mi">1</span>
<span class="o">...</span> <span class="mf">5.</span> <span class="n">R</span>                   <span class="o">--&gt;</span><span class="n">e</span> <span class="mi">2</span><span class="p">,</span><span class="mi">4</span>

<span class="mf">6.</span> <span class="n">Q</span> <span class="o">--&gt;</span> <span class="n">R</span>                 <span class="o">--&gt;</span><span class="n">i</span> <span class="mi">3</span><span class="o">-</span><span class="mi">5</span>
</pre></div>
</div>
<p>The proof includes the case that, when <code class="docutils literal"><span class="pre">Q</span></code> is assumed a fact then <code class="docutils literal"><span class="pre">R</span></code> would
follow as a fact, too.
The subproof lets us conclude that <code class="docutils literal"><span class="pre">Q</span> <span class="pre">--&gt;</span> <span class="pre">R</span></code> is a fact.</p>
<p>Here, two if-then facts entail a third one:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">--&gt;</span> <span class="n">Q</span><span class="p">,</span>  <span class="n">Q</span> <span class="o">--&gt;</span> <span class="n">R</span>  <span class="o">|-</span> <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">R</span>

<span class="mf">1.</span> <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">Q</span>     <span class="n">premise</span>
<span class="mf">2.</span> <span class="n">Q</span> <span class="o">--&gt;</span> <span class="n">R</span>     <span class="n">premise</span>

<span class="o">...</span> <span class="mf">3.</span>  <span class="n">P</span>      <span class="n">assumption</span>
<span class="o">...</span> <span class="mf">4.</span>  <span class="n">Q</span>      <span class="o">--&gt;</span><span class="n">e</span> <span class="mi">1</span><span class="p">,</span><span class="mi">3</span>
<span class="o">...</span> <span class="mf">5.</span>  <span class="n">R</span>      <span class="o">--&gt;</span><span class="n">e</span> <span class="mi">2</span><span class="p">,</span><span class="mi">4</span>

<span class="mf">6.</span> <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">R</span>     <span class="o">--&gt;</span><span class="n">i</span> <span class="mi">3</span><span class="o">-</span><span class="mi">5</span>
</pre></div>
</div>
<p>Notice how we assumed <code class="docutils literal"><span class="pre">P</span></code> to move the proof forwards to a proof of <code class="docutils literal"><span class="pre">R</span></code>.
We employ a similar tactic in this example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">--&gt;</span> <span class="p">(</span><span class="n">Q</span> <span class="o">--&gt;</span> <span class="n">R</span><span class="p">)</span> <span class="o">|-</span>  <span class="p">(</span><span class="n">Q</span> <span class="o">^</span> <span class="n">P</span><span class="p">)</span> <span class="o">--&gt;</span>  <span class="n">R</span>

<span class="mf">1.</span> <span class="n">P</span> <span class="o">--&gt;</span> <span class="p">(</span><span class="n">Q</span> <span class="o">--&gt;</span> <span class="n">R</span><span class="p">)</span>   <span class="n">premise</span>

<span class="o">...</span> <span class="mf">2.</span> <span class="n">Q</span> <span class="o">^</span> <span class="n">P</span>         <span class="n">assumption</span>
<span class="o">...</span> <span class="mf">3.</span> <span class="n">P</span>             <span class="o">^</span><span class="n">e2</span> <span class="mi">2</span>
<span class="o">...</span> <span class="mf">4.</span> <span class="n">Q</span> <span class="o">--&gt;</span> <span class="n">R</span>       <span class="o">--&gt;</span><span class="n">e</span> <span class="mi">1</span><span class="p">,</span><span class="mi">3</span>
<span class="o">...</span> <span class="mf">5.</span> <span class="n">Q</span>             <span class="o">^</span><span class="n">e1</span> <span class="mi">2</span>
<span class="o">...</span> <span class="mf">6.</span> <span class="n">R</span>             <span class="o">--&gt;</span><span class="n">e</span> <span class="mi">4</span><span class="p">,</span><span class="mi">6</span>

<span class="mf">7.</span> <span class="p">(</span><span class="n">Q</span> <span class="o">^</span> <span class="n">P</span><span class="p">)</span> <span class="o">--&gt;</span>  <span class="n">R</span>    <span class="o">--&gt;</span><span class="n">i</span> <span class="mi">2</span><span class="o">-</span><span class="mi">6</span>
</pre></div>
</div>
<p>It is possible to nest cases-analyses, as in this cruical example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">--&gt;</span> <span class="n">R</span><span class="p">,</span>  <span class="n">Q</span> <span class="o">--&gt;</span> <span class="n">R</span>  <span class="o">|-</span>  <span class="p">(</span><span class="n">P</span> <span class="n">v</span> <span class="n">Q</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">R</span>

<span class="mf">1.</span> <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">R</span>            <span class="n">premise</span>
<span class="mf">2.</span> <span class="n">Q</span> <span class="o">--&gt;</span> <span class="n">R</span>            <span class="n">premise</span>
<span class="o">...</span> <span class="mf">3.</span> <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span>          <span class="n">assumption</span>

<span class="o">...</span> <span class="o">...</span> <span class="mf">4.</span> <span class="n">P</span>          <span class="n">assumption</span>
<span class="o">...</span> <span class="o">...</span> <span class="mf">5.</span> <span class="n">R</span>          <span class="o">--&gt;</span><span class="n">e</span> <span class="mi">1</span><span class="p">,</span><span class="mi">4</span>

<span class="o">...</span> <span class="o">...</span> <span class="mf">6.</span> <span class="n">Q</span>          <span class="n">assumption</span>
<span class="o">...</span> <span class="o">...</span> <span class="mf">7.</span> <span class="n">R</span>          <span class="o">--&gt;</span><span class="n">e</span> <span class="mi">2</span><span class="p">,</span><span class="mi">6</span>

<span class="o">...</span> <span class="mf">8.</span> <span class="n">R</span>              <span class="n">ve</span> <span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="o">-</span><span class="mi">7</span>
<span class="mf">9.</span> <span class="p">(</span><span class="n">P</span> <span class="n">v</span> <span class="n">Q</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">R</span>      <span class="o">--&gt;</span><span class="n">i</span> <span class="mi">3</span><span class="o">-</span><span class="mi">8</span>
</pre></div>
</div>
<p>Here, the &#8220;or reasoning&#8221; is nested inside the &#8220;implies reasoning&#8221;.
This example shows how mastery of basic deduction rules allows one to reason far
more precisely than ordinary people do in real life.</p>
</div>
<div class="section" id="id22">
<h3>7.5.3. Tactics<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h3>
<p>Implication comes with two good tactics:</p>
<ul>
<li><p class="first">(<a href="#id23"><span class="problematic" id="id24">**</span></a><a href="#id25"><span class="problematic" id="id26">*</span></a>) <code class="docutils literal"><span class="pre">--&gt;i</span></code>-tactic: To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code>,</p>
<ol class="arabic simple">
<li>assume <code class="docutils literal"><span class="pre">P</span></code></li>
<li>prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">P</span> <span class="pre">|-</span> <span class="pre">Q</span></code></li>
<li>use <code class="docutils literal"><span class="pre">--&gt;i</span></code>.</li>
</ol>
<p>The proof structure looks like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span>  <span class="n">Premises</span>         <span class="n">premise</span>
<span class="o">...</span> <span class="n">i</span><span class="o">.</span>  <span class="n">P</span>            <span class="n">assumption</span>
         <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="o">...</span> <span class="n">j</span><span class="o">.</span>  <span class="n">Q</span>
<span class="n">k</span><span class="o">.</span>  <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">Q</span>          <span class="o">--&gt;</span><span class="n">i</span> <span class="n">i</span><span class="o">-</span><span class="n">j</span>
</pre></div>
</div>
</li>
<li><p class="first">(*) <code class="docutils literal"><span class="pre">--&gt;e</span></code>-tactic: To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">R</span></code>, if <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code> appears as a
premise or a proved fact in the partial proof, then</p>
<ol class="arabic simple">
<li>prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">P</span></code></li>
<li>use <code class="docutils literal"><span class="pre">--&gt;e</span></code> to deduce <code class="docutils literal"><span class="pre">Q</span></code></li>
<li>prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">P,</span> <span class="pre">Q</span> <span class="pre">|-</span> <span class="pre">R</span></code>.</li>
</ol>
<p>Here, the tactic is to generate new knowledge that will bring us closer to the
goal, <code class="docutils literal"><span class="pre">R</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span>  <span class="n">Premises</span>      <span class="n">premise</span>
       <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
<span class="n">i</span><span class="o">.</span>  <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">Q</span>
        <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="n">j</span><span class="o">.</span>  <span class="n">P</span>
<span class="n">k</span><span class="o">.</span>  <span class="n">Q</span>             <span class="o">--&gt;</span><span class="n">e</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span>
        <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="n">k</span><span class="o">.</span>  <span class="n">R</span>
</pre></div>
</div>
</li>
</ul>
<p>In an earlier proof example, you see an immediate use of the (<a href="#id27"><span class="problematic" id="id28">**</span></a><a href="#id29"><span class="problematic" id="id30">*</span></a>)-<code class="docutils literal"><span class="pre">--&gt;i</span></code>
tactic to the new subgoal:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">--&gt;</span> <span class="p">(</span><span class="n">Q</span> <span class="o">--&gt;</span> <span class="n">R</span><span class="p">),</span> <span class="n">Q</span> <span class="o">^</span> <span class="n">P</span> <span class="o">|-</span> <span class="n">R</span>
</pre></div>
</div>
<p>An easy application of the (**)-<code class="docutils literal"><span class="pre">^i</span></code> tactic generates this simpler subgoal:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">--&gt;</span> <span class="p">(</span><span class="n">Q</span> <span class="o">--&gt;</span> <span class="n">R</span><span class="p">),</span> <span class="n">Q</span><span class="p">,</span> <span class="n">P</span> <span class="o">|-</span> <span class="n">R</span>
</pre></div>
</div>
<p>and we quickly finish the proof by applying the (*)-<code class="docutils literal"><span class="pre">--&gt;e</span></code> tactic twice to
deduce <code class="docutils literal"><span class="pre">R</span></code>.</p>
</div>
<div class="section" id="id31">
<h3>7.5.4. Examples from Programming Logic<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h3>
<p>Recall the loop for finding a letter in a string:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>      <span class="c1"># the position of the  letter  in  s  we are examining</span>
<span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># did we find  c  in  s  yet?</span>

<span class="k">while</span> <span class="n">index</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="ow">and</span>  <span class="ow">not</span> <span class="n">found</span> <span class="p">:</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ invariant  (found --&gt; s[index] = c)  ^</span>
<span class="sd">              (~found --&gt; FORALL 0 &lt;= i &lt; index, s[i] != c)</span>
<span class="sd">  modifies  found, index }</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">if</span>  <span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">c</span> <span class="p">:</span>
        <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">else</span> <span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
<span class="c1"># after we quit the loop:</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. ~(index != len(s)       premise</span>
<span class="sd">  2. invariant               premise</span>
<span class="sd">  3. index == len(s)         algebra 1 }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>After the loop finishes, we use <code class="docutils literal"><span class="pre">--&gt;e</span></code> with the invariant to ensure that we
print the correct answer:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;{ invariant }&quot;&quot;&quot;</span>
<span class="k">if</span> <span class="n">found</span> <span class="p">:</span>
   <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   { 1. found                                          premise</span>
<span class="sd">     2. invariant                                      premise</span>
<span class="sd">     3. found --&gt; (s[index] == c)                      ^e1 2</span>
<span class="sd">     4. s[index] == c                                  --&gt;e 3,1 }</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="k">print</span> <span class="s2">&quot;found&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="s2">&quot;at&quot;</span><span class="p">,</span> <span class="n">index</span>
<span class="k">else</span> <span class="p">:</span>
   <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   { 1. ~found                                         premise (from if-law)</span>
<span class="sd">     2. invariant                                      premise</span>
<span class="sd">     3. index == len(s)                                premise</span>
<span class="sd">     4. ~found --&gt; FORALL 0 &lt;= i &lt; index: s[i] != c    ^e2 2</span>
<span class="sd">     5. FORALL 0 &lt;= i &lt; index, s[i] != c               --&gt;e 3,1</span>
<span class="sd">     6. FORALL 0 &lt;= i &lt; len(s), s[i] != c              subst 3,5 }</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="k">print</span> <span class="n">c</span><span class="p">,</span> <span class="s2">&quot;not found&quot;</span>

<span class="sd">&quot;&quot;&quot;{ (s[index] == c) v (FORALL 0 &lt;= i &lt; len(s), s[i] != c) }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Here is a second example, where we reason backwards from the goal,
<code class="docutils literal"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, to obtain the subgoal for completing the program successfully:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;{  subgoal:  (x &lt; 0 --&gt; y &lt;= 0)  ^  (x &gt;= 0 --&gt; y &gt; 0) }&quot;&quot;&quot;</span>
<span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    { subgoal: 1. -1 * y &gt;= 0</span>
<span class="sd">               2. y &lt;= 0          algebra 1 }&quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="sd">&quot;&quot;&quot;{  subgoal: x * y &gt; 0 }&quot;&quot;&quot;</span>
<span class="k">else</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    { subgoal: 1. 1 * y &gt; 0</span>
<span class="sd">               2. y &gt; 0           algebra 1 }&quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="sd">&quot;&quot;&quot;{  subgoal: x * y &gt; 0 }&quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;{  goal: x * y &gt; 0 }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>We propose <code class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> as the command to start the program.
To prove that the assignment achieves the subgoal established by the if-command,
we undertake a proof that must use <code class="docutils literal"><span class="pre">--&gt;i</span></code> (twice):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{  1. y == x + 1                                  premise</span>
<span class="sd">   ... 2. x &lt; 0                                   assumption</span>
<span class="sd">   ... 3. x + 1 &lt; 1                               algebra 2</span>
<span class="sd">   ... 4. x + 1 &lt;= 0                              algebra 3</span>
<span class="sd">   ... 5. y &lt;= 0                                  substitution 1, 4</span>
<span class="sd">   6. (x&lt;0) --&gt; (y &lt;= 0)                          --&gt;i 2, 5</span>

<span class="sd">   ... 7. x &gt;=0                                   assumption</span>
<span class="sd">   ... 8. x + 1 &gt; 0                               algebra 7</span>
<span class="sd">   ... 9. y &gt; 0                                   algebra 8, 1</span>
<span class="sd">   10. (x &gt;= 0) --&gt; (y &gt; 0)                       --&gt;i 7,9</span>

<span class="sd">   11. (x &lt; 0 --&gt; y &lt;= 0)  ^  (x &gt;= 0 --&gt; y &gt; 0)  ^i 6,10  }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="negation">
<h2>7.6. Negation<a class="headerlink" href="#negation" title="Permalink to this headline">¶</a></h2>
<p>The word, &#8220;not&#8221;, has many shadings in English, and it does also in logic.
We might read <code class="docutils literal"><span class="pre">~P</span></code> as saying, &#8220;<code class="docutils literal"><span class="pre">P</span></code> is not a fact&#8221;, or &#8220;the opposite of <code class="docutils literal"><span class="pre">P</span></code>
is a fact&#8221;, or &#8220;<code class="docutils literal"><span class="pre">P</span></code> can never be a fact&#8221;, or &#8220;it is impossible for <code class="docutils literal"><span class="pre">P</span></code> to be
a fact&#8221;, or &#8220;<code class="docutils literal"><span class="pre">P</span></code> is ruled out&#8221;, or even &#8220;<code class="docutils literal"><span class="pre">P</span></code> is false&#8221;.
The choice of deduction rules will decide the precise meaning of <code class="docutils literal"><span class="pre">~P</span></code>.
What is clearcut, however, is that whenever we can prove, <code class="docutils literal"><span class="pre">P</span></code> and also <code class="docutils literal"><span class="pre">~P</span></code>,
for some proposition, <code class="docutils literal"><span class="pre">P</span></code>, we have a contradiction.
A contradiction states an impossible situation, that is, <code class="docutils literal"><span class="pre">P</span></code> is a fact at the
same time that it is not a fact.
It is a &#8220;crash&#8221;, &#8220;the end of the world (or at least of the proof!)&#8221;.</p>
<div class="section" id="id32">
<h3>7.6.1. Rules<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h3>
<p>We use this symbol &#8212; <code class="docutils literal"><span class="pre">_|_</span></code> (math: ⊥) &#8212; to stand for a
contradiction.
There is an extra rule to deduce you have proved a contradiction:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>        <span class="n">P</span>    <span class="o">~</span><span class="n">P</span>
<span class="o">~</span><span class="n">e</span> <span class="p">:</span>  <span class="o">---------</span>
        <span class="n">_</span><span class="o">|</span><span class="n">_</span>
</pre></div>
</div>
<p>(The name is not ideal, but we will use it, anyway.)</p>
<p>If you start from some premises and you prove a contradiction, it means that the
premises disagree with each other.
(For example, from premises <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> and <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">0</span></code> we can deduce
<code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">^</span> <span class="pre">~(x</span> <span class="pre">&gt;</span> <span class="pre">0)</span></code>.
The problem is that the premises disagree about what is true at the start.)</p>
<p>When we encounter a contradiction in real life, we usually &#8220;start over&#8221; and try
our reasoning again, from a different set of premises.
In logic, contradictions are not only a signal that we should &#8220;start over&#8221;
(that is, change the premises of the proof we are building), but they are also
useful for finishing a line of logical reasoning where we must consider all
cases, even the impossible ones, that follow from some starting set of premises.</p>
<p>There is a special law for reasoning forwards from an impossible situation &#8212;
the <code class="docutils literal"><span class="pre">_|_e</span></code> law &#8212; which says, in the case of a contradiction, everything
becomes a fact. (That is, &#8220;if <code class="docutils literal"><span class="pre">False</span></code> is a fact, so is everything else!&#8221;.)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>        <span class="n">_</span><span class="o">|</span><span class="n">_</span>
<span class="n">_</span><span class="o">|</span><span class="n">_e</span> <span class="p">:</span>  <span class="o">------</span>  <span class="k">for</span> <span class="nb">any</span> <span class="n">proposition</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">at</span> <span class="nb">all</span>
        <span class="n">Q</span>
</pre></div>
</div>
</div>
<div class="section" id="id33">
<h3>7.6.2. Examples<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">_|_e</span></code>-rule works well with case analysis, where we discover that one case
is impossible.
Here is the classic example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="n">v</span> <span class="n">Q</span><span class="p">,</span> <span class="o">~</span><span class="n">P</span> <span class="o">|-</span> <span class="n">Q</span>

<span class="mf">1.</span> <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span>      <span class="n">premise</span>
<span class="mf">2.</span> <span class="o">~</span><span class="n">P</span>         <span class="n">premise</span>

<span class="o">...</span> <span class="mf">3.</span> <span class="n">P</span>      <span class="n">assumption</span>
<span class="o">...</span> <span class="mf">4.</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span>    <span class="o">~</span><span class="n">e</span> <span class="mi">3</span><span class="p">,</span><span class="mi">2</span>
<span class="o">...</span> <span class="mf">5.</span> <span class="n">Q</span>      <span class="n">_</span><span class="o">|</span><span class="n">_e</span> <span class="mi">4</span>

<span class="o">...</span> <span class="mf">6.</span> <span class="n">Q</span>      <span class="n">assumption</span>

<span class="mf">7.</span> <span class="n">Q</span>          <span class="n">ve</span> <span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="o">-</span><span class="mi">6</span>
</pre></div>
</div>
<p>Considering the premise, <code class="docutils literal"><span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q</span></code>, we develop the two-case analysis.
The first case, where <code class="docutils literal"><span class="pre">P</span></code> holds true, is impossible, because it causes a
contradiction.
The <code class="docutils literal"><span class="pre">_|_e</span></code>-rule lets us gracefully prove <code class="docutils literal"><span class="pre">Q</span></code> in this &#8220;impossible case&#8221;.
(You can read lines 3-6 as saying, &#8220;in the case when <code class="docutils literal"><span class="pre">P</span></code> might hold true,
there is a contradiction, and in such an impossible situation, we can deduce
whatever we like, so we deduce <code class="docutils literal"><span class="pre">Q</span></code> to finish this impossible case&#8221;.)</p>
<p>The second case, that <code class="docutils literal"><span class="pre">Q</span></code> holds true, is the only realistic case, and it
immediately yields the consequent.
The proof finishes the two-case analysis with a step of <code class="docutils literal"><span class="pre">ve</span></code>.</p>
<p>Here is another example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">--&gt;</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span> <span class="o">|-</span>  <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">R</span>

<span class="mf">1.</span> <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span>       <span class="n">premise</span>

<span class="o">...</span> <span class="mf">2.</span> <span class="n">P</span>           <span class="n">assumption</span>
<span class="o">...</span> <span class="mf">3.</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span>         <span class="o">--&gt;</span><span class="n">e</span> <span class="mi">1</span><span class="p">,</span><span class="mi">3</span>
<span class="o">...</span> <span class="mf">4.</span> <span class="n">R</span>           <span class="n">_</span><span class="o">|</span><span class="n">_e</span> <span class="mi">4</span>

<span class="mf">5.</span> <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">R</span>         <span class="o">--&gt;</span><span class="n">i</span> <span class="mi">3</span><span class="o">-</span><span class="mi">5</span>
</pre></div>
</div>
<p>The sequent can be read as, &#8220;if <code class="docutils literal"><span class="pre">P</span></code> generates a contradiction, then <code class="docutils literal"><span class="pre">P</span></code>
generates anything we want!&#8221;.
Here is a more interesting variation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">~</span><span class="n">P</span> <span class="o">|-</span>  <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">Q</span>

<span class="mf">1.</span> <span class="o">~</span><span class="n">P</span>        <span class="n">premise</span>

<span class="o">...</span> <span class="mf">2.</span> <span class="n">P</span>     <span class="n">assumption</span>
<span class="o">...</span> <span class="mf">3.</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span>   <span class="o">~</span><span class="n">e</span> <span class="mi">2</span><span class="p">,</span><span class="mi">1</span>
<span class="o">...</span> <span class="mf">4.</span> <span class="n">Q</span>     <span class="n">_</span><span class="o">|</span><span class="n">_e</span> <span class="mi">3</span>

<span class="mf">5.</span> <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">Q</span>   <span class="o">--&gt;</span><span class="n">i</span> <span class="mi">2</span><span class="o">-</span><span class="mi">4</span>
</pre></div>
</div>
<p>That is, if <code class="docutils literal"><span class="pre">P</span></code> is impossible, we can make any old if-then claim we want about
would follow if <code class="docutils literal"><span class="pre">P</span></code> somehow became a fact.
(Example: &#8220;if I am the president of the U.S., then everyone gets a tax refund of
a million bucks&#8221;. It&#8217;s a true statement but not so useful, since I am not the
president and will never be.)</p>
</div>
<div class="section" id="tactic">
<h3>7.6.3. Tactic<a class="headerlink" href="#tactic" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>(*) <code class="docutils literal"><span class="pre">_|_</span></code>-tactic: To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">Q</span></code>, if <code class="docutils literal"><span class="pre">~P</span></code> appears as a premise
or as a proved fact in our partial proof, then<ol class="arabic">
<li>prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">P</span></code></li>
<li>use <code class="docutils literal"><span class="pre">~e</span></code> to deduce <code class="docutils literal"><span class="pre">_|_</span></code></li>
<li>use the <code class="docutils literal"><span class="pre">_|_e</span></code>-rule to deduce <code class="docutils literal"><span class="pre">Q</span></code>.</li>
</ol>
</li>
</ul>
<p>The structure is</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span>   <span class="n">Premises</span>     <span class="n">premise</span>
       <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
<span class="n">i</span><span class="o">.</span>   <span class="o">~</span><span class="n">P</span>
      <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="n">j</span><span class="o">.</span>   <span class="n">P</span>
<span class="n">k</span><span class="o">.</span>   <span class="n">_</span><span class="o">|</span><span class="n">_</span>          <span class="o">~</span><span class="n">e</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span>
<span class="n">l</span><span class="o">.</span>   <span class="n">Q</span>            <span class="n">_</span><span class="o">|</span><span class="n">_e</span> <span class="n">k</span>
</pre></div>
</div>
<p>In the previous proof example, we see that <code class="docutils literal"><span class="pre">~P</span> <span class="pre">|-</span> <span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code> is proved quickly
once we obtain as a new fact (via an assumption, thanks to the (<a href="#id34"><span class="problematic" id="id35">**</span></a><a href="#id36"><span class="problematic" id="id37">*</span></a>)-<code class="docutils literal"><span class="pre">--&gt;i</span></code>
tactic!).</p>
</div>
<div class="section" id="id38">
<h3>7.6.4. Examples from Programming Logic<a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h3>
<p>Here is how we use the <code class="docutils literal"><span class="pre">_|_e</span></code>-rule with an if-command to dismiss an impossible
case in an efficient way:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
<span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">else</span> <span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>
<span class="sd">&quot;&quot;&quot;{ goal: y = 1 }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Clearly, the then-arm is executed to get the result &#8211; the else-arm will never
execute.
But the law for conditionals says we must analyze <em>both</em> arms to conclude a
logical result in advance of execution.
Our analysis quickly concludes that the else-arm is impossible, and the
<code class="docutils literal"><span class="pre">_|_e</span></code>-law finishes the job.
Say that the goal of the code that follows is to force <code class="docutils literal"><span class="pre">y</span> <span class="pre">==</span> <span class="pre">1</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
<span class="sd">&quot;&quot;&quot;{ 1. x == 3                 premise }&quot;&quot;&quot;</span>
<span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    { 1. x &gt; 0                 premise</span>
<span class="sd">      2. x == 3                premise }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="sd">&quot;&quot;&quot;{ 1. y == 1             premise }&quot;&quot;&quot;</span>
<span class="k">else</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    { 1. ~(x &gt; 0)              premise</span>
<span class="sd">      2. x == 3                premise</span>
<span class="sd">      3. (~(x &gt; 0) ^ x == 3)   ^i 1,2 }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    { 1. y = 2                 premise</span>
<span class="sd">      2. ~(x &gt; 0) ^ x == 3     premise</span>
<span class="sd">      3. ~(x &gt; 0)              ^e1 2</span>
<span class="sd">      4. x == 3                ^e2 2</span>
<span class="sd">      5. x &gt; 0                 algebra 4</span>
<span class="sd">      6. _|_                   ~e 5,3</span>
<span class="sd">      7. y == 1                _|_e 6   (!) }</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. (y == 1) v (y == 1)       premise</span>
<span class="sd">  ... 2.  y == 1               assumption</span>

<span class="sd">  ... 3.  y == 1               assumption</span>
<span class="sd">  4. y == 1                    ve 1, 2-2, 3-3 }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Because it is impossible to have both <code class="docutils literal"><span class="pre">~(x</span> <span class="pre">&gt;</span> <span class="pre">0)</span></code> and <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">3</span></code> at the same
time (line 6), we have reached an impossible situation, and we can conclude
whatever we want to finish this impossible case.</p>
<p>A useful way of thinking about a contradiction is a kind of &#8220;program crash&#8221;.
A logic proof is like a computer program, and when one uses the premises
(the &#8220;inputs&#8221;) of a proof to compute a contradiction, this is like a program
crash (a thrown exception).
The <code class="docutils literal"><span class="pre">~e</span></code> rule announces the crash/exception, and the <code class="docutils literal"><span class="pre">_|_e</span></code> rule acts like
an exception handler, cleaning up the mess and outputting some recovery answer.</p>
</div>
<div class="section" id="negation-introduction">
<h3>7.6.5. Negation Introduction<a class="headerlink" href="#negation-introduction" title="Permalink to this headline">¶</a></h3>
<p>Another rule for negation lets us deduce when an assertion is incompatible with
facts we already know.</p>
<p>For example, say that <code class="docutils literal"><span class="pre">Q</span></code>, <code class="docutils literal"><span class="pre">R</span></code>, <code class="docutils literal"><span class="pre">S</span></code>, ... are some premises that we have
used to prove facts.
Say we add <code class="docutils literal"><span class="pre">P</span></code> to the premise set, but it is incompatible, that is, we prove,
<code class="docutils literal"><span class="pre">Q,</span> <span class="pre">R,</span> <span class="pre">S,</span> <span class="pre">...,</span> <span class="pre">P</span> <span class="pre">|-</span> <span class="pre">_|_</span></code>.
So, in a world where <code class="docutils literal"><span class="pre">Q</span></code>, <code class="docutils literal"><span class="pre">R</span></code>, <code class="docutils literal"><span class="pre">S</span></code>, ... are facts, <code class="docutils literal"><span class="pre">P</span></code> can never be a
fact &#8211; we have <code class="docutils literal"><span class="pre">Q,</span> <span class="pre">R,</span> <span class="pre">S,</span> <span class="pre">...</span> <span class="pre">|-</span> <span class="pre">~P</span></code>.</p>
<div class="section" id="rule">
<h4>Rule<a class="headerlink" href="#rule" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default"><div class="highlight"><pre><span></span>         <span class="o">...</span> <span class="n">P</span> <span class="n">assume</span>
         <span class="o">...</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span>
<span class="o">~</span><span class="n">i</span><span class="p">:</span>   <span class="o">----------</span>
           <span class="o">~</span><span class="n">P</span>
</pre></div>
</div>
<p>The rule says that we can discuss the case when <code class="docutils literal"><span class="pre">P</span></code> holds; if a contradiction
results, then it is impossible for <code class="docutils literal"><span class="pre">P</span></code> to ever be a fact &#8211; indeed, <code class="docutils literal"><span class="pre">~P</span></code> is
the fact that holds.</p>
</div>
<div class="section" id="id39">
<h4>Examples<a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span><span class="p">,</span>  <span class="n">Q</span> <span class="o">--&gt;</span> <span class="o">~</span><span class="n">P</span>  <span class="o">|-</span>  <span class="o">~</span><span class="n">Q</span>

<span class="mf">1.</span> <span class="n">P</span>          <span class="n">premise</span>
<span class="mf">2.</span> <span class="n">Q</span> <span class="o">--&gt;</span> <span class="o">~</span><span class="n">P</span>   <span class="n">premise</span>

<span class="o">...</span> <span class="mf">3.</span> <span class="n">Q</span>      <span class="n">assumption</span>
<span class="o">...</span> <span class="mf">4.</span> <span class="o">~</span><span class="n">P</span>     <span class="o">--&gt;</span><span class="n">e</span> <span class="mi">2</span><span class="p">,</span><span class="mi">3</span>
<span class="o">...</span> <span class="mf">5.</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span>    <span class="o">~</span><span class="n">e</span> <span class="mi">1</span><span class="p">,</span><span class="mi">4</span>
<span class="mf">6.</span> <span class="o">~</span><span class="n">Q</span>         <span class="o">~</span><span class="n">i</span> <span class="mi">3</span><span class="o">-</span><span class="mi">5</span>
</pre></div>
</div>
<p>Here, the premises, <code class="docutils literal"><span class="pre">P</span></code> and <code class="docutils literal"><span class="pre">Q</span> <span class="pre">--&gt;</span> <span class="pre">~P</span></code>, are so strong that <em>it is impossible
for</em> <code class="docutils literal"><span class="pre">Q</span></code> <em>to ever be proved as a fact</em>.
(Lines 3-5 show that, if <code class="docutils literal"><span class="pre">Q</span></code> ever was proved a fact, it would cause a
contradiction/crash.)
So, <code class="docutils literal"><span class="pre">~Q</span></code> (&#8220;<code class="docutils literal"><span class="pre">Q</span></code> is impossible&#8221;) is proved, instead.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">|-</span> <span class="o">~~</span><span class="n">P</span>

<span class="mf">1.</span> <span class="n">P</span>           <span class="n">premise</span>

<span class="o">...</span> <span class="mf">2.</span> <span class="o">~</span> <span class="n">P</span>     <span class="n">assumption</span>
<span class="o">...</span> <span class="mf">3.</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span>     <span class="o">~</span><span class="n">e</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span>
<span class="mf">4.</span> <span class="o">~</span><span class="p">(</span><span class="o">~</span><span class="n">P</span><span class="p">)</span>       <span class="o">~</span><span class="n">i</span> <span class="mi">2</span><span class="o">-</span><span class="mi">3</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal"><span class="pre">~i</span></code> rule is not capable of proving <code class="docutils literal"><span class="pre">~~P</span> <span class="pre">|-</span> <span class="pre">P</span></code>.
Indeed, if &#8220;it is impossible that it is impossible for <code class="docutils literal"><span class="pre">P</span></code> to be a fact&#8221;, does
this mean that <code class="docutils literal"><span class="pre">P</span></code> (is proved to be) a fact?
(Example: Last night, you came home late and used your keys to enter your
apartment.
This morning, you can&#8217;t find your keys.
You say, &#8220;It&#8217;s not that I don&#8217;t have my keys!&#8221;
But do you have them in hand &#8211; do you have the evidence that you have your
keys
In mathematics, there are number problems where people have proved that it is
impossible for there not to be a solution.
But no one yet knows exactly what the solution is!)</p>
<p>These examples support this understanding of <code class="docutils literal"><span class="pre">~P</span></code>:</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">~P</span></code> <em>says that</em> &#8220;<code class="docutils literal"><span class="pre">P</span></code> <em>is impossible</em>&#8220;</div></blockquote>
<p>The three rules, <code class="docutils literal"><span class="pre">_|_e</span></code>, <code class="docutils literal"><span class="pre">~i</span></code>, and <code class="docutils literal"><span class="pre">~e</span></code>, give the meaning of
&#8220;is impossible&#8221; to the operator, <code class="docutils literal"><span class="pre">~</span></code>.</p>
</div>
<div class="section" id="id40">
<h4>Tactic<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h4>
<p>The (<a href="#id41"><span class="problematic" id="id42">**</span></a><a href="#id43"><span class="problematic" id="id44">*</span></a>)-<code class="docutils literal"><span class="pre">~i</span></code> tactic says, to prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">~P</span></code>,</p>
<ol class="arabic simple">
<li>assume <code class="docutils literal"><span class="pre">P</span></code></li>
<li>prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">P</span> <span class="pre">|-</span> <span class="pre">_|_</span></code></li>
<li>use <code class="docutils literal"><span class="pre">~i</span></code></li>
</ol>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span>  <span class="n">Premises</span>   <span class="n">premises</span>
<span class="o">...</span> <span class="n">i</span><span class="o">.</span>  <span class="n">P</span>      <span class="n">assumption</span>
         <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="o">...</span> <span class="n">j</span><span class="o">.</span>  <span class="n">_</span><span class="o">|</span><span class="n">_</span>
<span class="n">k</span><span class="o">.</span> <span class="o">~</span><span class="n">P</span>          <span class="o">~</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="n">j</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">~i</span></code>-tactic was used with good success in the previous example.</p>
</div>
</div>
<div class="section" id="proof-by-contradiction">
<h3>7.6.6. Proof by Contradiction<a class="headerlink" href="#proof-by-contradiction" title="Permalink to this headline">¶</a></h3>
<p>In circuit theory, the not-gate is a &#8220;flipper&#8221; &#8211; it flips low voltage to high
and vice versa.
In integer arithemetic, the negative symbol flips positive ints to negatives and
vice versa.
In these areas, for a datum, <code class="docutils literal"><span class="pre">D</span></code>, the phrase, <code class="docutils literal"><span class="pre">~D</span></code>, means the &#8220;opposite of&#8221;
or the &#8220;complement of&#8221; <code class="docutils literal"><span class="pre">D</span></code>.</p>
<p>In real life, we use opposites a lot &#8211; the opposite of daytime is nighttime,
the opposite of happy is sad, and so on.
We might even say that <code class="docutils literal"><span class="pre">~daytime</span></code> equals <code class="docutils literal"><span class="pre">nighttime</span></code>, and so on.
But what is <code class="docutils literal"><span class="pre">~raining</span></code>? Does it equal <code class="docutils literal"><span class="pre">sunny</span></code>? <code class="docutils literal"><span class="pre">overcast</span></code>? <code class="docutils literal"><span class="pre">snowing</span></code>?
Some concepts have no natural opposite.</p>
<p>If we work with circuits or similar True/False or &#8220;opposite&#8221; systems, then we
should be able to prove <code class="docutils literal"><span class="pre">~~P</span> <span class="pre">|-</span> <span class="pre">P</span></code>.
Here is the rule that lets us do so:</p>
<div class="section" id="id45">
<h4>Rule<a class="headerlink" href="#id45" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default"><div class="highlight"><pre><span></span>        <span class="o">...</span> <span class="o">~</span><span class="n">P</span> <span class="n">assume</span>
        <span class="o">...</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span>
<span class="n">Pbc</span><span class="p">:</span>   <span class="o">----------</span>
           <span class="n">P</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">Pbc</span></code> (&#8220;proof by contradiction&#8221;) rule says that, when <code class="docutils literal"><span class="pre">~P</span></code> leads to a
contradiction, then we have built a proof of <code class="docutils literal"><span class="pre">P</span></code>.</p>
<p>That is, <em>when</em> &#8220;<code class="docutils literal"><span class="pre">P</span></code> <em>is impossible</em>&#8221; <em>is impossible</em>, <code class="docutils literal"><span class="pre">Pbc</span></code> <em>concludes not
only that</em> &#8220;<code class="docutils literal"><span class="pre">P</span></code> <em>is possible</em>&#8221; <em>but that</em> &#8220;<code class="docutils literal"><span class="pre">P</span></code> <em>is a certainty</em>&#8221; &#8211;
<em>a fact</em>.</p>
<p>In a sense, <code class="docutils literal"><span class="pre">Pbc</span></code> builds &#8220;something from nothing&#8221; &#8211; a &#8220;proof&#8221; of &#8220;fact&#8221; <code class="docutils literal"><span class="pre">P</span></code>
from an argument that says <code class="docutils literal"><span class="pre">~P</span></code> leads to an impossible situation.
But does this mean we have &#8220;built&#8221; P?
In a world where the word &#8220;not&#8221; means the &#8220;opposite of&#8221;, we have.</p>
</div>
<div class="section" id="id46">
<h4>Examples<a class="headerlink" href="#id46" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">~~</span><span class="n">P</span> <span class="o">|-</span> <span class="n">P</span>

<span class="mf">1.</span> <span class="o">~~</span><span class="n">P</span>          <span class="n">premise</span>

<span class="o">...</span> <span class="mf">2.</span> <span class="o">~</span><span class="n">P</span>       <span class="n">assumption</span>
<span class="o">...</span> <span class="mf">3.</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span>      <span class="o">~</span><span class="n">e</span> <span class="mi">2</span><span class="p">,</span><span class="mi">1</span>
<span class="mf">4.</span> <span class="n">P</span>            <span class="n">Pbc</span> <span class="mi">2</span><span class="o">-</span><span class="mi">3</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">~</span><span class="p">(</span><span class="o">~</span><span class="n">P</span> <span class="n">v</span> <span class="o">~</span><span class="n">Q</span><span class="p">)</span>  <span class="o">|-</span> <span class="n">P</span> <span class="o">^</span> <span class="n">Q</span>

<span class="mf">1.</span>  <span class="o">~</span><span class="p">(</span><span class="o">~</span><span class="n">P</span> <span class="n">v</span> <span class="o">~</span><span class="n">Q</span><span class="p">)</span>   <span class="n">premise</span>

<span class="o">...</span> <span class="mf">2.</span> <span class="o">~</span><span class="n">P</span>        <span class="n">assumption</span>
<span class="o">...</span> <span class="mf">3.</span> <span class="o">~</span><span class="n">P</span> <span class="n">v</span> <span class="o">~</span><span class="n">Q</span>   <span class="n">vi1</span> <span class="mi">2</span>
<span class="o">...</span> <span class="mf">4.</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span>       <span class="o">~</span><span class="n">e</span> <span class="mi">3</span><span class="p">,</span><span class="mi">1</span>
<span class="mf">5.</span>  <span class="n">P</span>            <span class="n">Pbc</span> <span class="mi">2</span><span class="o">-</span><span class="mi">4</span>

<span class="o">...</span> <span class="mf">6.</span> <span class="o">~</span><span class="n">Q</span>        <span class="n">assumption</span>
<span class="o">...</span> <span class="mf">7.</span> <span class="o">~</span><span class="n">P</span> <span class="n">v</span> <span class="o">~</span><span class="n">Q</span>   <span class="n">vi2</span> <span class="mi">6</span>
<span class="o">...</span> <span class="mf">8.</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span>       <span class="o">~</span><span class="n">e</span> <span class="mi">3</span><span class="p">,</span><span class="mi">1</span>
<span class="mf">9.</span>  <span class="n">Q</span>            <span class="n">Pbc</span> <span class="mi">6</span><span class="o">-</span><span class="mi">8</span>

<span class="mf">10.</span> <span class="n">P</span> <span class="o">^</span> <span class="n">Q</span>        <span class="o">^</span><span class="n">i</span> <span class="mi">5</span><span class="p">,</span><span class="mi">9</span>
</pre></div>
</div>
<p>Here is a famous consequence of <code class="docutils literal"><span class="pre">Pbc</span></code>: from no starting premises at all, we
can prove <code class="docutils literal"><span class="pre">P</span> <span class="pre">v</span> <span class="pre">~P</span></code> for <em>any proposition we can imagine</em>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|-</span> <span class="n">P</span> <span class="n">v</span> <span class="o">~</span><span class="n">P</span>

<span class="o">...</span> <span class="mf">1.</span> <span class="o">~</span><span class="p">(</span><span class="n">P</span> <span class="n">v</span> <span class="o">~</span><span class="n">P</span><span class="p">)</span>      <span class="n">assumption</span>

<span class="o">...</span> <span class="o">...</span> <span class="mf">2.</span> <span class="n">P</span>          <span class="n">assumption</span>
<span class="o">...</span> <span class="o">...</span> <span class="mf">3.</span> <span class="n">P</span> <span class="n">v</span> <span class="o">~</span><span class="n">P</span>     <span class="n">vi1</span> <span class="mi">2</span>
<span class="o">...</span> <span class="o">...</span> <span class="mf">4.</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span>        <span class="o">~</span><span class="n">e</span> <span class="mi">3</span><span class="p">,</span><span class="mi">1</span>

<span class="o">...</span> <span class="mf">5.</span>  <span class="o">~</span><span class="n">P</span>            <span class="o">~</span><span class="n">i</span> <span class="mi">2</span>
<span class="o">...</span> <span class="mf">6.</span>  <span class="n">P</span> <span class="n">v</span> <span class="o">~</span><span class="n">P</span>        <span class="n">vi</span> <span class="mi">5</span>
<span class="o">...</span> <span class="mf">7.</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span>            <span class="o">~</span><span class="n">e</span> <span class="mi">6</span><span class="p">,</span><span class="mi">1</span>

<span class="mf">8.</span> <span class="n">P</span> <span class="n">v</span> <span class="o">~</span><span class="n">P</span>             <span class="n">Pbc</span> <span class="mi">1</span><span class="o">-</span><span class="mi">7</span>
</pre></div>
</div>
<p>Now that we have done this proof, say that <code class="docutils literal"><span class="pre">P</span></code> stands for &#8220;God has red hair&#8221;.
We have this result:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|-</span> <span class="s2">&quot;God has red hair&quot;</span> <span class="n">v</span> <span class="o">~</span><span class="p">(</span><span class="s2">&quot;God has red hair&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Do you accept this?
Perhaps the <code class="docutils literal"><span class="pre">Pbc</span></code> rule is not so well suited for deductions in the world of
theology.
A similar example is this one: let <code class="docutils literal"><span class="pre">P</span></code> stand for &#8220;I have stopped kicking my
dog&#8221;.
(But perhaps I do not even have a pet, let alone ever kicked one!)</p>
<p><code class="docutils literal"><span class="pre">Pbc</span></code> constructs &#8220;something from nothing&#8221;.
This appeals to circuit builders, where <code class="docutils literal"><span class="pre">~</span></code> and <code class="docutils literal"><span class="pre">v</span></code> are just gates/on-off
switches, but not always to computer scientists, who like to compute/build data
values and data structures in constructive ways, with algorithms.
For this reason, some logicians (actually, not so many) refuse to accept the
<code class="docutils literal"><span class="pre">Pbc</span></code> rule, except in specific circumstances.</p>
<p>Here is an example of a &#8220;specific circumstance&#8221;: for the integers, if we can
write a function,</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">propertyP</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    { pre   i and j are integers</span>
<span class="sd">      post  returns True or False and *always terminates*  }</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>that mechanically decides whether <code class="docutils literal"><span class="pre">propertyP(m,n)</span></code> is True or False for every
possible combination of integers, <code class="docutils literal"><span class="pre">m</span></code> and <code class="docutils literal"><span class="pre">n</span></code>, then we can safely use the
assertion:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|-</span> <span class="n">propertyP</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="n">v</span> <span class="o">~</span><span class="n">propertyP</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>for all choices of integers <code class="docutils literal"><span class="pre">m</span></code> and <code class="docutils literal"><span class="pre">n</span></code>.
The function, <code class="docutils literal"><span class="pre">propertyP</span></code>, is called a <em>decision procedure</em>.</p>
<p>Typically, when people accept that <code class="docutils literal"><span class="pre">|-</span> <span class="pre">P</span> <span class="pre">v</span> <span class="pre">~P</span></code> is a fact, it is because they
are using a decision procedure to answer the question.
When we consider situations that do not have decision procedures, the situation
gets murky, as in the example about the color of God&#8217;s hair.</p>
<p>Here is a surprising result, due to <code class="docutils literal"><span class="pre">Pbc</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">--&gt;</span> <span class="n">Q</span> <span class="o">|-</span> <span class="n">Q</span> <span class="n">v</span> <span class="o">~</span><span class="n">P</span>

<span class="mf">1.</span> <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">Q</span>            <span class="n">premise</span>
<span class="mf">2.</span> <span class="n">P</span> <span class="n">v</span> <span class="o">~</span><span class="n">P</span>             <span class="p">(</span><span class="n">previous</span> <span class="n">proof</span><span class="p">,</span> <span class="n">using</span> <span class="n">Pbc</span><span class="p">)</span>

<span class="o">...</span> <span class="mf">3.</span> <span class="n">P</span>              <span class="n">assumption</span>
<span class="o">...</span> <span class="mf">4.</span> <span class="n">Q</span>              <span class="o">--&gt;</span><span class="n">e</span> <span class="mi">1</span><span class="p">,</span><span class="mi">3</span>
<span class="o">...</span> <span class="mf">5.</span> <span class="n">Q</span> <span class="n">v</span> <span class="o">~</span><span class="n">P</span>         <span class="n">vi1</span> <span class="mi">4</span>

<span class="o">...</span> <span class="mf">6.</span> <span class="o">~</span><span class="n">P</span>             <span class="n">assumption</span>
<span class="o">...</span> <span class="mf">7.</span> <span class="n">Q</span> <span class="n">v</span> <span class="o">~</span><span class="n">P</span>         <span class="n">vi2</span> <span class="mi">6</span>

<span class="mf">8.</span> <span class="n">Q</span> <span class="n">v</span> <span class="o">~</span><span class="n">P</span>             <span class="n">ve</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="o">-</span><span class="mi">7</span>
</pre></div>
</div>
<p>This proof says that the dependency of <code class="docutils literal"><span class="pre">Q</span></code> on <code class="docutils literal"><span class="pre">P</span></code> forces us to conclude that
either <code class="docutils literal"><span class="pre">Q</span></code> is already a fact or <code class="docutils literal"><span class="pre">P</span></code> is impossible.
It is slightly odd that an &#8220;if-then&#8221; dependency would ensure either of the two
outcomes.
But this is the consequence of <code class="docutils literal"><span class="pre">Pbc</span></code>&#8216;s ability to build something from nothing.</p>
<p>This result also relies on Pbc:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|-</span> <span class="p">(</span><span class="n">P</span> <span class="o">--&gt;</span> <span class="n">Q</span><span class="p">)</span> <span class="n">v</span> <span class="p">(</span><span class="n">Q</span> <span class="o">--&gt;</span> <span class="n">P</span><span class="p">)</span>
</pre></div>
</div>
<p>for <em>any choice whatsover</em> of propositions <code class="docutils literal"><span class="pre">P</span></code> and <code class="docutils literal"><span class="pre">Q</span></code>.
(An example: let <code class="docutils literal"><span class="pre">P</span></code> stand for &#8220;It is raining&#8221; and <code class="docutils literal"><span class="pre">Q</span></code> stand for
&#8220;I am the President&#8221;.
The above sequent holds true, even though there is no dependency between the two
propositions.
Why is that so?
Is it reasonable?
The claim looks more benign when we restrict <code class="docutils literal"><span class="pre">P</span></code> and <code class="docutils literal"><span class="pre">Q</span></code> to be propositions
about logic gates.
The moral is, certain logic rules are meant for certain application areas, and
the <code class="docutils literal"><span class="pre">Pbc</span></code> rule works well in only circuit-theory-like worlds.)</p>
<p>This last result follows because <code class="docutils literal"><span class="pre">Pbc</span></code> lets us deduce that
<code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span> <span class="pre">|-</span> <span class="pre">Q</span> <span class="pre">v</span> <span class="pre">~P</span></code> &#8211; no longer does <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code> tell us that <code class="docutils literal"><span class="pre">P</span></code> gives the
needed knowledge for constructing/deducing <code class="docutils literal"><span class="pre">Q</span></code>;
no longer does <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code> tell us that <code class="docutils literal"><span class="pre">Q</span></code> physically depends on <code class="docutils literal"><span class="pre">P</span></code>.
Instead, due to <code class="docutils literal"><span class="pre">Pbc</span></code>, we must read <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code> as stating a coincidence about
the underlying True/False values of <code class="docutils literal"><span class="pre">P</span></code> and <code class="docutils literal"><span class="pre">Q</span></code>.
For this reason, the <code class="docutils literal"><span class="pre">--&gt;</span></code> operator is no longer necessary in a logic that
uses the <code class="docutils literal"><span class="pre">Pbc</span></code> rule;
this is why there is no need for an <code class="docutils literal"><span class="pre">--&gt;</span></code> gate in circuit theory (you use
<code class="docutils literal"><span class="pre">Q</span> <span class="pre">v</span> <span class="pre">~P</span></code> instead).</p>
<p>There is no truly useful tactic for applying the <code class="docutils literal"><span class="pre">Pbc</span></code>-rule.
It is indeed a rule of &#8220;last resort&#8221;, because it says, to try to prove
<code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">P</span></code>, one should assume <code class="docutils literal"><span class="pre">~P</span></code> and see if this leads one into a
contradiction, that is, a proof that <code class="docutils literal"><span class="pre">Premises,~P</span> <span class="pre">|-</span> <span class="pre">_|_</span></code>.
This is a kind of logical &#8220;wild-goose chase&#8221;.
But later in the chapter, we will see how computers can be made to chase after
such geese.</p>
</div>
</div>
</div>
<div class="section" id="important-equivalences">
<h2>7.7. Important Equivalences<a class="headerlink" href="#important-equivalences" title="Permalink to this headline">¶</a></h2>
<p>These useful equivalences can be proved with the laws for And and Or:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">P</span> <span class="pre">v</span> <span class="pre">P</span> <span class="pre">-||-</span> <span class="pre">P</span></code></li>
<li><code class="docutils literal"><span class="pre">P</span> <span class="pre">^</span> <span class="pre">P</span> <span class="pre">-||-</span> <span class="pre">P</span></code></li>
<li><code class="docutils literal"><span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q</span> <span class="pre">-||-</span> <span class="pre">Q</span> <span class="pre">v</span> <span class="pre">P</span></code></li>
<li><code class="docutils literal"><span class="pre">P</span> <span class="pre">^</span> <span class="pre">Q</span> <span class="pre">-||-</span> <span class="pre">Q</span> <span class="pre">^</span> <span class="pre">P</span></code></li>
<li><code class="docutils literal"><span class="pre">(P</span> <span class="pre">v</span> <span class="pre">Q)</span> <span class="pre">v</span> <span class="pre">R</span> <span class="pre">-||-</span> <span class="pre">P</span> <span class="pre">v</span> <span class="pre">(Q</span> <span class="pre">v</span> <span class="pre">R)</span></code></li>
<li><code class="docutils literal"><span class="pre">(P</span> <span class="pre">^</span> <span class="pre">Q)</span> <span class="pre">^</span> <span class="pre">R</span> <span class="pre">-||-</span> <span class="pre">P</span> <span class="pre">^</span> <span class="pre">(Q</span> <span class="pre">^</span> <span class="pre">R)</span></code></li>
<li><code class="docutils literal"><span class="pre">(P</span> <span class="pre">v</span> <span class="pre">Q)</span> <span class="pre">^</span> <span class="pre">R</span> <span class="pre">-||-</span> <span class="pre">(P</span> <span class="pre">^</span> <span class="pre">R)</span> <span class="pre">v</span> <span class="pre">(Q</span> <span class="pre">^</span> <span class="pre">R)</span></code></li>
<li><code class="docutils literal"><span class="pre">(P</span> <span class="pre">^</span> <span class="pre">Q)</span> <span class="pre">v</span> <span class="pre">R</span> <span class="pre">-||-</span> <span class="pre">(P</span> <span class="pre">v</span> <span class="pre">R)</span> <span class="pre">^</span> <span class="pre">(Q</span> <span class="pre">v</span> <span class="pre">R)</span> <span class="pre">P</span></code></li>
</ul>
<p>If you are an algebraist, you already knew these assertions, which characterize
a distributive lattice.</p>
<p>When we add the rules for implies, we can prove one other key equivalence:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">(P</span> <span class="pre">^</span> <span class="pre">Q)</span> <span class="pre">--&gt;</span> <span class="pre">R</span> <span class="pre">-||-</span> <span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">(Q</span> <span class="pre">--&gt;</span> <span class="pre">R)</span></code></li>
</ul>
<p>When we add the <code class="docutils literal"><span class="pre">~e</span></code>, <code class="docutils literal"><span class="pre">_|_e</span></code>, and <code class="docutils literal"><span class="pre">~i</span></code> rules, we can also prove:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">~(P</span> <span class="pre">v</span> <span class="pre">Q)</span> <span class="pre">-||-</span> <span class="pre">~P</span> <span class="pre">^</span> <span class="pre">~Q</span></code></li>
<li><code class="docutils literal"><span class="pre">~(P</span> <span class="pre">v</span> <span class="pre">Q)</span> <span class="pre">-||-</span> <span class="pre">~(~P</span> <span class="pre">--&gt;</span> <span class="pre">Q)</span></code></li>
<li><code class="docutils literal"><span class="pre">(P</span> <span class="pre">--&gt;</span> <span class="pre">~Q)</span> <span class="pre">-||-</span> <span class="pre">~(P</span> <span class="pre">^</span> <span class="pre">Q)</span></code></li>
<li><code class="docutils literal"><span class="pre">(P</span> <span class="pre">--&gt;</span> <span class="pre">~Q)</span> <span class="pre">-||-</span> <span class="pre">(~P)</span> <span class="pre">v</span> <span class="pre">Q</span></code></li>
<li><code class="docutils literal"><span class="pre">~P</span> <span class="pre">-||-</span> <span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">_|_</span></code></li>
<li><code class="docutils literal"><span class="pre">~P</span> <span class="pre">-||-</span> <span class="pre">~~~P</span></code></li>
</ul>
<p>Now we have characterized what algebraists call the Heyting lattices.</p>
<p>If we accept <code class="docutils literal"><span class="pre">Pbc</span></code> (or equivalently, we accept <code class="docutils literal"><span class="pre">P</span> <span class="pre">v</span> <span class="pre">~P</span></code> as a fact), then we
have these important results:
(Note, for each equivalence, <code class="docutils literal"><span class="pre">-||-</span></code>, that follows, the first part, stated with
<code class="docutils literal"><span class="pre">|-</span></code>, can be proved without <code class="docutils literal"><span class="pre">Pbc</span></code>, but the reverse direction requires
<code class="docutils literal"><span class="pre">Pbc</span></code>.)</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">P</span> <span class="pre">-||-</span> <span class="pre">~~P</span></code></li>
<li><code class="docutils literal"><span class="pre">P</span> <span class="pre">^</span> <span class="pre">Q</span> <span class="pre">-||-</span> <span class="pre">~(~P</span> <span class="pre">v</span> <span class="pre">~Q)</span></code></li>
<li><code class="docutils literal"><span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q</span> <span class="pre">-||-</span> <span class="pre">~(~P</span> <span class="pre">^</span> <span class="pre">~Q)</span></code></li>
<li><code class="docutils literal"><span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q</span> <span class="pre">-||-</span> <span class="pre">~P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code></li>
<li><code class="docutils literal"><span class="pre">~P</span> <span class="pre">v</span> <span class="pre">~Q</span> <span class="pre">-||-</span> <span class="pre">~(P</span> <span class="pre">^</span> <span class="pre">Q)</span></code></li>
<li><code class="docutils literal"><span class="pre">~P</span> <span class="pre">v</span> <span class="pre">Q</span> <span class="pre">-||-</span> <span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code></li>
<li><code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span> <span class="pre">-||-</span> <span class="pre">~Q</span> <span class="pre">--&gt;</span> <span class="pre">~P</span></code></li>
<li><code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span> <span class="pre">-||-</span> <span class="pre">~(P</span> <span class="pre">^</span> <span class="pre">~</span> <span class="pre">Q)</span></code></li>
<li><code class="docutils literal"><span class="pre">(B</span> <span class="pre">^</span> <span class="pre">P)</span> <span class="pre">v</span> <span class="pre">(~B</span> <span class="pre">^</span> <span class="pre">Q)</span> <span class="pre">-||-</span> <span class="pre">(B</span> <span class="pre">--&gt;</span> <span class="pre">P)</span> <span class="pre">^</span> <span class="pre">(~B</span> <span class="pre">--&gt;</span> <span class="pre">Q)</span></code></li>
</ul>
<p>In algebra, the inference rules presented here for <code class="docutils literal"><span class="pre">^</span></code>, <code class="docutils literal"><span class="pre">v</span></code>, <code class="docutils literal"><span class="pre">_|_</span></code>, and
<code class="docutils literal"><span class="pre">~</span></code> define the structure of a Boolean lattice, and the origins of modern
abstract algebra and logic come from George Boole&#8217;s attempt to formalize
&#8220;what it means&#8221; to compute with <code class="docutils literal"><span class="pre">^</span></code>, <code class="docutils literal"><span class="pre">v</span></code>, <code class="docutils literal"><span class="pre">~</span></code>.</p>
</div>
<div class="section" id="conjunctive-normal-form-cnf">
<h2>7.8. Conjunctive Normal Form (CNF)<a class="headerlink" href="#conjunctive-normal-form-cnf" title="Permalink to this headline">¶</a></h2>
<p>Computers can be programmed to manipulate propositions built with <code class="docutils literal"><span class="pre">^</span></code>, <code class="docutils literal"><span class="pre">v</span></code>,
<code class="docutils literal"><span class="pre">~</span></code>.
This is because the previous equivalences show we can eliminate all occurrences
of <code class="docutils literal"><span class="pre">--&gt;</span></code> and use <code class="docutils literal"><span class="pre">~</span></code>, <code class="docutils literal"><span class="pre">v</span></code> instead (provided we accept the <code class="docutils literal"><span class="pre">Pbc</span></code> rule).</p>
<p>A more striking result (again, provided we accept the <code class="docutils literal"><span class="pre">Pbc</span></code> rule) is that
every proposition written with <code class="docutils literal"><span class="pre">^</span></code>, <code class="docutils literal"><span class="pre">v</span></code>, <code class="docutils literal"><span class="pre">~</span></code> can be rewritten as an
equivalent proposition in this structure, called
<em>conjunctive normal form (cnf)</em>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">A00</span> <span class="n">v</span> <span class="n">A01</span> <span class="n">v</span> <span class="o">...</span> <span class="n">A0n</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">A10</span> <span class="n">v</span> <span class="n">A11</span> <span class="n">v</span> <span class="o">...</span> <span class="n">A1n</span><span class="p">)</span> <span class="o">^</span> <span class="o">...</span> <span class="o">^</span> <span class="p">(</span><span class="n">Am0</span> <span class="n">v</span> <span class="n">Am1</span> <span class="n">v</span> <span class="o">...</span> <span class="n">Amn</span><span class="p">)</span>
</pre></div>
</div>
<p>where each <code class="docutils literal"><span class="pre">Aij</span></code> is either a primitive proposition, <code class="docutils literal"><span class="pre">P</span></code>, or a negated
primitive proposition, <code class="docutils literal"><span class="pre">~P</span></code>.</p>
<p>A cnf-proposition is an &#8220;and-or&#8221; proposition, where &#8220;or-clauses&#8221; (disjunctive
clauses) are &#8220;anded together&#8221;.
The cnf structure is easy for a computer to manipulate and forms the starting
point for a powerful computerized proof technique known as
<em>resolution theorem proving</em>, which we consider shortly.</p>
<p>For example, <code class="docutils literal"><span class="pre">P</span> <span class="pre">^</span> <span class="pre">(Q</span> <span class="pre">v</span> <span class="pre">~R)</span></code> is in cnf, but <code class="docutils literal"><span class="pre">(P</span> <span class="pre">^</span> <span class="pre">Q)</span> <span class="pre">v</span> <span class="pre">~R</span></code> is not.
(Why?)
But the latter proposition is equivalent to <code class="docutils literal"><span class="pre">(P</span> <span class="pre">v</span> <span class="pre">~R)</span> <span class="pre">^</span> <span class="pre">(Q</span> <span class="pre">v</span> <span class="pre">~R)</span></code>, which is in
cnf.</p>
<p>Here is another example: <code class="docutils literal"><span class="pre">~(Q</span> <span class="pre">v</span> <span class="pre">~R)</span></code> is equivalent to <code class="docutils literal"><span class="pre">~Q</span> <span class="pre">^</span> <span class="pre">~~R</span></code>, which is
equivalent to <code class="docutils literal"><span class="pre">~Q</span> <span class="pre">^</span> <span class="pre">R</span></code>, which is in cnf.</p>
<p>Again, a proposition in conjunctive normal form is a sequence of one or more
conjunctions, <code class="docutils literal"><span class="pre">A1</span> <span class="pre">^</span> <span class="pre">A2</span> <span class="pre">^</span> <span class="pre">...</span> <span class="pre">^</span> <span class="pre">Am</span></code>, where each <code class="docutils literal"><span class="pre">Ai</span></code> is itself a sequence of
one or more disjunctions, <code class="docutils literal"><span class="pre">Bi1</span> <span class="pre">v</span> <span class="pre">Bi2</span> <span class="pre">v</span> <span class="pre">...</span> <span class="pre">v</span> <span class="pre">Bin</span></code>, where each component,
<code class="docutils literal"><span class="pre">Bij</span></code>, is itself a primitive proposition, <code class="docutils literal"><span class="pre">P</span></code>, or the negation, <code class="docutils literal"><span class="pre">~P</span></code>, of
one.</p>
<p>There are specific logical equivalences we apply to transform a proposition into
cnf.
Here they are, stated within an algorithm that converts an arbitrary proposition
into one in cnf:</p>
<ol class="arabic">
<li><p class="first">First, remove all implications, <code class="docutils literal"><span class="pre">A</span> <span class="pre">--&gt;</span> <span class="pre">B</span></code>, with this equivalence:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">--&gt;</span> <span class="n">B</span>  <span class="o">-||-</span>  <span class="o">~</span><span class="n">A</span> <span class="n">v</span> <span class="n">B</span>
</pre></div>
</div>
</li>
<li><p class="first">Next, move all remaining negation operators inwards, by repeatedly applying
these equivalences:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">~</span><span class="p">(</span><span class="o">~</span><span class="n">A</span><span class="p">)</span>  <span class="o">-||-</span>  <span class="n">A</span>
<span class="o">~</span><span class="p">(</span><span class="n">A</span> <span class="o">^</span> <span class="n">B</span><span class="p">)</span>  <span class="o">-||-</span>  <span class="o">~</span><span class="n">A</span> <span class="n">v</span> <span class="o">~</span><span class="n">B</span>
<span class="o">~</span><span class="p">(</span><span class="n">A</span> <span class="n">v</span> <span class="n">B</span><span class="p">)</span>  <span class="o">-||-</span>  <span class="o">~</span><span class="n">A</span> <span class="o">^</span> <span class="o">~</span><span class="n">B</span>
</pre></div>
</div>
</li>
<li><p class="first">At this point, all negation operators appear next to primitive propositions.
To finish, repeatedly apply (inside out) this equivalence to group together
all disjunction operators:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">A</span> <span class="o">^</span> <span class="n">B</span><span class="p">)</span> <span class="n">v</span> <span class="n">C</span>  <span class="o">-||-</span>  <span class="p">(</span><span class="n">A</span> <span class="n">v</span> <span class="n">C</span><span class="p">)</span>  <span class="o">^</span>  <span class="p">(</span><span class="n">B</span> <span class="n">v</span> <span class="n">C</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
<p>Let&#8217;s apply these steps to a nontrivial example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">~</span><span class="n">P</span> <span class="o">--&gt;</span> <span class="n">Q</span><span class="p">)</span> <span class="n">v</span> <span class="o">~</span><span class="p">(</span><span class="n">Q</span> <span class="n">v</span> <span class="o">~</span><span class="n">R</span><span class="p">)</span>

<span class="o">-||-</span>  <span class="p">(</span><span class="o">~~</span><span class="n">P</span> <span class="n">v</span> <span class="n">Q</span><span class="p">)</span>  <span class="n">v</span>  <span class="o">~</span><span class="p">(</span><span class="n">Q</span> <span class="n">v</span> <span class="o">~</span><span class="n">R</span><span class="p">)</span>    <span class="p">(</span><span class="n">step</span> <span class="mi">1</span><span class="p">)</span>

<span class="o">-||-</span>  <span class="p">(</span><span class="n">P</span> <span class="n">v</span> <span class="n">Q</span><span class="p">)</span>  <span class="n">v</span>  <span class="o">~</span><span class="p">(</span><span class="n">Q</span> <span class="n">v</span> <span class="o">~</span><span class="n">R</span><span class="p">)</span>
<span class="o">-||-</span>  <span class="p">(</span><span class="n">P</span> <span class="n">v</span> <span class="n">Q</span><span class="p">)</span>  <span class="n">v</span>  <span class="p">(</span><span class="o">~</span><span class="n">Q</span> <span class="o">^</span> <span class="o">~~</span><span class="n">R</span><span class="p">)</span>
<span class="o">-||-</span>  <span class="p">(</span><span class="n">P</span> <span class="n">v</span> <span class="n">Q</span><span class="p">)</span>  <span class="n">v</span>  <span class="p">(</span><span class="o">~</span><span class="n">Q</span> <span class="o">^</span> <span class="n">R</span><span class="p">)</span>              <span class="p">(</span><span class="n">step</span> <span class="mi">2</span><span class="p">)</span>

<span class="o">-||-</span>  <span class="p">(</span><span class="o">~</span><span class="n">Q</span> <span class="n">v</span> <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span><span class="p">)</span>  <span class="o">^</span>  <span class="p">(</span><span class="n">R</span> <span class="n">v</span> <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span><span class="p">)</span>   <span class="p">(</span><span class="n">step</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>The result, which is in cnf, can be simplified further:</p>
<ol class="arabic simple">
<li>Every disjunctive clause of form, <code class="docutils literal"><span class="pre">(P</span> <span class="pre">v</span> <span class="pre">Q</span> <span class="pre">v</span> <span class="pre">...</span> <span class="pre">v</span> <span class="pre">Q</span> <span class="pre">v</span> <span class="pre">R</span> <span class="pre">v</span> <span class="pre">...)</span></code>, can be
reduced by removing duplicates of the same proposition:
<code class="docutils literal"><span class="pre">(P</span> <span class="pre">v</span> <span class="pre">Q</span> <span class="pre">v</span> <span class="pre">...</span> <span class="pre">v</span> <span class="pre">R</span> <span class="pre">v</span> <span class="pre">...)</span></code></li>
<li>Every disjunctive clause of form, <code class="docutils literal"><span class="pre">(P</span> <span class="pre">v</span> <span class="pre">Q</span> <span class="pre">v</span> <span class="pre">...</span> <span class="pre">v</span> <span class="pre">~Q</span> <span class="pre">v</span> <span class="pre">R</span> <span class="pre">v</span> <span class="pre">...)</span></code>, is always
true and can be reduced to <code class="docutils literal"><span class="pre">True</span></code>.</li>
</ol>
<p>Looking at the previous example, we see that <code class="docutils literal"><span class="pre">(~Q</span> <span class="pre">v</span> <span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q)</span> <span class="pre">^</span> <span class="pre">(R</span> <span class="pre">v</span> <span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q)</span></code>
reduces to <code class="docutils literal"><span class="pre">True</span> <span class="pre">^</span> <span class="pre">(R</span> <span class="pre">v</span> <span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q)</span></code>, which is just <code class="docutils literal"><span class="pre">R</span> <span class="pre">v</span> <span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q</span></code>.
In this way, we reduce a complex proposition into its minimal, equivalent form,
cnf.</p>
<p>These constructions suggest that propositional logic, using all the deduction
rules including <code class="docutils literal"><span class="pre">Pbc</span></code>, boils down to an and-or game.
And in some sense, this is true.
But the story changes when we add the quantifiers, <code class="docutils literal"><span class="pre">FORALL</span></code>
(&#8220;for all&#8221;; math: ∀) and EXIST (&#8220;there exists&#8221;;
math: ∃).</p>
<div class="section" id="resolution-theorem-proving">
<h3>7.8.1. Resolution Theorem Proving<a class="headerlink" href="#resolution-theorem-proving" title="Permalink to this headline">¶</a></h3>
<p>Our deduction rules model common-sense thinking &#8211; they are useful for humans
but clumsy for computers.
In the 1960&#8217;s, J. Alan Robinson proposed a deduction system for computers that
has proved useful and successful; it is called <em>resolution theorem proving</em>.</p>
<p>Resolution theorem proving depends on propositions in cnf as well as the <code class="docutils literal"><span class="pre">Pbc</span></code>
rule.
To prove a sequent, <code class="docutils literal"><span class="pre">A1,</span> <span class="pre">A2,</span> <span class="pre">...,</span> <span class="pre">Am</span> <span class="pre">|-</span> <span class="pre">B</span></code>, we</p>
<ol class="arabic simple">
<li>translate every <code class="docutils literal"><span class="pre">Ai</span></code> into its conjunctive normal form, <code class="docutils literal"><span class="pre">A'i</span></code></li>
<li>translate <code class="docutils literal"><span class="pre">~B</span></code> into its conjunctive normal form, <code class="docutils literal"><span class="pre">notB'</span></code></li>
<li>try to prove <code class="docutils literal"><span class="pre">A'1,</span> <span class="pre">A'2,</span> <span class="pre">...,</span> <span class="pre">A'm,</span> <span class="pre">notB'</span> <span class="pre">|-</span> <span class="pre">_|_</span></code></li>
</ol>
<p>If step 3 succeeds, we finish with the <code class="docutils literal"><span class="pre">Pbc</span></code> rule.</p>
<p>This proves the result.
We know how to do Steps 1 and 2, so let&#8217;s focus on Step 3.</p>
<p>To do Step 3, we first reorganize all of <code class="docutils literal"><span class="pre">A'1,</span> <span class="pre">A'2,</span> <span class="pre">...,</span> <span class="pre">A'm,</span> <span class="pre">notB'</span></code> into one
large cnf proposition, and then we split the proposition into its set of
disjunctive clauses.</p>
<p>Here is an example.
We want to prove:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">--&gt;</span> <span class="n">R</span><span class="p">,</span>  <span class="n">Q</span> <span class="o">--&gt;</span> <span class="n">R</span> <span class="o">|-</span>  <span class="p">(</span><span class="n">P</span> <span class="n">v</span> <span class="n">Q</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">R</span>
</pre></div>
</div>
<p>We translate the premises and negated goal into this cnf proposition:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">~</span><span class="n">P</span> <span class="n">v</span> <span class="n">R</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="o">~</span><span class="n">Q</span> <span class="n">v</span> <span class="n">R</span><span class="p">)</span>  <span class="o">^</span>  <span class="p">(</span><span class="n">P</span> <span class="n">v</span> <span class="n">Q</span><span class="p">)</span> <span class="o">^</span> <span class="o">~</span><span class="n">R</span>
</pre></div>
</div>
<p>This gives this set of disjunctive clauses:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="o">~</span><span class="n">P</span> <span class="n">v</span> <span class="n">R</span><span class="p">,</span>  <span class="o">~</span><span class="n">Q</span> <span class="n">v</span> <span class="n">R</span><span class="p">,</span>  <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span><span class="p">,</span>  <span class="o">~</span><span class="n">R</span><span class="p">}</span>
</pre></div>
</div>
<p>From these clauses, we must prove a contradiction.</p>
<p>To finish Step 3, we forget our existing deduction rules and use just this one
deduction rule, the resolution rule, which works with disjunctive clauses:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>         <span class="n">A</span> <span class="n">v</span> <span class="n">P</span>     <span class="o">~</span><span class="n">P</span> <span class="n">v</span> <span class="n">B</span>
<span class="n">res</span><span class="p">:</span>  <span class="o">--------------------------</span>
              <span class="n">A</span> <span class="n">v</span> <span class="n">B</span>
</pre></div>
</div>
<p>The res rule maps two facts to a new fact.
Indeed, by a nested cases analysis (<code class="docutils literal"><span class="pre">ve</span></code>), we can manually prove that
<code class="docutils literal"><span class="pre">A</span> <span class="pre">v</span> <span class="pre">P,</span> <span class="pre">~P</span> <span class="pre">v</span> <span class="pre">B</span> <span class="pre">|-</span> <span class="pre">A</span> <span class="pre">v</span> <span class="pre">B</span></code>.
This is why we can use <code class="docutils literal"><span class="pre">res</span></code> as a deduction rule.</p>
<p>But <code class="docutils literal"><span class="pre">res</span></code> is a special deduction rule, because the clause it generates is
<em>smaller</em> than the union of its two premises &#8211; it removes a proposition from
future computation.
So, if we use <code class="docutils literal"><span class="pre">res</span></code> on all possible combinations of all the disjunctive
premises that we started with, at some point we will generate all possible facts
&#8211; the mechanical application of <code class="docutils literal"><span class="pre">res</span></code> will not run forever.</p>
<p>Here is the example and a proof using the <code class="docutils literal"><span class="pre">res</span></code> rule.
When we apply the <code class="docutils literal"><span class="pre">res</span></code> rule, we connect the two clauses used:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">~</span><span class="n">P</span> <span class="n">v</span> <span class="n">R</span>           <span class="o">~</span><span class="n">Q</span> <span class="n">v</span> <span class="n">R</span>          <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span>          <span class="o">~</span><span class="n">R</span>
    <span class="o">|</span>              <span class="o">|</span>              <span class="o">|</span>              <span class="o">|</span>
    <span class="o">|</span>              <span class="o">+--------------+</span>              <span class="o">|</span>
    <span class="o">|</span>                    <span class="n">R</span> <span class="n">v</span> <span class="n">P</span>                   <span class="o">|</span>
    <span class="o">|</span>                      <span class="o">|</span>                     <span class="o">|</span>
    <span class="o">+----------------------+</span>                     <span class="o">|</span>
              <span class="n">R</span> <span class="n">v</span> <span class="n">R</span>  <span class="o">=</span>  <span class="n">R</span>                        <span class="o">|</span>
                     <span class="o">|</span>                           <span class="o">|</span>
                     <span class="o">+---------------------------+</span>
                              <span class="p">(</span><span class="n">empty</span><span class="p">)</span> <span class="o">=</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span>
</pre></div>
</div>
<p>We used <code class="docutils literal"><span class="pre">res</span></code> three times and deduced an empty disjunctive clause, which means
False, that is <code class="docutils literal"><span class="pre">_|_</span></code>.
Notice we compressed the clause, <code class="docutils literal"><span class="pre">R</span> <span class="pre">v</span> <span class="pre">R</span></code>, into just <code class="docutils literal"><span class="pre">R</span></code>.
This is a key step in applying the res rule to uncover <code class="docutils literal"><span class="pre">_|_</span></code>.</p>
<p>The proof search can be conducted more than one way:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">~</span><span class="n">P</span> <span class="n">v</span> <span class="n">R</span>          <span class="o">~</span><span class="n">Q</span> <span class="n">v</span> <span class="n">R</span>          <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span>         <span class="o">~</span><span class="n">R</span>
   <span class="o">|</span>              <span class="o">|</span>              <span class="o">|</span>            <span class="o">|</span> <span class="o">|</span>
   <span class="o">|</span>              <span class="o">+--------------+</span>            <span class="o">|</span> <span class="o">|</span>
   <span class="o">|</span>                    <span class="n">R</span> <span class="n">v</span> <span class="n">P</span>                 <span class="o">|</span> <span class="o">|</span>
   <span class="o">|</span>                     <span class="o">|</span>                    <span class="o">|</span> <span class="o">|</span>
   <span class="o">|</span>                     <span class="o">+--------------------+</span> <span class="o">|</span>
   <span class="o">|</span>                               <span class="n">P</span>            <span class="o">|</span>
   <span class="o">|</span>                               <span class="o">|</span>            <span class="o">|</span>
   <span class="o">+-------------------------------+</span>            <span class="o">|</span>
                 <span class="n">R</span>                              <span class="o">|</span>
                 <span class="o">|</span>                              <span class="o">|</span>
                 <span class="o">+------------------------------+</span>
                         <span class="p">(</span><span class="n">empty</span><span class="p">)</span> <span class="o">=</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span>
</pre></div>
</div>
<p>Here, the premise <code class="docutils literal"><span class="pre">~R</span></code> must be used twice to prove the contradiction.
For this reason, a computerized implementation tries all possible combinations
of each <code class="docutils literal"><span class="pre">res</span></code>-generated clause with all existing clauses, searching to build
an empty clause.</p>
<p>Of course, if a sequent is unsound, resolution will not prove it.
For example, if we try to prove that <code class="docutils literal"><span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q</span></code> entails <code class="docutils literal"><span class="pre">P</span> <span class="pre">^</span> <span class="pre">Q</span></code> (and of course
it does not), we attempt this proof, which fails:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="n">v</span> <span class="n">Q</span>           <span class="o">~</span><span class="n">P</span> <span class="n">v</span> <span class="o">~</span><span class="n">Q</span>
  <span class="o">|</span>                <span class="o">|</span>
  <span class="o">+----------------+</span>
      <span class="n">Q</span> <span class="n">v</span> <span class="o">~</span><span class="n">Q</span>       <span class="o">|</span>           <span class="p">(</span><span class="n">always</span> <span class="n">true</span> <span class="o">---</span> <span class="n">this</span> <span class="n">clause</span> <span class="n">can</span> <span class="n">be</span> <span class="n">ignored</span><span class="p">)</span>
         <span class="o">|</span>         <span class="o">|</span>
         <span class="o">+---------+</span>
            <span class="o">~</span><span class="n">Q</span> <span class="n">v</span> <span class="o">~</span><span class="n">P</span>           <span class="p">(</span><span class="n">back</span> <span class="n">where</span> <span class="n">we</span> <span class="n">started</span><span class="p">;</span> <span class="n">no</span> <span class="n">use</span> <span class="n">continuing</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>There is no way to deduce an empty clause.
Indeed, the set of clauses we can possibly generate consists of everything we
see in the above attempt (if we include the mirror clause, <code class="docutils literal"><span class="pre">P</span> <span class="pre">v</span> <span class="pre">~P</span></code>, which is
easily generated, too).
And this is why an implementation can halt the proof search &#8211; if the
implementation generates all possible combinations of disjunctive clauses and
no more new clauses appear, then the search stops, with failure.</p>
<div class="section" id="implementing-cnf-and-resolution-theorem-proving-with-nested-lists">
<h4>Implementing CNF and Resolution Theorem Proving with Nested Lists<a class="headerlink" href="#implementing-cnf-and-resolution-theorem-proving-with-nested-lists" title="Permalink to this headline">¶</a></h4>
<p>A formula in cnf has a simple computer representation as a list of lists, that
is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">A00</span> <span class="n">v</span> <span class="n">A01</span> <span class="n">v</span> <span class="o">...</span> <span class="n">A0n</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">A10</span> <span class="n">v</span> <span class="n">A11</span> <span class="n">v</span> <span class="o">...</span> <span class="n">A1n</span><span class="p">)</span> <span class="o">^</span> <span class="o">...</span> <span class="o">^</span> <span class="p">(</span><span class="n">Am0</span> <span class="n">v</span> <span class="n">Am1</span> <span class="n">v</span> <span class="o">...</span> <span class="n">Amn</span><span class="p">)</span>
</pre></div>
</div>
<p>is represented in computer storage as the nested list:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="p">[</span><span class="n">A00</span><span class="p">,</span> <span class="n">A01</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">A0n</span><span class="p">],</span>  <span class="p">[</span><span class="n">A10</span><span class="p">,</span> <span class="n">A11</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">A1n</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="p">[</span><span class="n">Am0</span><span class="p">,</span> <span class="n">Am1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">Amn</span><span class="p">]</span> <span class="p">]</span>
</pre></div>
</div>
<p>For example, <code class="docutils literal"><span class="pre">(~Q</span> <span class="pre">v</span> <span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q)</span> <span class="pre">^</span> <span class="pre">(R</span> <span class="pre">v</span> <span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q)</span></code> is the nested list,
<code class="docutils literal"><span class="pre">[[&quot;~Q&quot;,</span> <span class="pre">&quot;P&quot;,</span> <span class="pre">&quot;Q&quot;],</span> <span class="pre">[&quot;R&quot;,</span> <span class="pre">&quot;P&quot;,</span> <span class="pre">&quot;~Q&quot;]]</span></code>.</p>
<p>The list representation makes it easy to implement resolution theorem proving:
To prove a sequent, <code class="docutils literal"><span class="pre">A1,</span> <span class="pre">A2,</span> <span class="pre">...,</span> <span class="pre">Am</span> <span class="pre">|-</span> <span class="pre">B</span></code>, we</p>
<ol class="arabic simple">
<li>translate every <code class="docutils literal"><span class="pre">Ai</span></code> into its cnf (nested list), <code class="docutils literal"><span class="pre">A'i</span></code>, and translate
<code class="docutils literal"><span class="pre">~B</span></code> into its conjunctive normal form (nested list), <code class="docutils literal"><span class="pre">notB'</span></code></li>
<li>append the nested lists into one long list of &#8220;disjunctive facts&#8221;:
<code class="docutils literal"><span class="pre">facts</span> <span class="pre">=</span> <span class="pre">A'1</span> <span class="pre">+</span> <span class="pre">A'2</span> <span class="pre">+</span> <span class="pre">A'M</span> <span class="pre">+</span> <span class="pre">notB'</span></code>.</li>
<li>Search the elements of list facts, searching for two lists, <code class="docutils literal"><span class="pre">L1</span></code> and
<code class="docutils literal"><span class="pre">L2</span></code>, such that proposition <code class="docutils literal"><span class="pre">&quot;~X&quot;</span></code> is in <code class="docutils literal"><span class="pre">L1</span></code> and <code class="docutils literal"><span class="pre">&quot;X&quot;</span></code> is in <code class="docutils literal"><span class="pre">L2</span></code>.<ul>
<li>If no such <code class="docutils literal"><span class="pre">L1</span></code> and <code class="docutils literal"><span class="pre">L2</span></code> are found, then we finish with failure &#8211;
there is no proof.</li>
<li>Else we find such <code class="docutils literal"><span class="pre">L1</span></code> and <code class="docutils literal"><span class="pre">L2</span></code>, and we build the list, <code class="docutils literal"><span class="pre">L3</span></code>, which
equals <code class="docutils literal"><span class="pre">L1</span> <span class="pre">+</span> <span class="pre">L2</span></code> but with both <code class="docutils literal"><span class="pre">&quot;~X&quot;</span></code> and <code class="docutils literal"><span class="pre">&quot;X&quot;</span></code> removed.
<strong>IMPORTANT:</strong> <code class="docutils literal"><span class="pre">L3</span></code> <strong>must be a list that is not already in</strong> <code class="docutils literal"><span class="pre">facts</span></code>.
(If such an <code class="docutils literal"><span class="pre">L3</span></code> cannot be found, then we finish with failure.)<ul>
<li>If <code class="docutils literal"><span class="pre">L3</span> <span class="pre">==</span> <span class="pre">[]</span></code>, we finish with success.</li>
<li>If <code class="docutils literal"><span class="pre">L3</span> <span class="pre">!=</span> <span class="pre">[]</span></code>, then we insert <code class="docutils literal"><span class="pre">L3</span></code> at the front of facts and repeat
this step.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>Here&#8217;s how the above algorithm operates on the earlier example, proving the
sequent, <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q,</span> <span class="pre">Q</span> <span class="pre">--&gt;</span> <span class="pre">R</span> <span class="pre">|-</span> <span class="pre">(P</span> <span class="pre">v</span> <span class="pre">Q)</span> <span class="pre">--&gt;</span> <span class="pre">R</span></code>:</p>
<ul class="simple">
<li>The premises and negated goal are appended into the nested list of disjunctive
facts, <code class="docutils literal"><span class="pre">facts</span> <span class="pre">=</span> <span class="pre">[[&quot;~P&quot;,</span> <span class="pre">&quot;R&quot;],</span> <span class="pre">[&quot;~Q&quot;,</span> <span class="pre">&quot;R&quot;],</span> <span class="pre">[&quot;P&quot;,</span> <span class="pre">&quot;Q&quot;],</span> <span class="pre">[&quot;~R&quot;]]</span></code>.</li>
<li><code class="docutils literal"><span class="pre">&quot;~P&quot;</span></code> in the first fact matches <code class="docutils literal"><span class="pre">&quot;P&quot;</span></code> in the third fact, so
<code class="docutils literal"><span class="pre">L3</span> <span class="pre">=</span> <span class="pre">[&quot;R&quot;,</span> <span class="pre">&quot;Q&quot;]</span></code>, and
<code class="docutils literal"><span class="pre">facts</span> <span class="pre">=</span> <span class="pre">[[&quot;R&quot;,</span> <span class="pre">&quot;Q&quot;],</span> <span class="pre">[&quot;~P&quot;,</span> <span class="pre">&quot;R&quot;],</span> <span class="pre">[&quot;~Q&quot;,</span> <span class="pre">&quot;R&quot;],</span> <span class="pre">[&quot;P&quot;,</span> <span class="pre">&quot;Q&quot;],</span> <span class="pre">[&quot;~R&quot;]]</span></code>.</li>
<li><code class="docutils literal"><span class="pre">&quot;Q&quot;</span></code> in the first fact matches <code class="docutils literal"><span class="pre">&quot;~Q&quot;</span></code> in the third fact, so
<code class="docutils literal"><span class="pre">L3</span> <span class="pre">=</span> <span class="pre">[&quot;R&quot;,</span> <span class="pre">&quot;R&quot;]</span> <span class="pre">=</span> <span class="pre">[&quot;R&quot;]</span></code>, and
<code class="docutils literal"><span class="pre">facts</span> <span class="pre">=</span> <span class="pre">[[&quot;R&quot;],</span> <span class="pre">[&quot;R&quot;,</span> <span class="pre">&quot;~Q&quot;],</span> <span class="pre">[&quot;~P&quot;,</span> <span class="pre">&quot;R&quot;],</span> <span class="pre">[&quot;~Q&quot;,</span> <span class="pre">&quot;R&quot;],</span> <span class="pre">[&quot;P&quot;,</span> <span class="pre">&quot;Q&quot;],</span> <span class="pre">[&quot;~R&quot;]]</span></code>.</li>
<li><code class="docutils literal"><span class="pre">&quot;R&quot;</span></code> in the first fact matches <code class="docutils literal"><span class="pre">&quot;~R&quot;</span></code> in the last fact, and
<code class="docutils literal"><span class="pre">L3</span> <span class="pre">=</span> <span class="pre">[]</span></code>, so the sequent is proved.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="models-of-propositional-logic-soundness-and-completeness">
<h2>7.9. Models of Propositional Logic: Soundness and Completeness<a class="headerlink" href="#models-of-propositional-logic-soundness-and-completeness" title="Permalink to this headline">¶</a></h2>
<p>When we say that &#8220;<code class="docutils literal"><span class="pre">P</span></code> is a fact&#8221;, what does this mean?
Perhaps it means &#8220;<code class="docutils literal"><span class="pre">P</span></code> is True&#8221;, or &#8220;<code class="docutils literal"><span class="pre">P</span></code> is proved&#8221;, or &#8220;our confidence in
<code class="docutils literal"><span class="pre">P</span></code> is absolute&#8221;.</p>
<p>The purpose of this section is to describe ways that we give meaning to
propositions and to show that the deduction rules in this chapter generate new
knowledge that means what we think it means.</p>
<div class="section" id="truth-tables">
<h3>7.9.1. Truth Tables<a class="headerlink" href="#truth-tables" title="Permalink to this headline">¶</a></h3>
<p>The most basic interpretation of propositions is that a proposition means either
True (<code class="docutils literal"><span class="pre">t</span></code>, <code class="docutils literal"><span class="pre">1</span></code>) or False (<code class="docutils literal"><span class="pre">f</span></code>, <code class="docutils literal"><span class="pre">0</span></code>).
This is a &#8220;circuit theory&#8221; interpretation.
In this situation, the meanings of the connectives, <code class="docutils literal"><span class="pre">^</span></code>, <code class="docutils literal"><span class="pre">v</span></code>, <code class="docutils literal"><span class="pre">~</span></code> are
given by the truth tables in the Chapter on <a class="reference internal" href="../02-circuits-truth-tables/index.html#circuits"><span class="std std-ref">Circuits and Truth Tables</span></a>.</p>
<p>Return to the Chapter on <a class="reference internal" href="../02-circuits-truth-tables/index.html#circuits"><span class="std std-ref">Circuits and Truth Tables</span></a> of these notes and review the truth tables for
<code class="docutils literal"><span class="pre">^</span></code>, <code class="docutils literal"><span class="pre">v</span></code>, <code class="docutils literal"><span class="pre">~</span></code>.
A truth table defines how the &#8220;inputs&#8221; <code class="docutils literal"><span class="pre">P</span></code> and <code class="docutils literal"><span class="pre">Q</span></code> are converted into
&#8220;outputs&#8221;.
Next, here is the standard truth table for <code class="docutils literal"><span class="pre">--&gt;</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span> <span class="n">P</span> <span class="n">Q</span> <span class="o">|</span>  <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">Q</span>
<span class="o">---------------</span>
 <span class="n">t</span> <span class="n">t</span> <span class="o">|</span> <span class="n">t</span>
 <span class="n">t</span> <span class="n">f</span> <span class="o">|</span> <span class="n">f</span>
 <span class="n">f</span> <span class="n">t</span> <span class="o">|</span> <span class="n">t</span>
 <span class="n">f</span> <span class="n">f</span> <span class="o">|</span> <span class="n">t</span>
</pre></div>
</div>
<p>The table&#8217;s last two rows are a bit surprising &#8211; indeed, neither <code class="docutils literal"><span class="pre">t</span></code> nor
<code class="docutils literal"><span class="pre">f</span></code> seem exactly correct as outputs here!
Think of <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code> as &#8220;the truth of &#8220;<code class="docutils literal"><span class="pre">P</span></code> forces the truth of <code class="docutils literal"><span class="pre">Q</span></code>&#8221;.
So, when <code class="docutils literal"><span class="pre">P</span></code> is <code class="docutils literal"><span class="pre">f</span></code>, then <code class="docutils literal"><span class="pre">Q</span></code> is not forced to be anything at all.
This makes <code class="docutils literal"><span class="pre">t</span></code> a reasonable answer for the last two rows of the table.</p>
<p>In a more technical sense, the values in the last two rows connect to our
ability to prove <code class="docutils literal"><span class="pre">~P</span> <span class="pre">|-</span> <span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code> and also <code class="docutils literal"><span class="pre">~P</span> <span class="pre">|-</span> <span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">~Q</span></code> &#8211;
they relate to our willingness to consider impossible cases (and embrace the
<code class="docutils literal"><span class="pre">_|_e</span></code> rule).</p>
<p>Nonetheless, we see that our understanding of implication as a truth table is
open to discussion.</p>
<p>Recall that we can build a truth table of a compound proposition.
We can do this for any sequent, computing the values of its premises and its
goal.
Here is an example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span> <span class="n">v</span> <span class="n">R</span>  <span class="o">|-</span>  <span class="p">(</span><span class="n">P</span> <span class="o">^</span> <span class="n">Q</span><span class="p">)</span> <span class="n">v</span> <span class="p">(</span><span class="n">P</span> <span class="o">^</span> <span class="n">R</span><span class="p">)</span>


<span class="n">P</span>  <span class="n">Q</span>  <span class="n">R</span>  <span class="o">|</span>  <span class="n">P</span>   <span class="n">Q</span> <span class="n">v</span> <span class="n">R</span>      <span class="p">(</span><span class="n">P</span> <span class="o">^</span> <span class="n">Q</span><span class="p">)</span> <span class="n">v</span> <span class="p">(</span><span class="n">P</span> <span class="o">^</span> <span class="n">R</span><span class="p">)</span>
<span class="o">-------------------------------------------------------</span>
<span class="n">t</span>  <span class="n">t</span>  <span class="n">t</span>  <span class="o">|</span>  <span class="n">t</span>     <span class="n">t</span>                 <span class="n">t</span>
<span class="n">t</span>  <span class="n">t</span>  <span class="n">f</span>  <span class="o">|</span>  <span class="n">t</span>     <span class="n">t</span>                 <span class="n">t</span>
<span class="n">t</span>  <span class="n">f</span>  <span class="n">t</span>  <span class="o">|</span>  <span class="n">t</span>     <span class="n">t</span>                 <span class="n">t</span>
<span class="n">t</span>  <span class="n">f</span>  <span class="n">f</span>  <span class="o">|</span>  <span class="n">t</span>     <span class="n">f</span>                 <span class="n">f</span>
<span class="n">f</span>  <span class="n">t</span>  <span class="n">t</span>  <span class="o">|</span>  <span class="n">f</span>     <span class="n">t</span>                 <span class="n">f</span>
<span class="n">f</span>  <span class="n">t</span>  <span class="n">f</span>  <span class="o">|</span>  <span class="n">f</span>     <span class="n">t</span>                 <span class="n">f</span>
<span class="n">f</span>  <span class="n">f</span>  <span class="n">t</span>  <span class="o">|</span>  <span class="n">f</span>     <span class="n">t</span>                 <span class="n">f</span>
<span class="n">f</span>  <span class="n">f</span>  <span class="n">f</span>  <span class="o">|</span>  <span class="n">f</span>     <span class="n">f</span>                 <span class="n">f</span>
</pre></div>
</div>
<p>According to the compound truth table, <code class="docutils literal"><span class="pre">P</span></code>, <code class="docutils literal"><span class="pre">Q</span> <span class="pre">v</span> <span class="pre">R</span></code> entails
<code class="docutils literal"><span class="pre">(P</span> <span class="pre">^</span> <span class="pre">Q)</span> <span class="pre">v</span> <span class="pre">(P</span> <span class="pre">^</span> <span class="pre">R)</span></code>, because, in every row where both <code class="docutils literal"><span class="pre">P</span></code> and also <code class="docutils literal"><span class="pre">Q</span> <span class="pre">v</span> <span class="pre">R</span></code>
compute to <code class="docutils literal"><span class="pre">t</span></code>, then so does <code class="docutils literal"><span class="pre">(P</span> <span class="pre">^</span> <span class="pre">Q)</span> <span class="pre">v</span> <span class="pre">(P</span> <span class="pre">^</span> <span class="pre">R)</span></code>.</p>
<p>We can of course use the deduction rules to build a proof of
<code class="docutils literal"><span class="pre">P,</span> <span class="pre">Q</span> <span class="pre">v</span> <span class="pre">R</span> <span class="pre">|-</span> <span class="pre">(P</span> <span class="pre">^</span> <span class="pre">Q)</span> <span class="pre">v</span> <span class="pre">(P</span> <span class="pre">^</span> <span class="pre">R)</span></code>.</p>
<p>Now, we have two questions:</p>
<ol class="arabic simple">
<li><em>soundness</em>: When we use the deduction rules to prove that
<code class="docutils literal"><span class="pre">P1,</span> <span class="pre">P2,</span> <span class="pre">...,</span> <span class="pre">Pn</span> <span class="pre">|-</span> <span class="pre">Q</span></code>, does this mean that the compound truth table also
shows that <code class="docutils literal"><span class="pre">P1,</span> <span class="pre">P2,</span> <span class="pre">...,</span> <span class="pre">Pn</span></code> entails <code class="docutils literal"><span class="pre">Q</span></code>?</li>
<li><em>completeness</em>: When we use a compound truth table and calculate that
<code class="docutils literal"><span class="pre">P1,</span> <span class="pre">P2,</span> <span class="pre">...,</span> <span class="pre">Pn</span></code> entails <code class="docutils literal"><span class="pre">Q</span></code>, does this mean we can use the deduction
rules to build a proof that <code class="docutils literal"><span class="pre">P1,</span> <span class="pre">P2,</span> <span class="pre">...,</span> <span class="pre">Pn</span> <span class="pre">|-</span> <span class="pre">Q</span></code>?</li>
</ol>
<p>When we use all the inference rules presented in this chapter (that is, <code class="docutils literal"><span class="pre">^i</span></code>,
<code class="docutils literal"><span class="pre">^e</span></code>, <code class="docutils literal"><span class="pre">vi</span></code>, <code class="docutils literal"><span class="pre">ve</span></code>, <code class="docutils literal"><span class="pre">--&gt;i</span></code>, <code class="docutils literal"><span class="pre">--&gt;e</span></code>, <code class="docutils literal"><span class="pre">_|_e</span></code>, <code class="docutils literal"><span class="pre">~i</span></code>, <code class="docutils literal"><span class="pre">~e</span></code>, <code class="docutils literal"><span class="pre">Pbc</span></code>)
then the short answer to both questions is &#8220;yes&#8221;.
The inference rules encode completely all the information within truth tables,
and truth tables decode all the deductions of inference rules.</p>
<p>Because of soundness and completeness, one way to determine whether there is a
proof for a sequent, <code class="docutils literal"><span class="pre">P1,</span> <span class="pre">P2,</span> <span class="pre">...,</span> <span class="pre">Pn</span> <span class="pre">|-</span> <span class="pre">Q</span></code>, is to build its truth table and
see if the truth table tells us whether the claim is true.
If yes, then we know there is a proof.
This brute-force technique is easy to program; why did we bother to learn about
cnf and resolution theorem proving, then?
The reason is that truth tables will fail us when we add the for-all
(<code class="docutils literal"><span class="pre">FORALL</span></code>; math: ∀) and there-exists
(<code class="docutils literal"><span class="pre">EXIST</span></code>; math: ∃) operators to logic,
but resolution theorem proving can and will be expanded to work with
quantifiers.
This is the reason for its success.</p>
<p>The reason why truth tables predict existence of proofs is because they are tied
to the <code class="docutils literal"><span class="pre">Pbc</span></code> rule.
Say that we are purists and refuse to use the <code class="docutils literal"><span class="pre">Pbc</span></code> inference rule.
The set of rules that remain are certainly sound with respect to the truth
tables, but they are not complete.
(For example, a compound truth table shows that <code class="docutils literal"><span class="pre">|-</span> <span class="pre">P</span> <span class="pre">v</span> <span class="pre">~P</span></code>, but this cannot
be proved without <code class="docutils literal"><span class="pre">Pbc</span></code>.)</p>
<p>You might argue that the deduction system lacking <code class="docutils literal"><span class="pre">Pbc</span></code> is too weak.
<em>Or, you might argue that our understanding of the meaning of propositions is
incorrect.</em></p>
<p>(If you are an algebraist, you shrug your shoulders, because you already know
that the full set of deduction rules is sound and complete for any mathematical
model of meaning that forms a Boolean lattice.
The set of rules that omit <code class="docutils literal"><span class="pre">Pbc</span></code> is sound and complete for any mathematical
model of meaning that forms a Heyting lattice. The details are below.)</p>
<p>The point is, meaning goes beyond primitive notions like <code class="docutils literal"><span class="pre">{0,</span> <span class="pre">1}</span></code> and
<code class="docutils literal"><span class="pre">{t,</span> <span class="pre">f}</span></code>, and mathematicians have understood this for about 200 years.
Indeed, there are many different forms of meaning and many different forms of
symbolic logic that deduce assertions with those meanings.</p>
</div>
<div class="section" id="boolean-lattices">
<h3>7.9.2. Boolean Lattices<a class="headerlink" href="#boolean-lattices" title="Permalink to this headline">¶</a></h3>
<p>If we believe all propositions are either True (<code class="docutils literal"><span class="pre">t</span></code>, <code class="docutils literal"><span class="pre">1</span></code>) or False
(<code class="docutils literal"><span class="pre">f</span></code>, <code class="docutils literal"><span class="pre">0</span></code>), we run into an immediate problem with a statement like <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>
&#8211; is it True or False?
The correct answer is, &#8220;it depends (on the context in which it is stated, that
is, on the value of <code class="docutils literal"><span class="pre">x</span></code>)&#8221;.</p>
<p>Propositions must be understood in the context in which they are stated, and
<code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> is True sometimes and is False sometimes.
Rather than using a simple two-valued, <code class="docutils literal"><span class="pre">t,f</span></code>, model of meaning, we should
generalize to a model that takes context into account.
The appropriate generalization of the two-valued truth-table model to a
many-valued model is called a <em>Boolean lattice</em>.</p>
<p>The meaning of a proposition is <em>the set of all the contexts that make the
proposition a fact</em>.
For example, in algebra class, perhaps we study the properties of an unknown
integer variable, <code class="docutils literal"><span class="pre">x</span></code>.
We make statements like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">0</span>
<span class="mi">2</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>We next ask, &#8220;in which contexts are these propositions facts?&#8221;
We write <code class="docutils literal"><span class="pre">[[</span> <span class="pre">P</span> <span class="pre">]]</span></code> to name the set of those contexts that make <code class="docutils literal"><span class="pre">P</span></code> a fact.
For the above primitive propositions, in a &#8220;universe&#8221; of integers, we have:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">]]</span>      <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">...</span> <span class="p">}</span>    <span class="p">(</span><span class="n">that</span> <span class="ow">is</span><span class="p">,</span>  <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="ow">is</span> <span class="n">a</span> <span class="n">fact</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">context</span>
                                        <span class="n">where</span>  <span class="n">x</span>  <span class="n">equals</span> <span class="mi">1</span> <span class="ow">or</span> <span class="mi">2</span> <span class="ow">or</span> <span class="mi">3</span> <span class="ow">or</span> <span class="o">...</span><span class="p">)</span>
<span class="p">[[</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">]]</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="p">[[</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">]]</span>  <span class="o">=</span> <span class="p">{</span> <span class="o">...</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">[[</span> <span class="mi">2</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="p">]]</span> <span class="o">=</span> <span class="n">Int</span><span class="p">,</span>  <span class="n">that</span> <span class="ow">is</span><span class="p">,</span>  <span class="p">{</span> <span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">[[</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">]]</span>  <span class="o">=</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>These sets are the <em>meanings</em> of the propositions.
What is the &#8220;world of meanings&#8221; from which these sets are taken?
Surely, it is not just <code class="docutils literal"><span class="pre">t,f</span></code> &#8211; it is the set of all subsets of the integers.
(We write this is <code class="docutils literal"><span class="pre">P(Int)</span></code>, where <code class="docutils literal"><span class="pre">Int</span> <span class="pre">=</span> <span class="pre">{...,-2,-1,0,1,2,...}</span></code>.)
Here is a crude, partial drawing of this world of meanings, <code class="docutils literal"><span class="pre">P(Int)</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>                  <span class="p">{</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="o">...</span><span class="p">}</span>
  <span class="o">...</span>

<span class="o">...</span>   <span class="p">{</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="o">...</span><span class="p">}</span>      <span class="p">{</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span> <span class="o">...</span><span class="p">}</span>     <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="o">...</span><span class="p">}</span>  <span class="o">...</span>

  <span class="o">...</span>

<span class="o">...</span>    <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span>       <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span>    <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span>    <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span>  <span class="o">...</span>

<span class="o">...</span> <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span>  <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">}</span>  <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">}</span>  <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span>  <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span>  <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span>  <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span> <span class="o">...</span>

<span class="o">...</span>  <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">}</span>     <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span>        <span class="p">{</span><span class="mi">0</span><span class="p">}</span>         <span class="p">{</span><span class="mi">1</span><span class="p">}</span>         <span class="p">{</span><span class="mi">2</span><span class="p">}</span>   <span class="o">...</span>

                          <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>This collection is infinite, and many sets within the collection are infinite.
The structure is a <em>Boolean lattice</em>, named after George Boole, who studied
first this form of meaning-world: It lets us union sets, intersect sets, and
make complements of sets.</p>
<div class="section" id="conjunction-disjunction-negation">
<h4>Conjunction, Disjunction, Negation<a class="headerlink" href="#conjunction-disjunction-negation" title="Permalink to this headline">¶</a></h4>
<p>We use the Boolean lattice give meaning to <code class="docutils literal"><span class="pre">^</span></code>, <code class="docutils literal"><span class="pre">v</span></code>, and <code class="docutils literal"><span class="pre">~</span></code>.
Say that <code class="docutils literal"><span class="pre">U</span></code> is the set of all contexts under study.
Each proposition, <code class="docutils literal"><span class="pre">P</span></code>, has a meaning that is some subset of <code class="docutils literal"><span class="pre">U</span></code>.
(In the above example, <code class="docutils literal"><span class="pre">U</span> <span class="pre">=</span> <span class="pre">Int</span> <span class="pre">=</span> <span class="pre">{0,1,2,3,...}</span></code>.)
We define the connectives like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span> <span class="n">P</span> <span class="o">^</span> <span class="n">Q</span> <span class="p">]]</span> <span class="o">=</span>  <span class="p">[[</span><span class="n">P</span><span class="p">]]</span> <span class="n">intersection</span> <span class="p">[[</span><span class="n">Q</span><span class="p">]]</span>
                              <span class="p">(</span><span class="n">that</span> <span class="ow">is</span><span class="p">,</span> <span class="n">the</span> <span class="nb">set</span> <span class="n">of</span> <span class="n">contexts</span> <span class="n">that</span>
                               <span class="n">make</span> <span class="n">both</span> <span class="n">P</span> <span class="n">a</span> <span class="n">fact</span> <span class="ow">and</span> <span class="n">Q</span> <span class="n">a</span> <span class="n">fact</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">intersection</span> <span class="n">of</span>
                               <span class="n">the</span> <span class="nb">set</span> <span class="n">that</span> <span class="n">makes</span> <span class="n">P</span> <span class="n">a</span> <span class="n">fact</span> <span class="k">with</span> <span class="n">the</span> <span class="n">one</span> <span class="n">that</span>
                               <span class="n">makes</span> <span class="n">Q</span> <span class="n">a</span> <span class="n">fact</span><span class="p">)</span>
<span class="p">[[</span> <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span> <span class="p">]]</span> <span class="o">=</span>  <span class="p">[[</span><span class="n">P</span><span class="p">]]</span> <span class="n">union</span> <span class="p">[[</span><span class="n">Q</span><span class="p">]]</span>

<span class="p">[[</span> <span class="o">~</span><span class="n">P</span> <span class="p">]]</span>    <span class="o">=</span>  <span class="n">U</span> <span class="o">-</span> <span class="p">[[</span><span class="n">P</span><span class="p">]]</span>      <span class="p">(</span><span class="n">that</span> <span class="ow">is</span><span class="p">,</span> <span class="nb">set</span> <span class="n">complement</span><span class="p">:</span> <span class="n">remove</span> <span class="nb">all</span> <span class="n">contexts</span>
                               <span class="n">where</span> <span class="p">[[</span><span class="n">P</span><span class="p">]]</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">fact</span><span class="p">)</span>
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">v</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">]]</span> <span class="o">=</span>  <span class="p">[[</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">]]</span> <span class="n">union</span> <span class="p">[[</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="o">...</span><span class="p">}</span>

<span class="p">[[</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">]]</span> <span class="o">=</span> <span class="p">[[</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">]]</span> <span class="n">intersection</span> <span class="p">[[</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">}</span>

<span class="p">[[</span> <span class="o">~</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">]]</span> <span class="o">=</span>  <span class="p">{</span><span class="o">...-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">...</span><span class="p">}</span> <span class="o">-</span> <span class="p">{</span><span class="mi">1</span><span class="p">}</span>  <span class="o">=</span>  <span class="p">{</span><span class="o">...-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">...</span><span class="p">}</span>
</pre></div>
</div>
<p>With these definitions, it is easy to calculate that
<code class="docutils literal"><span class="pre">[[</span> <span class="pre">P</span> <span class="pre">v</span> <span class="pre">~P</span> <span class="pre">]]</span> <span class="pre">=</span> <span class="pre">Int</span></code>, <code class="docutils literal"><span class="pre">[[</span> <span class="pre">P</span> <span class="pre">^</span> <span class="pre">~P</span> <span class="pre">]]</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">}</span></code>, and so on.
Indeed, all the logical equivalences stated in the earlier section become set
equalities in the Boolean-lattice model, e.g.,
<code class="docutils literal"><span class="pre">[[</span> <span class="pre">P</span> <span class="pre">^</span> <span class="pre">Q</span> <span class="pre">]]</span> <span class="pre">=</span> <span class="pre">[[</span> <span class="pre">~(~P</span> <span class="pre">v</span> <span class="pre">~Q)</span> <span class="pre">]]</span></code> and <code class="docutils literal"><span class="pre">[[</span> <span class="pre">P</span> <span class="pre">]]</span> <span class="pre">=</span> <span class="pre">[[</span> <span class="pre">~~P</span> <span class="pre">]]</span></code>.
Just as important, entailment is understood as subset containment, <code class="docutils literal"><span class="pre">⊆</span></code>.</p>
<p>It is a famous and important result that the full set of deduction rules in this
chapter are sound and complete for the Boolean-lattice models:</p>
<ul>
<li><p class="first"><em>sound</em>: When we prove <code class="docutils literal"><span class="pre">P1,</span> <span class="pre">P2,</span> <span class="pre">...,</span> <span class="pre">Pn</span> <span class="pre">|-</span> <span class="pre">Q</span></code>, it must be the case that:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>([[P1]] intersection [[P2]] intersection ... intersection [[Pn]]) ⊆ (is a subset of) [[ Q ]]
</pre></div>
</div>
<p>no matter what meanings are given to <code class="docutils literal"><span class="pre">P1</span></code>, <code class="docutils literal"><span class="pre">P2</span></code>, ... <code class="docutils literal"><span class="pre">Q</span></code>.</p>
</li>
<li><p class="first"><em>complete</em>: When it is the case that, no matter how we give meanings to
<code class="docutils literal"><span class="pre">P1</span></code>, <code class="docutils literal"><span class="pre">P2</span></code>, ... <code class="docutils literal"><span class="pre">Q</span></code>, in an arbitrary Boolean lattice, we end up with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>[[P1]] intersection [[P2]] intersection ... intersection [[Pn]] ⊆ (is a subset of) [[Q]]
</pre></div>
</div>
<p>then we can prove <code class="docutils literal"><span class="pre">P1,</span> <span class="pre">P2,</span> <span class="pre">...,</span> <span class="pre">Pn</span> <span class="pre">|-</span> <span class="pre">Q</span></code>.</p>
</li>
</ul>
<p>The key is that meanings are sets, so <code class="docutils literal"><span class="pre">^</span></code> is just set intersection,
<code class="docutils literal"><span class="pre">v</span></code> is set union, and <code class="docutils literal"><span class="pre">~</span></code> is set complement.
This gives a smooth understanding of logic, and it is remarkable that the
common-sense deduction rules match elementary set theory.</p>
</div>
<div class="section" id="implication">
<h4>Implication<a class="headerlink" href="#implication" title="Permalink to this headline">¶</a></h4>
<p>But what about implication?
Read <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code> as saying, &#8220;when a context makes <code class="docutils literal"><span class="pre">P</span></code> a fact, that same
context forces &#8220;&#8221;Q&#8221;&#8221; to be a fact, too&#8221;.
Here is an appropriate definition of <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code> as a set of contexts, namely,
those contexts that make <code class="docutils literal"><span class="pre">P</span></code> a fact also force <code class="docutils literal"><span class="pre">Q</span></code> to be a fact:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>[[ P --&gt; Q ]] =  S,  where  S  is the largest set of contexts
                     such that   S  intersection [[ P ]] ⊆ [[Q]]
</pre></div>
</div>
<p>(IMPORTANT: the previous line is just a restatement of the <code class="docutils literal"><span class="pre">--&gt;e</span></code> rule:
<code class="docutils literal"><span class="pre">[[</span> <span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span> <span class="pre">]]</span> <span class="pre">^</span> <span class="pre">[[P]]</span> <span class="pre">|-</span> <span class="pre">[[Q]]</span></code>!)</p>
<p>In the Boolean lattice model seen above, set <code class="docutils literal"><span class="pre">S</span></code> is merely
<code class="docutils literal"><span class="pre">[[</span> <span class="pre">Q</span> <span class="pre">]]</span> <span class="pre">union</span> <span class="pre">(S</span> <span class="pre">-</span> <span class="pre">[[</span> <span class="pre">P</span> <span class="pre">]])</span></code>, that is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span> <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">Q</span> <span class="p">]]</span> <span class="o">=</span>  <span class="p">[[</span> <span class="o">~</span><span class="n">P</span> <span class="n">v</span> <span class="n">Q</span> <span class="p">]])</span>
</pre></div>
</div>
<p>The equivalence, <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span> <span class="pre">-||-</span> <span class="pre">Q</span> <span class="pre">v</span> <span class="pre">~P</span></code>, holds true in the Boolean-lattice
model.
This is a bit disappointing, but it is the price we pay for defining negation as
set complement (&#8220;the opposite of&#8221;).</p>
<p>There is one final observation: If we define:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span> <span class="p">]]</span> <span class="o">=</span>  <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>that is, no context can ever make a contradiction into a fact, then:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span> <span class="o">~</span><span class="n">P</span> <span class="p">]]</span>  <span class="o">=</span>  <span class="p">[[</span> <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span> <span class="p">]]</span>
</pre></div>
</div>
<p>because <code class="docutils literal"><span class="pre">[[</span> <span class="pre">~P</span> <span class="pre">]]</span></code> is exactly the largest set, <code class="docutils literal"><span class="pre">S</span></code>, where <code class="docutils literal"><span class="pre">S</span></code> intersect
<code class="docutils literal"><span class="pre">[[</span> <span class="pre">P</span> <span class="pre">]]</span> <span class="pre">⊆</span> <span class="pre">{</span> <span class="pre">}</span></code>.
This means <em>negation is unnecessary to logic</em> provided we have implication and
contradiction.
It also suggests the reading of <code class="docutils literal"><span class="pre">~P</span></code> as &#8220;<code class="docutils literal"><span class="pre">P</span></code> is impossible&#8221; is appropriate.</p>
</div>
<div class="section" id="other-boolean-lattices">
<h4>Other Boolean Lattices<a class="headerlink" href="#other-boolean-lattices" title="Permalink to this headline">¶</a></h4>
<p>There are simpler Boolean lattices than the powerset of all the integers.
The following are all examples of Boolean lattices, where <code class="docutils literal"><span class="pre">U</span></code> names the
&#8220;universe&#8221; of possible contexts.
All can be used to give sematics to propositional logic:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">U0</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">}</span>         <span class="n">U1</span> <span class="o">=</span> <span class="p">{</span><span class="n">day</span><span class="p">,</span><span class="n">night</span><span class="p">}</span>          <span class="n">U2</span> <span class="o">=</span> <span class="p">{</span><span class="n">wkday</span><span class="p">,</span><span class="n">sat</span><span class="p">,</span><span class="n">sun</span><span class="p">}</span>


  <span class="p">{</span><span class="mi">1</span><span class="p">}</span>             <span class="p">{</span><span class="n">day</span><span class="p">,</span><span class="n">night</span><span class="p">}</span>                       <span class="p">{</span><span class="n">wkday</span><span class="p">,</span><span class="n">sat</span><span class="p">,</span><span class="n">sun</span><span class="p">}</span>

  <span class="p">{}</span>            <span class="p">{</span><span class="n">day</span><span class="p">}</span>    <span class="p">{</span><span class="n">night</span><span class="p">}</span>         <span class="p">{</span><span class="n">wkday</span><span class="p">,</span><span class="n">sat</span><span class="p">}</span>   <span class="p">{</span><span class="n">wkday</span><span class="p">,</span><span class="n">sun</span><span class="p">}</span>   <span class="p">{</span><span class="n">sat</span><span class="p">,</span><span class="n">sun</span><span class="p">}</span>

                      <span class="p">{}</span>                     <span class="p">{</span><span class="n">wkday</span><span class="p">}</span>     <span class="p">{</span><span class="n">sat</span><span class="p">}</span>       <span class="p">{</span><span class="n">sun</span><span class="p">}</span>

                                                          <span class="p">{}</span>
</pre></div>
</div>
<p>Think of propositions that have meanings in each of these universes, e.g., for
universe <code class="docutils literal"><span class="pre">U2</span></code>, say that <code class="docutils literal"><span class="pre">P</span></code> is &#8220;Burger King is open today&#8221; and
<code class="docutils literal"><span class="pre">[[P]]</span> <span class="pre">=</span> <span class="pre">{wkday,sat}</span></code>; and say that <code class="docutils literal"><span class="pre">Q</span></code> is
&#8220;Burger King stays open late today&#8221; and <code class="docutils literal"><span class="pre">[[Q]]</span> <span class="pre">=</span> <span class="pre">{sat}</span></code>.
Now compute the semantics of <code class="docutils literal"><span class="pre">P</span> <span class="pre">^</span> <span class="pre">Q</span></code>, <code class="docutils literal"><span class="pre">~P</span></code>, <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code>
(it&#8217;s <code class="docutils literal"><span class="pre">{sat,sun}</span></code>!), <code class="docutils literal"><span class="pre">Q</span> <span class="pre">--&gt;</span> <span class="pre">P</span></code>, etc.</p>
<p>The universe, <code class="docutils literal"><span class="pre">U0</span> <span class="pre">=</span> <span class="pre">{1}</span></code>, generates the truth-table semantics of propositional
logic. (True is <code class="docutils literal"><span class="pre">{1}</span></code> and False is <code class="docutils literal"><span class="pre">{}</span></code>.)
Truth tables are a special case of Boolean-lattice semantics.</p>
</div>
</div>
<div class="section" id="data-structures-as-meanings-heyting-lattices">
<h3>7.9.3. Data Structures as Meanings; Heyting Lattices<a class="headerlink" href="#data-structures-as-meanings-heyting-lattices" title="Permalink to this headline">¶</a></h3>
<p>If we believe that the claim, <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span> <span class="pre">-||-</span> <span class="pre">Q</span> <span class="pre">v</span> <span class="pre">~P</span></code>, is too strong, then we
can back away from it by discarding the <code class="docutils literal"><span class="pre">Pbc</span></code> rule.
In this case, the equivalence breaks, and implication <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code> is now
distinct from <code class="docutils literal"><span class="pre">Q</span> <span class="pre">v</span> <span class="pre">~P</span></code> and also from <code class="docutils literal"><span class="pre">~(P</span> <span class="pre">^</span> <span class="pre">~Q)</span></code>.
This is a high price to pay, because it means <code class="docutils literal"><span class="pre">~~P</span></code> is no longer equivalent to
<code class="docutils literal"><span class="pre">P</span></code> and we can no longer prove <code class="docutils literal"><span class="pre">|-</span> <span class="pre">P</span> <span class="pre">v</span> <span class="pre">~P</span></code>.
It also means we cannot use the truth-table or Boolean-lattice models.
But the models we use instead give us insight into the meanings of implication
and negation and even tie the meaning of symbolic logic to computer programs.</p>
<div class="section" id="the-meaning-of-a-proposition-is-a-program">
<h4>The Meaning of a Proposition is a Program<a class="headerlink" href="#the-meaning-of-a-proposition-is-a-program" title="Permalink to this headline">¶</a></h4>
<p>When we program, we think in terms of data types.
For example, <code class="docutils literal"><span class="pre">3</span></code> has data type <code class="docutils literal"><span class="pre">int</span></code>, <code class="docutils literal"><span class="pre">&quot;abc&quot;</span></code> has type string, and so on.
For languages that use compilers (C#, Java, SML, etc.), the compiler will check
that data values are used consistently with their data types (e.g., adding an
int to a float is OK, but one cannot add a string to an array).</p>
<p>Perhaps you noted that the <code class="docutils literal"><span class="pre">^i</span></code> rule is a kind of pairing rule: <code class="docutils literal"><span class="pre">^i</span></code> pairs a
proof of <code class="docutils literal"><span class="pre">P</span></code> and a proof of <code class="docutils literal"><span class="pre">Q</span></code> to make a proof of <code class="docutils literal"><span class="pre">P</span> <span class="pre">^</span> <span class="pre">Q</span></code>.
We can make pairs in Python, like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;abc&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">p</span></code> is a pair of data type <code class="docutils literal"><span class="pre">int</span> <span class="pre">^</span> <span class="pre">string</span></code>!
We index the pair like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">print</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>   <span class="c1"># prints   3 &quot;abc&quot;</span>
</pre></div>
</div>
<p>The indexing looks like what we do with the <code class="docutils literal"><span class="pre">^e</span></code> rules.
(By the way, C# uses <a href="#id47"><span class="problematic" id="id48">``</span></a>Tuple``s to construct such pairs.)</p>
<p>There is also a coincidence between functions and the rules for implication.
When we prove <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code> with <code class="docutils literal"><span class="pre">--&gt;i</span></code>, we use an assumption, <code class="docutils literal"><span class="pre">P</span></code>, to prove
<code class="docutils literal"><span class="pre">Q</span></code>.
In Python, we build functions that take parameters (&#8220;assumptions&#8221;) to return
answers, e.g.,</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>        <span class="c1"># pre:   s  has data type  string</span>
   <span class="n">ans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1">#   calculate the length of string  s</span>
   <span class="k">return</span>  <span class="n">ans</span>   <span class="c1"># post:  ans has data type  int</span>
</pre></div>
</div>
<p>This function has as its data type, <code class="docutils literal"><span class="pre">string</span> <span class="pre">--&gt;</span> <span class="pre">int</span></code>.
C# force us to declare the types:</p>
<div class="highlight-c#"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// f&#39;s data type is  string --&gt; int</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The code shows how to use a value of type <code class="docutils literal"><span class="pre">string</span></code> to construct a value of
type <code class="docutils literal"><span class="pre">int</span></code>.
In general, a function that takes an argument of data type <code class="docutils literal"><span class="pre">P</span></code> to construct an
answer of type <code class="docutils literal"><span class="pre">Q</span></code> has data type, <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code>.</p>
<p>When we call such a function, by supplying an argument of data type, <code class="docutils literal"><span class="pre">P</span></code>, we
get in return an answer of type <code class="docutils literal"><span class="pre">Q</span></code> (e.g., <code class="docutils literal"><span class="pre">f(&quot;abc&quot;)</span></code> for the above
function).
This is the same as applying the <code class="docutils literal"><span class="pre">--&gt;e</span></code>-rule to a proof of type <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code>
and a proof of type <code class="docutils literal"><span class="pre">P</span></code> to get a proof of type <code class="docutils literal"><span class="pre">Q</span></code> as the answer.</p>
<p>There is a general principle here: the meaning of a proposition need not be a
true-false value or a set of contexts but a <em>program</em>, and <em>a proposition is a
fact exactly when we construct a program that has the proposition as its data
type</em>.
For example, the pair, <code class="docutils literal"><span class="pre">(3,</span> <span class="pre">&quot;abc&quot;)</span></code>, is evidence that <code class="docutils literal"><span class="pre">int</span> <span class="pre">^</span> <span class="pre">string</span></code> is a
fact &#8211; can be built.
This is an adventurous turn that connects logic with programming.
It is called the <em>Heyting interpretation</em> of logic.</p>
<p>The previous paragraph suggests that whenever we write a proof in logic, we are
building a program, and whenever we are building a program, we are writing a
logic proof!
Here&#8217;s an example of a proof and the C# program that is constructed from the
proof:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">p</span> <span class="o">^</span> <span class="n">q</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">r</span><span class="p">,</span>  <span class="n">q</span>  <span class="o">|-</span>   <span class="n">p</span> <span class="o">--&gt;</span> <span class="n">r</span>

<span class="mf">1.</span> <span class="p">(</span><span class="n">p</span> <span class="o">^</span> <span class="n">q</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">r</span>   <span class="n">premise</span>
<span class="mf">2.</span>  <span class="n">q</span>             <span class="n">premise</span>
<span class="o">+---------------------------------</span>
<span class="o">|</span>  <span class="mf">3.</span>  <span class="n">p</span>          <span class="n">assumption</span>
<span class="o">|</span>  <span class="mf">4.</span>  <span class="n">p</span> <span class="o">^</span> <span class="n">q</span>      <span class="o">^</span><span class="n">i</span> <span class="mi">3</span><span class="p">,</span><span class="mi">2</span>
<span class="o">|</span>  <span class="mf">5.</span>  <span class="n">r</span>          <span class="o">-&gt;</span><span class="n">e</span> <span class="mi">1</span><span class="p">,</span><span class="mi">4</span>
<span class="o">+--------------------------------</span>
<span class="mf">6.</span>  <span class="n">p</span> <span class="o">-&gt;</span> <span class="n">r</span>        <span class="o">-&gt;</span><span class="n">i</span> <span class="mi">3</span><span class="o">-</span><span class="mi">5</span>
</pre></div>
</div>
<p>The above proof is a program &#8211; To see why, let:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">p</span>  <span class="o">==</span>  <span class="nb">int</span>
<span class="n">q</span>  <span class="o">==</span>  <span class="n">string</span>
<span class="n">r</span>  <span class="o">==</span>  <span class="nb">bool</span>
</pre></div>
</div>
<p>Then, from the library components (global variables):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>    <span class="n">public</span> <span class="nb">bool</span> <span class="n">doStuff</span><span class="p">(</span><span class="nb">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">string</span> <span class="n">y</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="nb">int</span> <span class="o">^</span> <span class="n">string</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="nb">bool</span><span class="p">,</span>
<span class="ow">and</span>
    <span class="n">string</span> <span class="n">data</span>                          <span class="o">//</span>  <span class="n">string</span>
</pre></div>
</div>
<p>we built this program, <code class="docutils literal"><span class="pre">public</span> <span class="pre">bool</span> <span class="pre">myProc(int</span> <span class="pre">z)</span></code>
(of &#8220;type&#8221; <code class="docutils literal"><span class="pre">int</span> <span class="pre">--&gt;</span> <span class="pre">bool</span></code>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>                                       // 1. presume  doStuff  is a global var
                                       // 2. presume  data  is a global var
public bool myProc(int z) {            //    3. assume you have an int param,  z
    Tuple&lt;int,string&gt; args = (z, data) //    4. introduce a pair/tuple (^i)
    bool ans = doStuff(args)           //    5. call doStuff with the pair (-&gt;e)
    return ans                         //       and get the bool,  ans
}                                      // 6. end function def (-&gt;i)
</pre></div>
</div>
<p>(Notice how we use names, like <code class="docutils literal"><span class="pre">doStuff</span></code>, <code class="docutils literal"><span class="pre">args</span></code>, and <code class="docutils literal"><span class="pre">ans</span></code>, and
assignments in place of &#8220;line numbers&#8221; in the program/proof.)</p>
<p>The key lies in the data typing: the data types of the C# phrases are the
propositions that are proved on each line.
The lines of the program are lines of a proof.
The type checker for C# extracts the types and constructs a logic proof when it
does type checking!</p>
<p>Here is a summary of how propositions match to program code:</p>
<ul>
<li><p class="first"><em>primitive propositions/data types</em>:
Types <code class="docutils literal"><span class="pre">int</span></code>, <code class="docutils literal"><span class="pre">string</span></code>, etc. are primitive propositions/data types.
We have that <code class="docutils literal"><span class="pre">0:</span> <span class="pre">int</span></code> (read as, <code class="docutils literal"><span class="pre">0</span></code> has type <code class="docutils literal"><span class="pre">int</span></code>), <code class="docutils literal"><span class="pre">1:</span> <span class="pre">int</span></code>, etc.,
as well as <code class="docutils literal"><span class="pre">&quot;abc&quot;:</span> <span class="pre">string</span></code>, <code class="docutils literal"><span class="pre">&quot;&quot;:</span> <span class="pre">string</span></code>, etc.
It is ok to name the value, e.g.,</p>
<div class="highlight-c#"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</pre></div>
</div>
<p>constructs an <code class="docutils literal"><span class="pre">int</span></code>.
We say that <code class="docutils literal"><span class="pre">0</span></code> &#8220;proves&#8221; or &#8220;constructs&#8221; or &#8220;witnesses&#8221; <code class="docutils literal"><span class="pre">int</span></code>.</p>
</li>
<li><p class="first"><em>conjunction/pair type</em>:
A pair is built and indexed like this in Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="k">print</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>   <span class="c1"># prints   3 &quot;abc&quot;</span>
</pre></div>
</div>
<p>(C# uses <code class="docutils literal"><span class="pre">Tuple``s.)</span> <span class="pre">``p</span></code> witnesses/proves <code class="docutils literal"><span class="pre">int</span> <span class="pre">^</span> <span class="pre">string</span></code>.
Pairing, <code class="docutils literal"><span class="pre">(,)</span></code>, acts like <code class="docutils literal"><span class="pre">^i</span></code>, and indexing (<code class="docutils literal"><span class="pre">[0]</span></code> and <code class="docutils literal"><span class="pre">[1]</span></code>) act
like <code class="docutils literal"><span class="pre">^e1</span></code> and <code class="docutils literal"><span class="pre">^e2</span></code>.</p>
</li>
<li><p class="first"><em>disjunction/variant type</em>: Some languages (Pascal, Algol68, SML) let you
define a union or variant type, <code class="docutils literal"><span class="pre">int</span> <span class="pre">+</span> <span class="pre">string</span></code> (<code class="docutils literal"><span class="pre">int</span> <span class="pre">v</span> <span class="pre">string</span></code>), which
combines the values from the two types into a new type.
The values in the unioned type are &#8220;tagged&#8221; to show their origin.</p>
<p>In C#, we use enumerations to construct variant values:</p>
<div class="highlight-c#"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">Time</span> <span class="p">{</span> <span class="n">AM</span><span class="p">,</span> <span class="n">PM</span> <span class="p">};</span>
<span class="n">Tuple</span><span class="p">&lt;</span><span class="n">Time</span><span class="p">,</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">t</span> <span class="p">=</span> <span class="p">(</span><span class="n">Time</span><span class="p">.</span><span class="n">AM</span><span class="p">,</span> <span class="m">945</span><span class="p">);</span>   <span class="c1">// a variant value of &quot;type&quot;  AM v PM</span>

<span class="k">enum</span> <span class="n">Suit</span> <span class="p">{</span> <span class="n">Spades</span><span class="p">,</span> <span class="n">Hearts</span><span class="p">,</span> <span class="n">Diamonds</span><span class="p">,</span> <span class="n">Clubs</span> <span class="p">};</span>
<span class="n">Tuple</span><span class="p">&lt;</span><span class="n">Suit</span><span class="p">,</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">card</span> <span class="p">=</span> <span class="p">(</span><span class="n">Suit</span><span class="p">.</span><span class="n">Hearts</span><span class="p">,</span> <span class="s">&quot;Queen&quot;</span><span class="p">);</span>   <span class="c1">// a variant value of type  Spades v ... v Clubs</span>
</pre></div>
</div>
<p>We simulate a variant type in Python as a pair, e.g., <code class="docutils literal"><span class="pre">(&quot;AM&quot;,</span> <span class="pre">945)</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">vi</span></code> rules construct variant values, and the <code class="docutils literal"><span class="pre">ve</span></code> rule is an if- or
switch-command that asks about the variant part.
Indeed, the classic if-command is just the <code class="docutils literal"><span class="pre">ve</span></code> rule for this enumeration:</p>
<div class="highlight-c#"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">true</span><span class="p">,</span> <span class="k">false</span> <span class="p">};</span>
</pre></div>
</div>
</li>
<li><p class="first"><em>implication/function type</em>: A function that takes an argument of type <code class="docutils literal"><span class="pre">P</span></code>
and returns an answer of type <code class="docutils literal"><span class="pre">Q</span></code> has data type, <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code>.
We&#8217;ve already seen examples of functions and how they are defined and called.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">_|_</span></code>/<em>exception type</em>: A program error (exception) stops a program with no
answer &#8211; no value at all!
In Python, this is coded as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">raise</span> <span class="ne">Exception</span>
</pre></div>
</div>
<p>The data type of &#8220;no answer&#8221; is <code class="docutils literal"><span class="pre">_|_</span></code>, and the <code class="docutils literal"><span class="pre">_|_e</span></code>-rule is an
&#8220;exception handler&#8221; that lets us recover from an exception by inserting any
value we wish of any type at all.
In Python, the <code class="docutils literal"><span class="pre">_|_e</span></code>-rule is coded like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="o">...</span> <span class="k">raise</span> <span class="ne">Exception</span> <span class="o">...</span>  <span class="c1"># a ``contradiction&#39;&#39;</span>
<span class="k">except</span><span class="p">:</span>                      <span class="c1"># traps the error and recovers</span>
    <span class="o">...</span><span class="n">any</span> <span class="n">value</span> <span class="n">we</span> <span class="n">wish</span> <span class="n">of</span> <span class="nb">any</span> <span class="nb">type</span> <span class="n">at</span> <span class="nb">all</span><span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<p>Using these techniques, we can translate any proof in propositional logic into a
program and any program into a proof.
<em>The meaning of a proposition is the set of all the programs that have that
proposition as its data type.</em></p>
<p>To finish this development, we treat <code class="docutils literal"><span class="pre">~P</span></code> as an abbreviation for <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">_|_</span></code>
&#8211; <code class="docutils literal"><span class="pre">~P</span></code> is a computer function that does <code class="docutils literal"><span class="pre">raise</span> <span class="pre">Exception</span></code> if it is ever
called with a <code class="docutils literal"><span class="pre">P</span></code> data structure as its argument!
In this way, both <code class="docutils literal"><span class="pre">P</span></code> and <code class="docutils literal"><span class="pre">~P</span></code> cannot participate together in a useful
computation &#8211; an exception gets raised.</p>
<p>With the above understanding &#8212; the Heyting interpretation &#8212; of the rules,
<code class="docutils literal"><span class="pre">^i</span></code>, <code class="docutils literal"><span class="pre">^e</span></code>, <code class="docutils literal"><span class="pre">vi</span></code>, <code class="docutils literal"><span class="pre">ve</span></code>, <code class="docutils literal"><span class="pre">--&gt;i</span></code>, <code class="docutils literal"><span class="pre">--&gt;e</span></code>, and <code class="docutils literal"><span class="pre">_|_e</span></code> (note that the
<code class="docutils literal"><span class="pre">~e</span></code> and <code class="docutils literal"><span class="pre">~i</span></code> rules are unnecessary when we treat <code class="docutils literal"><span class="pre">~P</span></code> as <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">_|_</span></code>),
we have</p>
<ul class="simple">
<li><em>soundness</em>: for every proof we make, <code class="docutils literal"><span class="pre">P1,</span> <span class="pre">P2,</span> <span class="pre">...</span> <span class="pre">|-</span> <span class="pre">Q</span></code>, there is a
computer program of data type <code class="docutils literal"><span class="pre">Q</span></code> that is assembled from phrases of types
<code class="docutils literal"><span class="pre">P1,</span> <span class="pre">P2,</span> <span class="pre">...</span></code>;</li>
<li><em>completeness</em>: whenever we build a program of data type <code class="docutils literal"><span class="pre">Q</span></code> using input
variables <code class="docutils literal"><span class="pre">P1,</span> <span class="pre">P2,</span> <span class="pre">...</span></code> and the above constructions, there is a proof we can
build by type checking the program, that is, by imitating the program&#8217;s
structure with deduction rules.
The proof proves <code class="docutils literal"><span class="pre">P1,</span> <span class="pre">P2,</span> <span class="pre">...</span> <span class="pre">|-</span> <span class="pre">Q</span></code>.</li>
</ul>
<p>In this reading, programming and logic are the &#8220;same thing&#8221;.</p>
<p>Notice that the assignment command is missing from the above explanation.
Assignment is used to name phrases, so assignments act as the &#8220;line numbers&#8221; of
proofs.
But loops and recursive functions are missing, too.
Propositional logic is not expressive enough by itself to represent repetitive
computation.
But when we move to predicate logic (and study the programming language Prolog),
we will express this feature by means of &#8220;recursively defined propositions&#8221;.</p>
<p>The ideas in this section are often used to define the type-checking laws for a
modern programming language.
The constructions of the language are written in inference-rule form, and a
compiler&#8217;s type checker is a proof-checker that checks that a program is
correctly written according to the inference rules.
In this way, a modern programming language is a logic, like the one we studied
in this chapter, and when we are writing a program, we are writing a proof in
the program&#8217;s &#8220;typed-syntax logic&#8221;.
There are many scholarly texts that show how one designs and uses languages in
this way.</p>
</div>
<div class="section" id="heyting-lattices">
<h4>Heyting Lattices<a class="headerlink" href="#heyting-lattices" title="Permalink to this headline">¶</a></h4>
<p>Perhaps would like to see a lattice model for the deduction rules less <code class="docutils literal"><span class="pre">Pbc</span></code>.
The needed structure is a <em>Heyting lattice</em>.</p>
<p>A key property of a Boolean lattice, <code class="docutils literal"><span class="pre">P(U)</span></code>, generated from universe set
<code class="docutils literal"><span class="pre">U</span></code>, is that every set, <code class="docutils literal"><span class="pre">S</span></code> in <code class="docutils literal"><span class="pre">P(U)</span></code>, has as its complement, <code class="docutils literal"><span class="pre">U</span> <span class="pre">-</span> <span class="pre">S</span></code>.
This justifies the claim that <code class="docutils literal"><span class="pre">P</span> <span class="pre">-||-</span> <span class="pre">~~P</span></code> and supports the <code class="docutils literal"><span class="pre">Pbc</span></code> rule.</p>
<p>The absence of <code class="docutils literal"><span class="pre">Pbc</span></code> as a sound reasoning rule means that we can use lattice
models that lack a set-complement operation, that is, the model no longer needs
to hold all possible subsets of <code class="docutils literal"><span class="pre">U</span></code> as contexts and this means for some sets,
<code class="docutils literal"><span class="pre">S</span></code>, in the lattice, <code class="docutils literal"><span class="pre">U</span> <span class="pre">-</span> <span class="pre">S</span></code> does not exist.</p>
<p>A lattice that has fewer sets in it than the powerset lattice, <code class="docutils literal"><span class="pre">P(U)</span></code>, and can
support the following operations is called a <em>Heyting lattice</em>.
(Note: the explanation that follows is simplified but conveys the key ideas.)</p>
<ol class="arabic">
<li><p class="first"><code class="docutils literal"><span class="pre">{}</span></code> exists in the lattice.</p>
</li>
<li><p class="first">For all sets <code class="docutils literal"><span class="pre">P</span></code> and <code class="docutils literal"><span class="pre">Q</span></code>, both <code class="docutils literal"><span class="pre">P</span> <span class="pre">union</span> <span class="pre">Q</span></code> and <code class="docutils literal"><span class="pre">P</span> <span class="pre">intersection</span> <span class="pre">Q</span></code>
exist in the lattice.</p>
</li>
<li><p class="first">For all sets <code class="docutils literal"><span class="pre">P</span></code> and <code class="docutils literal"><span class="pre">Q</span></code>, there is a set, <code class="docutils literal"><span class="pre">R</span></code>, such that</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">P</span></code> intersection <code class="docutils literal"><span class="pre">R</span></code> is a subset of <code class="docutils literal"><span class="pre">Q</span></code></li>
<li>for all other sets, <code class="docutils literal"><span class="pre">W</span></code>, such that <code class="docutils literal"><span class="pre">P</span></code> intersection <code class="docutils literal"><span class="pre">W</span></code> is a subset
of <code class="docutils literal"><span class="pre">Q</span></code>, <code class="docutils literal"><span class="pre">W</span></code> is a subset of <code class="docutils literal"><span class="pre">R</span></code>.</li>
</ul>
<p>That is, <code class="docutils literal"><span class="pre">R</span></code> is the <em>largest</em> set in the lattice such that <code class="docutils literal"><span class="pre">P</span></code>
intersection <code class="docutils literal"><span class="pre">R</span></code> is a subset of <code class="docutils literal"><span class="pre">Q</span></code>.
The set, <code class="docutils literal"><span class="pre">R</span></code>, is named <code class="docutils literal"><span class="pre">P</span></code> implies <code class="docutils literal"><span class="pre">Q</span></code>.</p>
</li>
</ol>
<p>Again, think of a Heyting lattice as a collection of context sets but the
set-complement of a context set is not always defined.
Here is the new semantics of propositional logic:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>[[ P ]]       = the set of contexts in which  P  is a fact (just like before)

[[ P ^ Q ]]   = [[ P ]] intersection [[ Q ]]

[[ P v Q ]]   = [[ P ]] union [[ Q ]]


[[ P --&gt; Q ]] = [[ P ]] implies [[ Q ]],
                 that is, the largest set, R, of contexts, such that
                 R intersection [[ P ]] ⊆ [[ Q ]]

[[ _|_ ]]     = {}
</pre></div>
</div>
<p>Negation is an abbreviation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span> <span class="o">~</span><span class="n">P</span> <span class="p">]]</span>      <span class="o">=</span> <span class="p">[[</span> <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span> <span class="p">]],</span>
                 <span class="n">that</span> <span class="ow">is</span><span class="p">,</span> <span class="n">the</span> <span class="n">largest</span> <span class="nb">set</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">of</span> <span class="n">contexts</span><span class="p">,</span> <span class="n">such</span> <span class="n">that</span>
                             <span class="n">R</span> <span class="n">intersection</span> <span class="p">[[</span> <span class="n">P</span> <span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
                 <span class="n">that</span> <span class="ow">is</span><span class="p">,</span> <span class="n">the</span> <span class="n">largest</span> <span class="nb">set</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">that</span> <span class="ow">is</span> <span class="n">disjoint</span> <span class="kn">from</span>  <span class="p">[[</span><span class="n">P</span><span class="p">]]</span>
</pre></div>
</div>
<p>With substantial work, one can prove soundness and completeness for the
deduction rules less <code class="docutils literal"><span class="pre">Pbc</span></code> for Heyting lattices.</p>
<p>Heyting lattices can express real-life contexts &#8211; think of possible weather
situations:
There might be <code class="docutils literal"><span class="pre">sun</span></code>, <code class="docutils literal"><span class="pre">clouds</span></code>, or <code class="docutils literal"><span class="pre">wetNclouds</span></code> (and if it&#8217;s wet, then
there must be clouds, too!)
Here is a lattice of combinations of these options:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>             <span class="p">{</span><span class="n">sun</span><span class="p">,</span> <span class="n">clouds</span><span class="p">}</span>
              <span class="o">/</span>       \
  <span class="p">{</span><span class="n">sun</span><span class="p">,</span> <span class="n">wetNclouds</span><span class="p">}</span>  <span class="p">{</span><span class="n">clouds</span><span class="p">}</span>
    <span class="o">/</span>         \      <span class="o">/</span>
<span class="p">{</span><span class="n">sun</span><span class="p">}</span>      <span class="p">{</span><span class="n">wetNclouds</span><span class="p">}</span>
     \    <span class="o">/</span>
       <span class="p">{}</span>
</pre></div>
</div>
<p><em>Some combinations are missing</em>.
(<code class="docutils literal"><span class="pre">{clouds}</span></code> means the same thing as <code class="docutils literal"><span class="pre">{clouds,</span> <span class="pre">wetNclouds}</span></code> &#8212; &#8220;clouds or
wet-and-clouds&#8221;.)
We have these semantics:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">clear</span> <span class="p">]]</span>                      <span class="o">=</span> <span class="p">{</span><span class="n">sun</span><span class="p">}</span>
<span class="p">[[</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">raining</span> <span class="p">]]</span>                    <span class="o">=</span> <span class="p">{</span><span class="n">wetNclouds</span><span class="p">}</span>
<span class="p">[[</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">overcast</span> <span class="p">]]</span>                   <span class="o">=</span> <span class="p">{</span><span class="n">clouds</span><span class="p">}</span>

<span class="p">[[</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">clear</span> <span class="n">v</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">overcast</span> <span class="p">]]</span>     <span class="o">=</span> <span class="p">{</span><span class="n">sun</span><span class="p">,</span> <span class="n">clouds</span><span class="p">}</span>
<span class="p">[[</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">clear</span> <span class="o">^</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">overcast</span> <span class="p">]]</span>     <span class="o">=</span> <span class="p">{}</span>
<span class="p">[[</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">overcast</span> <span class="o">^</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">raining</span> <span class="p">]]</span>   <span class="o">=</span> <span class="p">{</span><span class="n">wetNclounds</span><span class="p">},</span>  <span class="n">which</span> <span class="ow">is</span>  <span class="p">{</span><span class="n">clouds</span><span class="p">}</span> <span class="n">intersect</span> <span class="p">{</span><span class="n">wetNclouds</span><span class="p">}</span>
<span class="p">[[</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">raining</span> <span class="n">v</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">overcast</span> <span class="p">]]</span>   <span class="o">=</span> <span class="p">{</span><span class="n">clouds</span><span class="p">},</span> <span class="n">which</span> <span class="ow">is</span>  <span class="p">{</span><span class="n">clouds</span><span class="p">}</span> <span class="n">union</span> <span class="p">{</span><span class="n">wetNclouds</span><span class="p">}</span>

<span class="p">[[</span> <span class="o">~</span><span class="p">(</span><span class="n">It</span> <span class="ow">is</span> <span class="n">raining</span><span class="p">)</span> <span class="p">]]</span>                 <span class="o">=</span> <span class="p">{</span><span class="n">sun</span><span class="p">},</span>   <span class="n">which</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">largest</span> <span class="nb">set</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">such</span> <span class="n">that</span>  <span class="n">R</span> <span class="n">intersect</span> <span class="p">{</span><span class="n">wetNclounds</span><span class="p">}</span> <span class="o">=</span> <span class="p">{}</span>
<span class="p">[[</span> <span class="o">~</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">It</span> <span class="ow">is</span> <span class="n">raining</span><span class="p">)</span> <span class="p">]]</span>               <span class="o">=</span> <span class="p">{</span><span class="n">clouds</span><span class="p">}</span>

<span class="p">[[</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">clear</span> <span class="o">--&gt;</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">raining</span> <span class="p">]]</span>    <span class="o">=</span> <span class="p">{},</span>   <span class="n">because</span> <span class="n">no</span> <span class="n">context</span> <span class="n">makes</span> <span class="n">this</span> <span class="n">true</span>
<span class="p">[[</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">raining</span> <span class="o">--&gt;</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">overcast</span> <span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="n">sun</span><span class="p">,</span> <span class="n">clouds</span><span class="p">},</span>  <span class="n">because</span> <span class="n">the</span> <span class="n">claim</span> <span class="n">holds</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">largest</span> <span class="n">possible</span> <span class="n">context</span> <span class="nb">set</span>
</pre></div>
</div>
<p>Any finite, distributive lattice is a Heyting lattice.
Such lattices appear in data-flow analyzers in compilers.
Every Boolean lattice is a Heyting lattice, but there are Heyting lattices that
are not Boolean lattices (e.g., above).</p>
</div>
</div>
<div class="section" id="possible-worlds-kripke-structures">
<h3>7.9.4. Possible-Worlds (Kripke) Structures<a class="headerlink" href="#possible-worlds-kripke-structures" title="Permalink to this headline">¶</a></h3>
<p>Here are two questions for which no one knows the answer:</p>
<ol class="arabic">
<li><p class="first"><em>Goldbach&#8217;s conjecture</em>: Every even integer larger than 2 is the sum of two
primes.
(For example, 4 = 2+2, 6 = 3+3, 8 = 5+3, 10 = 7+3, etc.)
Even-valued integers up to 10 <sup>18</sup> have been checked, and all satisfy
Goldbach&#8217;s conjecture.
But no one has stated a proof that the conjecture holds for all even
integers.</p>
</li>
<li><p class="first"><em>Collatz&#8217;s conjecture</em>: This program terminates for all integer inputs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">()</span>
<span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">:</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">else</span> <span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">print</span> <span class="n">n</span>
</pre></div>
</div>
<p>The program has been tested with integers up to about 10 <sup>18</sup> as well,
with successful termination.
But no one has stated a proof that the conjecture holds for all integers.</p>
</li>
</ol>
<p>Goldbach&#8217;s conjecture and Collatz&#8217;s conjecture are open, unsolved problems;
they are not known to be facts or falsities as of today.
We cannot claim <code class="docutils literal"><span class="pre">Goldbach</span> <span class="pre">v</span> <span class="pre">~Goldbach</span></code> as of today &#8211; we just don&#8217;t know.
If we accept the <code class="docutils literal"><span class="pre">Pbc</span></code> rule, which lets us prove
<code class="docutils literal"><span class="pre">|-</span> <span class="pre">Goldbach</span> <span class="pre">v</span> <span class="pre">~Goldbach</span></code>, then we have a practical problem:
Is Goldbach&#8217;s conjecture proved True or is it proved False?
The &#8220;proof&#8221; of <code class="docutils literal"><span class="pre">|-</span> <span class="pre">Goldbach</span> <span class="pre">v</span> <span class="pre">~Goldbach</span></code> is impractical &#8211;
it is a claim empty of content.
Maybe someday in the future someone will prove or disprove Goldbach&#8217;s
conjecture.</p>
<p>A possible-worlds (Kripke) model gives meaning to propositions with respect to
the <em>passage of time</em>.
For each point in time, there is a sets listing those primitive facts that are
known at that specific time.
The sets are organized with regards to the passage of time, so that a fact known
at time <code class="docutils literal"><span class="pre">n</span></code> holds for all future times, <code class="docutils literal"><span class="pre">m</span> <span class="pre">&gt;</span> <span class="pre">n</span></code>, as well.
And, as time passes, we discover new primitive facts, so that the sets grow in
size.</p>
<p>In this formulation, <code class="docutils literal"><span class="pre">P</span> <span class="pre">^</span> <span class="pre">Q</span></code>, at time <code class="docutils literal"><span class="pre">n</span></code>, is understood as saying,
&#8220;both <code class="docutils literal"><span class="pre">P</span></code> and <code class="docutils literal"><span class="pre">Q</span></code> are known to be facts as of now (time <code class="docutils literal"><span class="pre">n</span></code>) and from now
on (times <code class="docutils literal"><span class="pre">m</span> <span class="pre">&gt;</span> <span class="pre">n</span></code>)&#8221;.
<code class="docutils literal"><span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q</span></code> means &#8220;<code class="docutils literal"><span class="pre">P</span></code> is known to be a fact, or <code class="docutils literal"><span class="pre">Q</span></code> is known to be a fact as
of now and from now on&#8221;.
<code class="docutils literal"><span class="pre">~P</span></code> means &#8220;<code class="docutils literal"><span class="pre">P</span></code> is not a fact now and <em>will never be in the future</em>&#8221;.
That is, we know it is impossible for <code class="docutils literal"><span class="pre">P</span></code> to ever be known as a fact.</p>
<p><code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code> is understood as saying, &#8220;if <code class="docutils literal"><span class="pre">P</span></code> is ever discovered as a fact now
or at any time in the future, we will find <code class="docutils literal"><span class="pre">Q</span></code> as a fact at that very same
time&#8221;.
In this way, <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code> can be a fact before <code class="docutils literal"><span class="pre">P</span></code> is uncovered as a fact.</p>
<p>Also, there are times when we cannot establish <code class="docutils literal"><span class="pre">P</span></code> and we cannot establish
<code class="docutils literal"><span class="pre">~P</span></code> either.
This might be the case at the start of time, where we know (almost) no facts at
all.
Or, it might be as of today, with respect to Goldbach&#8217;s and Collatz&#8217;s
conjectures.</p>
<p>In the possible-worlds model, <em>the meaning of a proposition is the times when
the proposition is known as a fact</em>.
The possible-worlds model is sound and complete for our deduction rules less
<code class="docutils literal"><span class="pre">Pbc</span></code>. (With some work, we can extract a Heyting lattice.)</p>
<p>A possible-worlds (Kripke) model shows all of time, including the present time
and all possible future times.
For example, say that we work in a propositional logic where there are three
primitive propositions, <code class="docutils literal"><span class="pre">G</span></code> (stands for &#8220;Goldbach&#8217;s conjective holds&#8221;),
<code class="docutils literal"><span class="pre">C</span></code> (stands for &#8220;Collatz&#8217;s conjecture holds&#8221;), and B (&#8220;Bush is president&#8221;).
Here is a Kripke model that shows how time might unfold with regards to these
three primitive propositions: (In the picture, time moves from left to right.)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>      <span class="o">+--</span><span class="n">b</span><span class="p">:{</span><span class="n">C</span><span class="p">}</span><span class="o">--+-----</span><span class="n">c</span><span class="p">:{</span><span class="n">C</span><span class="p">,</span><span class="n">G</span><span class="p">}</span>
      <span class="o">|</span>         <span class="o">|</span>
<span class="n">a</span><span class="p">:{</span> <span class="p">}</span><span class="o">-+</span>         <span class="o">+----</span><span class="n">d</span><span class="p">:{</span><span class="n">C</span><span class="p">}</span>
      <span class="o">|</span>
      <span class="o">+------------</span><span class="n">e</span><span class="p">:{</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">}</span>
</pre></div>
</div>
<p>The model says, at the start of time, <code class="docutils literal"><span class="pre">a</span></code>, we know neither <code class="docutils literal"><span class="pre">C</span></code> nor <code class="docutils literal"><span class="pre">G</span></code> nor
<code class="docutils literal"><span class="pre">B</span></code>.
In one future, <code class="docutils literal"><span class="pre">b</span></code>, we discover <code class="docutils literal"><span class="pre">C</span></code>, in another possible future, <code class="docutils literal"><span class="pre">e</span></code>, we
discover <code class="docutils literal"><span class="pre">G</span></code> and <code class="docutils literal"><span class="pre">B</span></code>.
From <code class="docutils literal"><span class="pre">b</span></code>, we might progress to futures <code class="docutils literal"><span class="pre">c</span></code> or <code class="docutils literal"><span class="pre">d</span></code>.
Futures <code class="docutils literal"><span class="pre">c</span></code>, <code class="docutils literal"><span class="pre">d</span></code>, and <code class="docutils literal"><span class="pre">e</span></code> mark the end of time.
(It is of course acceptable to have Kripke structures that allow time to run
forever!)
At time <code class="docutils literal"><span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">C</span></code> is not a fact, nor is <code class="docutils literal"><span class="pre">~C</span></code>.
But at time <code class="docutils literal"><span class="pre">b</span></code>, <code class="docutils literal"><span class="pre">C</span></code> is a fact. Also at <code class="docutils literal"><span class="pre">b</span></code>, <code class="docutils literal"><span class="pre">~B</span></code> is a fact <em>because it
is impossible for</em> <code class="docutils literal"><span class="pre">B</span></code> <em>to be discovered at any future reachable from</em> <code class="docutils literal"><span class="pre">b</span></code>.
So, at <code class="docutils literal"><span class="pre">b</span></code>, <code class="docutils literal"><span class="pre">C</span> <span class="pre">^</span> <span class="pre">~B</span></code> is a fact.
Also at <code class="docutils literal"><span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">B</span> <span class="pre">--&gt;</span> <span class="pre">G</span></code> is a fact, because at all futures reachable from
<code class="docutils literal"><span class="pre">a</span></code>, whenever <code class="docutils literal"><span class="pre">B</span></code> appears, <code class="docutils literal"><span class="pre">G</span></code> does also.</p>
<p>To summarize, here are the meanings of some propositions in the above Kripke
model:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span> <span class="n">C</span> <span class="p">]]</span>       <span class="o">=</span> <span class="p">{</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">}</span>

<span class="p">[[</span> <span class="o">~</span><span class="n">B</span> <span class="p">]]</span>      <span class="o">=</span> <span class="p">{</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">}</span>

<span class="p">[[</span> <span class="n">C</span> <span class="o">^</span> <span class="o">~</span><span class="n">B</span> <span class="p">]]</span>  <span class="o">=</span> <span class="p">{</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">}</span>

<span class="p">[[</span> <span class="o">~</span><span class="n">C</span> <span class="p">]]</span>      <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">}</span>

<span class="p">[[</span> <span class="n">C</span> <span class="n">v</span> <span class="o">~</span> <span class="n">C</span> <span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">}</span>

<span class="p">[[</span> <span class="n">B</span> <span class="o">--&gt;</span> <span class="n">G</span> <span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">}</span>

<span class="p">[[</span> <span class="n">G</span> <span class="o">--&gt;</span> <span class="n">B</span> <span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">}</span>
</pre></div>
</div>
<p>Kripke models are also useful in database and artificial-intelligence
applications, when one must state propositions and do deductions based on what
is already known and what might be known in the future.
(The logic for doing this is called <em>modal logic</em>.)
Also, state-transition diagrams, which are used to describe the behaviors of
multi-object programs and also computer networks, are Kripke structures, and
there is a logic, called <em>temporal logic</em>, that one uses to analyze these
systems.</p>
</div>
</div>
<div class="section" id="summary-of-rules-and-tactics">
<h2>7.10. Summary of Rules and Tactics<a class="headerlink" href="#summary-of-rules-and-tactics" title="Permalink to this headline">¶</a></h2>
<p>As a general principle, when you are proving a claim:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">S1</span><span class="p">,</span> <span class="n">S2</span><span class="p">,</span> <span class="o">...</span> <span class="o">|-</span> <span class="n">T</span>
</pre></div>
</div>
<p>first look at the connectives within <code class="docutils literal"><span class="pre">T</span></code> and note that you will probably need
the introduction rules for those connectives to assemble the clauses you prove
into <code class="docutils literal"><span class="pre">T</span></code>.
Then, look at the connectives within each of the premises, <code class="docutils literal"><span class="pre">Si</span></code>, and note that
you will probably need the elimination rules for those connectives to
disassemble the premises into the primitive propositions needed to assemble into
<code class="docutils literal"><span class="pre">T</span></code>.</p>
<p>To choose the order for using the introduction and elimination rules, think
about the tactics you might use to disassemble the premises and assemble the
goal.
The inference rules in this chapter are reviewed below in the order in which
they should be tactically applied:</p>
<ul>
<li><p class="first">(<a href="#id49"><span class="problematic" id="id50">**</span></a><a href="#id51"><span class="problematic" id="id52">*</span></a>) <code class="docutils literal"><span class="pre">^i</span></code>: use to prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">P</span> <span class="pre">^</span> <span class="pre">Q</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="n">Premises</span>     <span class="n">premise</span>
     <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="n">i</span><span class="o">.</span> <span class="n">P</span>
     <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="n">j</span><span class="o">.</span> <span class="n">Q</span>
<span class="n">k</span><span class="o">.</span>  <span class="n">P</span> <span class="o">^</span> <span class="n">Q</span>       <span class="o">^</span><span class="n">i</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span>
</pre></div>
</div>
</li>
<li><p class="first">(<a href="#id53"><span class="problematic" id="id54">**</span></a><a href="#id55"><span class="problematic" id="id56">*</span></a>) <code class="docutils literal"><span class="pre">ve</span></code>-tactic: To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">R</span></code>, if <code class="docutils literal"><span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q</span></code> appears as a
premise or proved fact in the partial proof, then</p>
<ol class="arabic simple">
<li>prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">P</span> <span class="pre">|-</span> <span class="pre">R</span></code></li>
<li>prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">Q</span> <span class="pre">|-</span> <span class="pre">R</span></code></li>
<li>use the <code class="docutils literal"><span class="pre">ve</span></code>-rule to prove <code class="docutils literal"><span class="pre">R</span></code>.</li>
</ol>
<p>The proof is structured like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span>  <span class="n">Premises</span>         <span class="n">premise</span>
      <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
<span class="n">i</span><span class="o">.</span>  <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span>

<span class="o">...</span> <span class="n">j</span><span class="o">.</span> <span class="n">P</span>             <span class="n">assumption</span>
<span class="o">...</span>     <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="o">...</span> <span class="n">k</span><span class="o">.</span> <span class="n">R</span>

<span class="o">...</span> <span class="n">l</span><span class="o">.</span> <span class="n">Q</span>             <span class="n">assumption</span>
<span class="o">...</span>     <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="o">...</span> <span class="n">m</span><span class="o">.</span> <span class="n">R</span>

<span class="n">n</span><span class="o">.</span>     <span class="n">R</span>             <span class="n">ve</span> <span class="mi">2</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="o">-</span><span class="n">m</span>
</pre></div>
</div>
</li>
<li><p class="first">(<a href="#id57"><span class="problematic" id="id58">**</span></a><a href="#id59"><span class="problematic" id="id60">*</span></a>) <code class="docutils literal"><span class="pre">--&gt;i</span></code>: use to prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span>  <span class="n">Premises</span>       <span class="n">premise</span>
<span class="o">...</span> <span class="n">i</span><span class="o">.</span>  <span class="n">P</span>          <span class="n">assumption</span>
<span class="o">...</span>     <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="o">...</span> <span class="n">j</span><span class="o">.</span>  <span class="n">Q</span>
<span class="n">k</span><span class="o">.</span>  <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">Q</span>        <span class="o">--&gt;</span><span class="n">i</span> <span class="n">i</span><span class="o">-</span><span class="n">j</span>
</pre></div>
</div>
</li>
<li><p class="first">(<a href="#id61"><span class="problematic" id="id62">**</span></a><a href="#id63"><span class="problematic" id="id64">*</span></a>) <code class="docutils literal"><span class="pre">~i</span></code>: use to prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">~P</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span>  <span class="n">Premises</span>   <span class="n">premises</span>
<span class="o">...</span> <span class="n">i</span><span class="o">.</span>  <span class="n">P</span>      <span class="n">assumption</span>
<span class="o">...</span>     <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="o">...</span> <span class="n">j</span><span class="o">.</span>  <span class="n">_</span><span class="o">|</span><span class="n">_</span>
<span class="n">k</span><span class="o">.</span> <span class="o">~</span><span class="n">P</span>          <span class="o">~</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="n">j</span>
</pre></div>
</div>
</li>
<li><p class="first">(**) <code class="docutils literal"><span class="pre">^e</span></code>-tactic: If your task is to prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">R</span></code> and you have as
a premise or proved fact in your partial proof, <code class="docutils literal"><span class="pre">P</span> <span class="pre">^</span> <span class="pre">Q</span></code>, then apply <code class="docutils literal"><span class="pre">^E</span></code>
to extract <code class="docutils literal"><span class="pre">P</span></code> and <code class="docutils literal"><span class="pre">Q</span></code> to use in the proof:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="n">Premises</span>    <span class="n">premise</span>
      <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
<span class="n">i</span><span class="o">.</span> <span class="n">P</span> <span class="o">^</span> <span class="n">Q</span>       <span class="n">premise</span>
<span class="n">i</span><span class="o">+</span><span class="mf">1.</span> <span class="n">P</span>         <span class="o">^</span><span class="n">e1</span> <span class="n">i</span>
<span class="n">i</span><span class="o">+</span><span class="mf">2.</span> <span class="n">Q</span>         <span class="o">^</span><span class="n">e2</span> <span class="n">i</span>
    <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="n">j</span><span class="o">.</span> <span class="n">R</span>
</pre></div>
</div>
</li>
<li><p class="first">(*) <code class="docutils literal"><span class="pre">--&gt;e</span></code>-tactic: To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">R</span></code>, if <code class="docutils literal"><span class="pre">P</span> <span class="pre">--&gt;</span> <span class="pre">Q</span></code> appears as a
premise or a proved fact in the partial proof, then</p>
<ol class="arabic simple">
<li>prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">P</span></code></li>
<li>use <code class="docutils literal"><span class="pre">--&gt;e</span></code> to deduce <code class="docutils literal"><span class="pre">Q</span></code></li>
<li>prove <code class="docutils literal"><span class="pre">Premises,</span> <span class="pre">P,</span> <span class="pre">Q</span> <span class="pre">|-</span> <span class="pre">R</span></code>.</li>
</ol>
<p>Here, the tactic is to generate new knowledge that will bring us closer to the
goal, <code class="docutils literal"><span class="pre">R</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span>  <span class="n">Premises</span>      <span class="n">premise</span>
       <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
<span class="n">i</span><span class="o">.</span>  <span class="n">P</span> <span class="o">--&gt;</span> <span class="n">Q</span>
        <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="n">j</span><span class="o">.</span>  <span class="n">P</span>
<span class="n">k</span><span class="o">.</span>  <span class="n">Q</span>             <span class="o">--&gt;</span><span class="n">e</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span>
        <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="n">k</span><span class="o">.</span>  <span class="n">R</span>
</pre></div>
</div>
</li>
<li><p class="first">(*) <code class="docutils literal"><span class="pre">_|_</span></code>-tactic: To prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">Q</span></code>, if <code class="docutils literal"><span class="pre">~P</span></code> appears as a premise
or as a proved fact in our partial proof, then</p>
<ol class="arabic simple">
<li>prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">P</span></code></li>
<li>use <code class="docutils literal"><span class="pre">~e</span></code> to deduce <code class="docutils literal"><span class="pre">_|_</span></code></li>
<li>use the <code class="docutils literal"><span class="pre">_|_e</span></code>-rule to deduce <code class="docutils literal"><span class="pre">Q</span></code>.</li>
</ol>
<p>The structure is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span>   <span class="n">Premises</span>     <span class="n">premise</span>
       <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
<span class="n">i</span><span class="o">.</span>   <span class="o">~</span><span class="n">P</span>
      <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="n">j</span><span class="o">.</span>   <span class="n">P</span>
<span class="n">k</span><span class="o">.</span>   <span class="n">_</span><span class="o">|</span><span class="n">_</span>          <span class="o">~</span><span class="n">e</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span>
<span class="n">l</span><span class="o">.</span>   <span class="n">Q</span>            <span class="n">_</span><span class="o">|</span><span class="n">_e</span> <span class="n">k</span>
</pre></div>
</div>
</li>
<li><p class="first">(*) <code class="docutils literal"><span class="pre">vi</span></code>: use to prove <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">P</span> <span class="pre">v</span> <span class="pre">Q</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span>  <span class="n">Premises</span>     <span class="n">premise</span>
     <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="n">i</span><span class="o">.</span>  <span class="n">P</span>
<span class="n">j</span><span class="o">.</span>  <span class="n">P</span> <span class="n">v</span> <span class="n">Q</span>        <span class="n">vi1</span> <span class="n">i</span>
</pre></div>
</div>
</li>
<li><p class="first">() <code class="docutils literal"><span class="pre">Pbc</span></code>: use, as a last resort, to try to prove any <code class="docutils literal"><span class="pre">Premises</span> <span class="pre">|-</span> <span class="pre">P</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">1.</span>  <span class="n">Premises</span>    <span class="n">premise</span>
<span class="o">...</span> <span class="n">i</span><span class="o">.</span> <span class="o">~</span><span class="n">P</span>       <span class="n">assumption</span>
<span class="o">...</span>  <span class="p">(</span><span class="n">fill</span> <span class="ow">in</span><span class="p">)</span>
<span class="o">...</span> <span class="n">j</span><span class="o">.</span> <span class="n">_</span><span class="o">|</span><span class="n">_</span>
<span class="n">k</span><span class="o">.</span> <span class="n">P</span>            <span class="n">Pbc</span> <span class="n">i</span><span class="o">-</span><span class="n">j</span>
</pre></div>
</div>
</li>
</ul>
<hr class="docutils" />
<p align=right><small><em>
This note was adapted from David Schmidt's CIS 301, 2008,
<a href="http://people.cis.ksu.edu/~schmidt/301s14/Lectures/5natdedT.html">Chapter 5</a>
course note.
</em></small></p></div>
</div>


    </div>
      
  </div>
</div>

  </body>
</html>