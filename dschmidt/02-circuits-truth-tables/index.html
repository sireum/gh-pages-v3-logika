
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2. Circuits and Truth Tables &#8212; Sireum Logika</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sireum.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script src="../../_static/js/jquery-fix.js"></script>
    <script src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../_static/logika.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="3. Propositional Logic" href="../03-propositional-logic/index.html" />
    <link rel="prev" title="1. Introduction: Why bother?" href="../01-introduction/index.html" />
  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          Logika</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../doc/01-getting-started/index.html">Download</a></li>
                <li><a href="../../doc/index.html">Documentation</a></li>
                <li><a href="../index.html">Course Notes</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html"> <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#"> <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">2. Circuits and Truth Tables</a><ul>
<li><a class="reference internal" href="#gates-and-truth-tables">2.1. Gates and Truth Tables</a><ul>
<li><a class="reference internal" href="#characterizing-truth-tables">2.1.1. Characterizing Truth Tables</a></li>
<li><a class="reference internal" href="#truth-tables-as-proofs">2.1.2. Truth Tables as Proofs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#logika-truth-tables">2.2. Logika Truth Tables</a></li>
<li><a class="reference internal" href="#the-strange-case-of-the-imply-gate">2.3. The Strange Case of the Imply-gate</a></li>
<li><a class="reference internal" href="#common-logical-formula-circuit-equivalences">2.4. Common Logical Formula (circuit) Equivalences</a><ul>
<li><a class="reference internal" href="#equality">2.4.1. Equality</a></li>
<li><a class="reference internal" href="#the-double-negative">2.4.2. The Double Negative</a></li>
<li><a class="reference internal" href="#exclusive-or-xor">2.4.3. Exclusive OR (XOR)</a></li>
<li><a class="reference internal" href="#de-morgan-s-law">2.4.4. De Morgan’s Law</a></li>
<li><a class="reference internal" href="#implication-equivalences">2.4.5. Implication Equivalences</a></li>
</ul>
</li>
<li><a class="reference internal" href="#why-it-is-called-the-top-level-operator">2.5. Why it is called the “Top Level” operator</a></li>
<li><a class="reference internal" href="#knowledge-travels-along-the-wires-of-a-circuit">2.6. Knowledge Travels Along the Wires of A Circuit</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <br/>
<font color="darkgray">
<big><big><b>
Logika: Programming Logics
</b></big></big>
</font>
<br/>
<font color="black">
<big><big><big><big><b>
2. Circuits and Truth Tables
</b></big></big></big></big>
</font><hr class="docutils" />
<div class="section" id="circuits-and-truth-tables">
<span id="circuits"></span><h1><span class="section-number">2. </span>Circuits and Truth Tables<a class="headerlink" href="#circuits-and-truth-tables" title="Permalink to this headline">¶</a></h1>
<p>In this chapter, we review basic notions about gates and learn the relationship
between circuits and assignment-based computer programs.
This sets the stage for analyzing modern programs.</p>
<div class="section" id="gates-and-truth-tables">
<h2><span class="section-number">2.1. </span>Gates and Truth Tables<a class="headerlink" href="#gates-and-truth-tables" title="Permalink to this headline">¶</a></h2>
<p>Here are the four basic gates:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 21%" />
<col style="width: 32%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>P AND Q</p></td>
<td><p>P OR Q</p></td>
<td><p>NOT P</p></td>
<td><p>P IMPLY Q</p></td>
</tr>
<tr class="row-even"><td><p><img alt="AND" src="../../_images/AND.png" /></p></td>
<td><p><img alt="OR" src="../../_images/OR.png" /></p></td>
<td><p><img alt="NOT" src="../../_images/NOT.png" /></p></td>
<td><p><img alt="IMPLY" src="../../_images/IEEE_IMPLY.png" /></p></td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<p>In the above drawings, the input wires are labelled with the names <code class="docutils literal notranslate"><span class="pre">P</span></code> and
<code class="docutils literal notranslate"><span class="pre">Q</span></code>.
The output that is computed is emitted from the rightmost wire which exits the
gate.  For these simple gates, it is possible to exhaustively test every permutation
of potential inputs and summarize results in a table, called a truth table.</p>
<p>Let’s examine the AND gate.  The AND gate emits a high voltage (<code class="docutils literal notranslate"><span class="pre">1</span></code>) exactly
when high voltages are sensed at input wires <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code>; otherwise
low voltage (<code class="docutils literal notranslate"><span class="pre">0</span></code>) is emitted.  The gate’s physical behavior is summarized by
in the following table.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AND</span><span class="p">:</span> <span class="n">P</span> <span class="n">Q</span> <span class="o">|</span>
<span class="o">------------</span>
     <span class="mi">1</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">1</span>
     <span class="mi">1</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">0</span>
     <span class="mi">0</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">0</span>
     <span class="mi">0</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">0</span>
</pre></div>
</div>
<p>For the remainder of this course, we will use <code class="docutils literal notranslate"><span class="pre">T</span></code> (read “true”) for <code class="docutils literal notranslate"><span class="pre">1</span></code> and
<code class="docutils literal notranslate"><span class="pre">F</span></code> (read “false”) for <code class="docutils literal notranslate"><span class="pre">0</span></code>.
This is because we will examine applications that go far beyond circuit theory
and base-two arithmetic.
Here are the truth tables for the AND, OR, NOT and IMPLY gates:</p>
<a class="reference internal image-reference" href="../../_images/NotLogikaTable.PNG"><img alt="../../_images/NotLogikaTable.PNG" src="../../_images/NotLogikaTable.PNG" style="width: 551px; height: 89px;" /></a>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The capital letters P and Q are intended to be place holders, not
variables strictly named P and Q.  Their use avoids the verbose, “Right-hand
Side Operand” and “Left-hand Side Operand”.</p>
</div>
<p>OR is sometimes called “inclusive or”, because as long as one of
its inputs is true, then its output is true.  This differs from common United
States English usage.  Generally in spoken and written English, “or” carries the
exclusive connotation.  If offered a choice of “coffee or tea,” it is understood
that you may select one but not both.  The logical “or” is admits the possibility
of both.  It is more accurately translated into the English language as “and/or”.</p>
<p>The meaning of the IMPLY gate will be covered latter in this chapter.  It is
included here so all the gate information is consolidated.</p>
<p>It is standard to write each gate in a linear notation, that is, instead of
drawing <img alt="AND" src="../../_images/AND.png" />, we write <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">∧</span> <span class="pre">Q</span></code>.
(The tradition of writing linear notations to represent two-dimensional
structures goes back centuries in physics and math.)
The notations are as follows (the traditional math notations are provided for
your reference.)</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 21%" />
<col style="width: 28%" />
<col style="width: 34%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Gate</p></td>
<td><p>ASCII</p></td>
<td><p>Math</p></td>
<td><p>UNICODE</p></td>
</tr>
<tr class="row-even"><td><p>AND</p></td>
<td><p>∧</p></td>
<td><p>∧</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">∧</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>OR</p></td>
<td><p>v</p></td>
<td><p>∨</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">∨</span></code></p></td>
</tr>
<tr class="row-even"><td><p>NOT</p></td>
<td><p>~</p></td>
<td><p>¬</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">¬</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>IMPLY</p></td>
<td><p>-&gt;</p></td>
<td><p>⇒</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">→</span></code></p></td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<p><em>These notes will typically use the UNICODE notations.</em></p>
<p>We can also compose the gates to define new operations.</p>
<p>For example, this circuit, <img alt="circuit1" src="../../_images/circuit1.png" /> written <code class="docutils literal notranslate"><span class="pre">¬</span> <span class="pre">(P</span> <span class="pre">∧</span> <span class="pre">Q)</span></code>, defines this
computation of outputs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>P Q | ¬ (P ∧ Q)
--------------
T T | F
T F | T
F T | T
F F | T
</pre></div>
</div>
<p>which we can work out in stages, like this:</p>
<a class="reference internal image-reference" href="../../_images/NotLogikaTT.png"><img alt="../../_images/NotLogikaTT.png" src="../../_images/NotLogikaTT.png" style="width: 559.35px; height: 160.65px;" /></a>
<p>We begin by writing the value of each set of inputs on the left, under their
corresponding symbol on the right. Next we apply the operator (gate) with the
highest precedence (covered  in Logical Operator Precedence below).  In our case
the “()” make the AND (<code class="docutils literal notranslate"><span class="pre">∧</span></code>) symbol the highest.</p>
<p>A truth assignment is a unique permutation of the possible inputs for a system.
For the ∧-gate, it is a 2-variable sequence. Considering the first row we see
we have ” T ∧ T”–looking that up in the ∧-gate truth table we see the result is
also “T”, and we record that under the “∧” symbol.  We do the same thing all the
other truth assignments.</p>
<p>After the initial transcribing of the truth values under
their respective variables, we look up the truth-values in the gate tables, not
the variables. Also observe that while ∧ is symmetric, i.e. “T F” == “F T” == “F”
the IMPLY gate is not.</p>
<p>Now we look up the value under the “∧” symbol in the ¬ gate table.  In the first
row we see that the truth assignment for the first row, “T”, is “F” and record
it under the “¬” symbol. Do this for every row and we are done.</p>
<div class="section" id="characterizing-truth-tables">
<h3><span class="section-number">2.1.1. </span>Characterizing Truth Tables<a class="headerlink" href="#characterizing-truth-tables" title="Permalink to this headline">¶</a></h3>
<p>In our study of logic, it will be convenient to characterize logical formula with
a description of their truth tables. If all truth assignments for a logical formula
are True, the formula is said to be a tautology.  The formula <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">∨</span> <span class="pre">¬</span> <span class="pre">p</span></code> is a
tautology.  In the following example, the <code class="docutils literal notranslate"><span class="pre">*</span></code> marks the top level or last
evaluated operator.</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      *
------------
p | p ∨ ¬ p
------------
T | T T F T
F | F T T F
------------
Tautology
</pre></div>
</td></tr></table></div>
<p>A formula for which every truth assignment is False is called contradictory. The
formula <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">∧</span> <span class="pre">¬</span> <span class="pre">p</span></code> is contradictory (or a contradiction).</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      *
------------
p | p ∧ ¬ p
------------
T | T F F T
F | F F T F
------------
Contradictory
</pre></div>
</td></tr></table></div>
<p>A formula for which some truth assignments are False and other’s True is called
contingent.  The equation <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">q</span> <span class="pre">|</span> <span class="pre">¬</span> <span class="pre">(q</span> <span class="pre">∧</span> <span class="pre">q)</span></code>, from above is contingent.</p>
<blockquote>
<div><div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      *
---------------
p q | ¬ (p ∧ q)
---------------
T T | F  T T T
T F | T  T F F
F T | T  F F T
F F | T  F F F
---------------
Contingent
- T : [T F] [F T] [F F]
- F : [T T]
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>In this section, we have used Logika truth tables.  They are explained in more
detail below.  In this class, if you produce a truth table as part of an answer,
it must match the Logika syntax.</p>
</div>
<div class="section" id="truth-tables-as-proofs">
<h3><span class="section-number">2.1.2. </span>Truth Tables as Proofs<a class="headerlink" href="#truth-tables-as-proofs" title="Permalink to this headline">¶</a></h3>
<p>This is a class about logic.  As such, much the class will involve formally
proving some claim is always true, never true, or true only under certain conditions.
Many types of “computing” problems can be expressed as truth tables.</p>
<p>Consider the simple 2-bit integer adder.</p>
<a class="reference internal image-reference" href="../../_images/01-image-100.png"><img alt="../../_images/01-image-100.png" src="../../_images/01-image-100.png" style="width: 640.0px; height: 360.0px;" /></a>
<p>While it has a lot of parts (three “answer” tables, each with 2^2 truth
assignments), it is certainly feasible (although irritating) to calculate these
tables by hand.  But recall, that most integers are represented by 32-bits, leading to
33 tables (don’t forget the Carry-Over or Overflow bit), each with 2^32 entries.
This will take a bit (pun intended) over a 1,100-years to write out by hand if
you can average one truth assignment per second.</p>
<p>Considering you will probably never be asked to write a real-world application
as simple as integer addition, it is easy to conclude that it is
infeasible to prove the correctness of programs by truth tables.  The inability
to test a program by
exhaustively testing every input or state is known as the combinatorial explosion
problem.</p>
<p>OKay … then why are we making you learn truth tables? Well, even when more advanced
techniques are applied to prove logical statements, underling the techniques’ soundness
are these primitive rules which are easily expressed and learned via truth tables.</p>
</div>
</div>
<div class="section" id="logika-truth-tables">
<h2><span class="section-number">2.2. </span>Logika Truth Tables<a class="headerlink" href="#logika-truth-tables" title="Permalink to this headline">¶</a></h2>
<p>From this point forward, the course will expect you to use Logika formatted
truth tables.  The Logika truth table for the formula  <code class="docutils literal notranslate"><span class="pre">¬</span> <span class="pre">(P</span> <span class="pre">∧</span> <span class="pre">Q)</span></code> is:</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span>      *
------------
p | p ∨ ¬ p
------------
T | T T F T
F | F T T F
------------
Tautology
</pre></div>
</td></tr></table></div>
<p>Logika truth tables have standard format (syntax) and semantic meanings.  All elements
of the truth table must be included to be considered correct.</p>
<a class="reference internal image-reference" href="../../_images/LTTExplained.png"><img alt="../../_images/LTTExplained.png" src="../../_images/LTTExplained.png" style="width: 898.0px; height: 399.0px;" /></a>
<p>The first line will always contain a single asterisk (<code class="docutils literal notranslate"><span class="pre">*</span></code>) over the last operator evaluated
in the formula. This may also be referred to as the “top level” or “lowest precedent”
operator. Why it is called the “top level” operator will be covered towards the
end of this chapter.</p>
<p>Next is a line of <code class="docutils literal notranslate"><span class="pre">-</span></code> (minus sign) characters, these lines must be at least as long
as the third line to avoid getting errors.</p>
<p>The third line contains “variables | formula”.  As Logika uses some capital letters as
reserved words, lower case letters are used as variable names.  Additionally, variables
should be listed alphabetically.</p>
<p>The fourth line is another row of <code class="docutils literal notranslate"><span class="pre">-</span></code>.</p>
<p>Next come the truth assignments.  Convention is to start with all True and progress
linearly to all False.  Capital <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">F</span></code> must be used. In a truth assignment
each variable is mapped to either true or false.</p>
<p>After the Truth assignments is another row of <code class="docutils literal notranslate"><span class="pre">-</span></code>.</p>
<p>Lastly comes the table.  When all truth assignment cause the formula to be true,
the word <code class="docutils literal notranslate"><span class="pre">Tautology</span></code> is used without an accompanying table.  Similarly, when
all truth assignments are false, <code class="docutils literal notranslate"><span class="pre">Contradictory</span></code> is used.  All other results
are <code class="docutils literal notranslate"><span class="pre">Contingent</span></code>, see the example in the figure above.</p>
<p>The order of precedence for logical operators from highest to lowest are:</p>
<img alt="../../_images/PrecedenceTable.PNG" src="../../_images/PrecedenceTable.PNG" />
<p>Parentheses alter the order of operations as they do in normal algebra.
Parenthetical expressions are evaluated from most-deeply nested to
least-deeply nested  (inside-to-outside).</p>
</div>
<div class="section" id="the-strange-case-of-the-imply-gate">
<h2><span class="section-number">2.3. </span>The Strange Case of the Imply-gate<a class="headerlink" href="#the-strange-case-of-the-imply-gate" title="Permalink to this headline">¶</a></h2>
<p>The astute reader will notice that <code class="docutils literal notranslate"><span class="pre">→</span></code> truth tables work very different from
<code class="docutils literal notranslate"><span class="pre">∧</span></code> and <code class="docutils literal notranslate"><span class="pre">∨</span></code>. To begin with, <code class="docutils literal notranslate"><span class="pre">∧</span></code> and <code class="docutils literal notranslate"><span class="pre">∨</span></code> truth assignments are symmetric;
if [T F] == F then [F T] == F.
This is not true of implication because, <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code> is a composite
claim that asserts that p holds knowledge sufficient to deduce q.</p>
<p>Lets use a concrete example from K-State.  If I know you are majoring
in computer science (fact p), then I know you are majoring in engineering (fact q).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>majoring in computer science  →  majoring in engineering
           p                  →           q
</pre></div>
</div>
<p>However the converse, <code class="docutils literal notranslate"><span class="pre">majoring</span> <span class="pre">in</span> <span class="pre">Engineering</span>&#160; <span class="pre">→</span> <span class="pre">majoring</span> <span class="pre">in</span> <span class="pre">Computer</span> <span class="pre">Science</span></code>
is not necessarily true.</p>
<p>Some students tend to conflate “p holds knowledge sufficient to deduce q” to mean
“p == q”, and are surprised and indignant that the truth assignment [F T] in
the IMPLY gate is True. <strong>p → q does not mean p == q or q == p</strong></p>
<p>In the truth table for <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code>, the result reflects the existence of a serial
link between <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code>.  First <code class="docutils literal notranslate"><span class="pre">p</span></code> must be true, then <code class="docutils literal notranslate"><span class="pre">q</span></code> must also
be true in order for the implication to be true.</p>
<p>If both are true, the link is
true, and the implication (the relationship) between <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> is true.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">p</span></code> is true and <code class="docutils literal notranslate"><span class="pre">q</span></code> is false, clearly p does not hold knowledge sufficient
to deduce q, so the relationship is not true (false).</p>
<p>Finally, if p is not true,
there is no way to know whether the relationship holds.  In this case, the
implication is said to be true, or vacuously true.  There is certainly no
evidence to prove that it is false.</p>
<p>Implication in logic was formalized by William of Ockham,  in his book
<em>Summa Logicae</em> in the 14th century.  These somewhat convoluted
rules add tremendous expressive power to logic and computation.  Without them
there would be no branching in programs (no IFs, no FORs, no WHILEs).</p>
</div>
<div class="section" id="common-logical-formula-circuit-equivalences">
<h2><span class="section-number">2.4. </span>Common Logical Formula (circuit) Equivalences<a class="headerlink" href="#common-logical-formula-circuit-equivalences" title="Permalink to this headline">¶</a></h2>
<div class="section" id="equality">
<h3><span class="section-number">2.4.1. </span>Equality<a class="headerlink" href="#equality" title="Permalink to this headline">¶</a></h3>
<p>Two (or more) logical statements are said to be equal IFF (if and only if, <code class="docutils literal notranslate"><span class="pre">↔</span></code>) they have
the same truth value for every truth assignment; i.e. their truth tables
evaluate exactly the same. An example of equal are <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">∧</span> <span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">∧</span> <span class="pre">(q</span> <span class="pre">∧</span> <span class="pre">p)</span></code></p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span>         *
--------------
p q | (p ∧ q)
--------------
T T |  T T T
T F |  T F F
F T |  F F T
F F |  F F F
---------------
Contingent
- T : [T T]
- F : [F F] [F T] [T F]
</pre></div>
</td></tr></table></div>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span>         *
-------------------
p q |  p ∧ (q ∧ p)
-------------------
T T |  T T  T T T
T F |  T F  F F T
F T |  F F  T F F
F F |  F F  F F F
--------------------
Contingent
- T : [T T]
- F : [F F] [F T] [T F]
</pre></div>
</td></tr></table></div>
<p>Finding equivalent logical statements of fewer gates (states) is important to
several fields. In computer
science, fewer states can lead to less memory, fewer operations and smaller programs.  In
computer engineering, fewer gates means fewer circuits less power and less heat.</p>
<p>More technically, bi-implication is another way to express quality.  However, we
have not yet introduced an “equals” operator.</p>
<blockquote>
<div><p>p = q ↔ (p → q) ∧ (q → p)</p>
</div></blockquote>
</div>
<div class="section" id="the-double-negative">
<h3><span class="section-number">2.4.2. </span>The Double Negative<a class="headerlink" href="#the-double-negative" title="Permalink to this headline">¶</a></h3>
<p>In Logika, and in many logic applications, double negations
effectively cancel each other out.  This is not the only possible interpretation
of <code class="docutils literal notranslate"><span class="pre">¬</span> <span class="pre">¬</span> <span class="pre">p</span></code>, but it is the one implemented in Logika.  We may discuss other
interpretations in the section on Propositional Logic.</p>
<blockquote>
<div><p>¬ ¬ p ↔ p</p>
</div></blockquote>
</div>
<div class="section" id="exclusive-or-xor">
<h3><span class="section-number">2.4.3. </span>Exclusive OR (XOR)<a class="headerlink" href="#exclusive-or-xor" title="Permalink to this headline">¶</a></h3>
<p>As previously discussed, common English usage of “or” is in the exclusive sense.
<code class="docutils literal notranslate"><span class="pre">(p</span> <span class="pre">XOR</span> <span class="pre">q)</span></code> can be expressed in several ways:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(p ∧ ¬ q) ∨ (¬p ∧ q)
(p ∨ q) ∧ ¬ (p ∧ q)
</pre></div>
</div>
<p>In class, we will not accept the use of an XOR operator, you must express the
all formula in terms of AND, OR, NOT and IMPLY.</p>
</div>
<div class="section" id="de-morgan-s-law">
<h3><span class="section-number">2.4.4. </span>De Morgan’s Law<a class="headerlink" href="#de-morgan-s-law" title="Permalink to this headline">¶</a></h3>
<p>De Morgan’s Law is a statement about the relationship between AND
and NOT-OR (NOR) (<code class="docutils literal notranslate"><span class="pre">¬</span> <span class="pre">(</span> <span class="pre">p</span> <span class="pre">∨</span> <span class="pre">q)</span></code>).  Specifically:</p>
<blockquote>
<div><div class="line-block">
<div class="line">p ∧ q  ↔  ¬ ( ¬ p ∨ ¬ q)</div>
<div class="line">p ∨ q  ↔  ¬ ( ¬ p ∧ ¬ q)</div>
</div>
</div></blockquote>
<p>This has important implications for computer engineering, allowing
all logic constructions to be expressed with only two types of basic
gates, NAND and NOT; greatly economizing integrated chip production.</p>
<p>Augustus De Morgan also coined the term Mathematical Induction and provided a rigorous
approach for its proof. Mathematical induction is the basis for many
computer science proofs in areas of algorithms, languages and
computational complexity.</p>
</div>
<div class="section" id="implication-equivalences">
<h3><span class="section-number">2.4.5. </span>Implication Equivalences<a class="headerlink" href="#implication-equivalences" title="Permalink to this headline">¶</a></h3>
<p>Finally, implication can be expressed as negation and OR; or as its
contra-positive statement.</p>
<blockquote>
<div><div class="line-block">
<div class="line">(p → q) ↔   ¬ p ∨ q</div>
<div class="line">(p → q) ↔ ( ¬ q → ¬ p)  the contrapositive statement</div>
</div>
</div></blockquote>
<p>The converse of an implication may or may not be true</p>
<blockquote>
<div><div class="line-block">
<div class="line">(p → q) ??? (q → p)   the converse (NOT NECESSARILY AN EQUIVALENCE)</div>
</div>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While most of the formula presented in this section are true
equivalences, IF you are asked to prove they are equal by truth table,
it is expected that you would make a truth table for each side of the <code class="docutils literal notranslate"><span class="pre">↔</span></code>
and show that their values match for every truth assignment.</p>
</div>
</div>
</div>
<div class="section" id="why-it-is-called-the-top-level-operator">
<h2><span class="section-number">2.5. </span>Why it is called the “Top Level” operator<a class="headerlink" href="#why-it-is-called-the-top-level-operator" title="Permalink to this headline">¶</a></h2>
<p>Let us return to the 2-bit adder, and consider only the circuitry for Q1.  In a
circuit, knowledge can be said to flow along the wires, where it is transformed
by gates and the new knowledge propagates to the next point.</p>
<a class="reference internal image-reference" href="../../_images/01-image-110.png"><img alt="../../_images/01-image-110.png" src="../../_images/01-image-110.png" style="width: 696.0px; height: 229.5px;" /></a>
<p>In the circuit annotated above, it is clear what knowledge (facts and deduced
facts) flow in each wire segment.  A common mathematical, hence computer science
technique is to represent this type of knowledge flow in specialized type of
graph called a tree.  A tree is represented by a collection of nodes and edges,
one node is selected as the “root” and all nodes have a unique path (a collection
of edges) leading to the root node. By convention, the tree is drawn inverted,
with its root at the top and its leaves hanging from the bottom.</p>
<a class="reference internal image-reference" href="../../_images/01-image-120.png"><img alt="../../_images/01-image-120.png" src="../../_images/01-image-120.png" style="width: 289.2px; height: 405.0px;" /></a>
<p>In computer science, the root is selected to be the node which provides the
“final answer” to the problem.  As you can see, edges carry facts and nodes
are operators which deduce new facts.</p>
<p>The tree representation of a computer program is a fundamental abstraction for
computer scientist.  Modern compilers and interpreters take a program written
in a high level programing language and convert it into an abstract syntax tree
(AST), which is then
converted to machine-code.  For languages in the functional paradigm (C# and Java
are in the imperative and/or object paradigms ), there is a strong correlation
between the high-level program’s structure and that of the AST.</p>
<p>When we compare the tree with the logical statement, we see the lowest priority
operator is the root of the tree;  hence the term “Top Level” operator.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>             *
(¬(A1 ∧ B1)) ∧ (A1 ∧ B1)
</pre></div>
</div>
</div>
<div class="section" id="knowledge-travels-along-the-wires-of-a-circuit">
<h2><span class="section-number">2.6. </span>Knowledge Travels Along the Wires of A Circuit<a class="headerlink" href="#knowledge-travels-along-the-wires-of-a-circuit" title="Permalink to this headline">¶</a></h2>
<p>So far, we pretended that low- and high-voltage levels travel along the wiring
of a circuit.
But it is really knowledge that travels the circuit.
This is understood with some pictures.
Here is a circuit:</p>
<img alt="../../_images/circuit2.png" src="../../_images/circuit2.png" />
<p>and here is its coding in equations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>R = P ∧ Q
S = R ∨ Q
T = ¬ S
</pre></div>
</div>
<p>Let’s redraw the circuit vertically and lay it side by side with the assignment
equations:</p>
<img alt="../../_images/ex1.png" src="../../_images/ex1.png" />
<p>Each wire in the circuit is named. These are just <em>variable names</em>.
Indeed, <em>the first (electronic) computer programs, in the 1940s, were
descriptions of wiring diagrams</em> like this one.
The modern stored-program computer, developed by John von Neumann in the 1950s,
used storage registers to hold the values of the variable names and used a
processor to compute the values of the equations.
In this way, a processor-plus-registers can simulate a circuit, and
<strong>all computer programs are merely descriptions of circuits in which information
flows through the wires (the variables)</strong>.</p>
<p>This is the origin of variable-based, assignment-based computer programming.
Now, at each of the <em>program points</em>, marked by stars in the above diagram, what
information travels in the wires?
We might use the circuit with some inputs to see “what happens”.
Say that we supply <code class="docutils literal notranslate"><span class="pre">true</span></code> for <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code> for <code class="docutils literal notranslate"><span class="pre">Q</span></code>:</p>
<img alt="../../_images/ex2.png" src="../../_images/ex2.png" />
<p>The diagram shows the values on the wires labelled <code class="docutils literal notranslate"><span class="pre">P</span></code>, <code class="docutils literal notranslate"><span class="pre">Q</span></code>, <code class="docutils literal notranslate"><span class="pre">R</span></code> and <code class="docutils literal notranslate"><span class="pre">S</span></code>
as they travel through the circuit.
But this is just tracking the values of the variables in the assignment program
we wrote!
The “output variable”/write, named <code class="docutils literal notranslate"><span class="pre">T</span></code>, has value <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>Just as interesting is that we can analyze the program/circuit <em>before</em> it is
completely tested.
For example, say that the circuit will be inserted into a board where its <code class="docutils literal notranslate"><span class="pre">P</span></code>
wire will always receive a t as input, but we don’t know what <code class="docutils literal notranslate"><span class="pre">Q</span></code> will receive.
What can we predict about the circuit’s behavior once it is embedded in the board?
It’s this:</p>
<img alt="../../_images/ex3.png" src="../../_images/ex3.png" />
<p>In the diagram, we see that <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">Q</span></code> is stated after the AND gate.
How do we know this?
First, we do know that <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">P</span> <span class="pre">∧</span> <span class="pre">Q</span></code>. But <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">true</span></code>.
We <em>substitute</em> <code class="docutils literal notranslate"><span class="pre">true</span></code> for <code class="docutils literal notranslate"><span class="pre">P</span></code> and obtain <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">true</span> <span class="pre">∧</span> <span class="pre">Q</span></code>.
Next, we do a cases analysis and consider the cases of <code class="docutils literal notranslate"><span class="pre">Q</span></code>’s possible value:
If <code class="docutils literal notranslate"><span class="pre">Q</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code>, then <code class="docutils literal notranslate"><span class="pre">true</span> <span class="pre">∧</span> <span class="pre">Q</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span> <span class="pre">∧</span> <span class="pre">true</span></code>, which <em>simplifies</em> to <code class="docutils literal notranslate"><span class="pre">true</span></code>,
that is, to <code class="docutils literal notranslate"><span class="pre">Q</span></code>’s value.
Similarly, when <code class="docutils literal notranslate"><span class="pre">Q</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code>, then <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">∧</span> <span class="pre">Q</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code> as well.
Hence, in both cases, <code class="docutils literal notranslate"><span class="pre">true</span> <span class="pre">∧</span> <span class="pre">Q</span></code> equals <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p>
<p>The above reasoning is a <em>deduction</em> – we deduced from the facts <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">true</span></code> and
<code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">P</span> <span class="pre">∧</span> <span class="pre">Q</span></code> that <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">Q</span></code>.
The whole point of this course is to learn how to make such deductions.</p>
<p>The other deductions in the example are calculated with similar uses of
substitution, simplification, and cases analysis.</p>
<p>The point of the previous example is that we can deduce (predict) properties of
the circuit in advance of using it.
These deductions complement testing.</p>
<p>Next, say that we don’t know anything about <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code> as inputs.
What can be stated about the circuit’s output?
Well, it’s this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>T = ¬((P ∧ Q) ∨ Q)
</pre></div>
</div>
<p>stating the obvious!
But by a careful examination of the truth tables, we can also state that
<code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">=</span> <span class="pre">¬Q</span></code>.
Later in the course, we learn <em>deduction rules</em> that calculate this result, not
relying on truth tables.</p>
<p>Finally, we can make circuits that take three or more inputs, e.g.,
<code class="docutils literal notranslate"><span class="pre">(¬(P</span> <span class="pre">∧</span> <span class="pre">Q))</span> <span class="pre">∨</span> <span class="pre">R</span></code>
computes:</p>
<p>Here, the column underneath OR defines the output.
We see this circuit emits false only when <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code> are both true and
<code class="docutils literal notranslate"><span class="pre">R</span></code> is false.
This is a hint that the circuit, <code class="docutils literal notranslate"><span class="pre">¬(P</span> <span class="pre">∧</span> <span class="pre">Q</span> <span class="pre">∧</span> <span class="pre">~R)</span></code>, behaves the same way
(has the same truth table) as the one above.
Yet another equivalent circuit is <code class="docutils literal notranslate"><span class="pre">(¬P)</span> <span class="pre">∨</span> <span class="pre">(¬Q)</span> <span class="pre">∨</span> <span class="pre">R</span></code>. (Why?)</p>
<p>In circuit design, finding equivalent circuits with fewer gates and variables
saves power, time and material.</p>
<hr class="docutils" />
<p align=right><small><em>
This note was adapted from David Schmidt's CIS 301, 2008,
<a href="http://people.cis.ksu.edu/~schmidt/301s14/Lectures/0circuitsT.html">Chapter 0</a>
course note.
</em></small></p>
<p align=right><small><em>
It was updated in 2018 by Dr John Hatcliff and George Lavezzi <br>
to conform with Logika syntax and more closely match <br>
KSU's CIS 301 course as taught in Spring 2018.
</em></small></p></div>
</div>


    </div>
      
  </div>
</div>

  </body>
</html>