
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>1. Introduction: Why bother? &mdash; Sireum Logika</title>
    
    <link rel="stylesheet" href="../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootswatch-3.3.4/journal/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sireum.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.3.4/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../_static/logika.ico"/>
    <link rel="top" title="Sireum Logika" href="../../index.html" />
    <link rel="up" title="Logika: Programming Logics" href="../index.html" />
    <link rel="next" title="2. Circuits and Truth Tables" href="../02-circuits-truth-tables/index.html" />
    <link rel="prev" title="Logika: Programming Logics" href="../index.html" />
  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          Logika</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../doc/index.html">Documentation</a></li>
                <li><a href="../index.html">Course Notes</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html"> <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#"> <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">1. Introduction: Why bother?</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <br/>
<font color="darkgray">
<big><big><b>
Logika: Programming Logics
</b></big></big>
</font>
<br/>
<font color="black">
<big><big><big><big><b>
1. Introduction: Why bother?
</b></big></big></big></big>
</font><div class="section" id="introduction-why-bother">
<span id="introduction"></span><h1>1. Introduction: Why bother?<a class="headerlink" href="#introduction-why-bother" title="Permalink to this headline">¶</a></h1>
<p>That&#8217;s a good question!
After all, you can hack a spreadsheet program or build an interactive game by
writing a lot of code, experimenting with it, and patching it.
After awhile, the program you wrote does more or less what you wanted.</p>
<p>But imagine if the rest of the world worked that same way &#8211; would you want to
drive a car or fly an airplane that was &#8220;hacked together&#8221;?
How about travelling in a bus across a bridge that fell down a few times already
and was repeatedly patched till it (seemed) to hold?</p>
<p>Perhaps these analogies are a bit extreme, but professional scientists and
engineers rely on planning, design, and calculation so that they are certain the
products they want to build will work before anyone starts building them.
Professionals rely on an intellectual foundation to plan, design, and calculate.
For example:</p>
<ul class="simple">
<li>physicists use mathematics as the intellectual foundation of their products</li>
<li>chemical engineers use chemistry</li>
<li>mechanical engineers use physics</li>
<li>computer engineers and computer (software) scientists use algebra and symbolic
logic</li>
</ul>
<p>If you develop significant expertise in software engineering, perhaps you will
work at a firm or lab that develops <em>safety-critical software</em>, that is,
software upon which people&#8217;s money or safety or lives depend.
(An example is the flight-control software that lives in the nose of a jet and
flies it.
Another example is the navigation software in a satellite that talks to the GPS
device in someone&#8217;s car.)
Software of this nature has to be working correctly from the beginning &#8211;
there is no freedom to hack-and-patch the code once it is in use.
Software engineers must use algebra and logic to plan and calculate how the
software will behave before the software is built and installed.</p>
<p>This story is not an idle one: As you probably know, computer processor chips
are planned out in a programming language that looks a lot like C.
When Intel designed its first Pentium chip, there was a programming error in one
of the chip&#8217;s coded hash tables.
The coding was burned into hardware, and millions of chips were manufactured.
The error was quickly detected &#8211; the chip did not always perform multiplication
correctly.
As a result, Intel lost a lot of money recalling the faulty chips and
manufacturing a patched replacement.
These days, Intel uses techniques for validating chip designs much like the one
you will learn in this course.</p>
<p>If you have taken a software architecture course
(e.g., <a class="reference external" href="http://softwarearch.santoslab.org">CIS 501: Software Architecture and Design</a>),
you know that large systems can be drawn out, or &#8220;blueprinted,&#8221; with diagrams
that show the components and how they connect together by means of method calls,
event broadcast, and message passing.
What we will learn in this course is lower level and more basic &#8211; we will learn
how to calculate how the lines of coding in each component compute internal
knowledge as they convert inputs into outputs.</p>
<p>To understand the idea, let&#8217;s think about electronics.
When an electronic device, like a TV-set or radio, is designed, the parts of
the device and their wirings are drawn out in a diagram called a schematic.
Here is a schematic of a vacuum-tube guitar amplifier, the kind used by
recording studios to produce a warm sound with good sustain:</p>
<img alt="../../_images/eicohf22.png" src="../../_images/eicohf22.png" />
<p>Notice that the wires to the vacuum tubes (the globes labelled V1 through V5)
are labelled with voltages, and there is a table in the lower left corner of the
schematic that lists the correct resistances that will hold at each of the wires
(&#8220;pins&#8221;) that connect to the tubes.</p>
<p>The voltage and resistance calculations are both an <em>analysis</em> and a
<em>prediction</em> of how the circuit should behave.
The numbers were calculated with mathematics and algebra, and if the electronics
parts are working correctly, <em>then these voltage, amperage, and resistance
levels must occur</em> &#8211; the foundations of electronics (math and algebra) demand
it.</p>
<p>When the circuit is built, the actual levels are measured with a multimeter and
compared to the calculations; if there is a discrepency, this is a signal that
some part within the circuit is faulty.</p>
<p>A computer program is a &#8220;circuit&#8221; that &#8220;runs on&#8221; knowledge, and when we
design the parts (lines) of a computer program, we should include
&#8220;knowledge checks&#8221; that assert the amount of knowledge computed by the program
at various points.
We will learn how to write and insert such knowledge checks, called
<em>assertions</em>, into programs and use the laws of symbolic logic to prove that the
assertions will hold true.</p>
<p>You will see many examples of &#8220;program schematics&#8221; in the upcoming chapters.
Here are two.
First, this little code fragment apparently selects the larger of two integers
and prints it:</p>
<div class="highlight-scala"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">import</span> <span class="nn">org.sireum.logika._</span>
<span class="c1">// the above imports, for example, type Z,</span>
<span class="c1">// which is an arbitrary-precision integer type (i.e., scala.BigInt)</span>
<span class="c1">// for the remaining examples, we&#39;ll elide it</span>

<span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">readInt</span><span class="o">()</span> <span class="c1">// readInt asks an integer from the user via console input</span>
<span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">readInt</span><span class="o">()</span> <span class="c1">// val declares a read-only variable</span>
<span class="k">var</span> <span class="n">max</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="mi">0</span>       <span class="c1">// var declares a read/write variable</span>
<span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">max</span> <span class="k">=</span> <span class="n">x</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
  <span class="n">max</span> <span class="k">=</span> <span class="n">y</span>
<span class="o">}</span>
<span class="n">println</span><span class="o">(</span><span class="s">&quot;Maximum of &quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="s">&quot; and &quot;</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="s">&quot; is &quot;</span><span class="o">,</span> <span class="n">max</span><span class="o">,</span> <span class="s">&quot;.&quot;</span><span class="o">)</span>
</pre></div>
</td></tr></table></div>
<p>Think of the program as a &#8220;circuit&#8221; whose lines are &#8220;wired&#8221; together in
sequence.
Instead of voltage, information or knowledge &#8220;flows&#8221; from one line to the next.
Here is the program&#8217;s &#8220;schematic&#8221; where the internal &#8220;knowledge levels&#8221; are
written in symbolic logic and are inserted within the lines of the program,
enclosed by set braces, <code class="docutils literal"><span class="pre">l&quot;&quot;&quot;{</span> <span class="pre">...</span> <span class="pre">}&quot;&quot;&quot;</span></code>:</p>
<div class="highlight-scala"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">readInt</span><span class="o">()</span>
<span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">readInt</span><span class="o">()</span>
<span class="k">var</span> <span class="n">max</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">l</span><span class="s">&quot;&quot;&quot;{ 1. x &gt; y                   premise     }&quot;&quot;&quot;</span>
  <span class="n">max</span> <span class="k">=</span> <span class="n">x</span>
  <span class="n">l</span><span class="s">&quot;&quot;&quot;{ 1. x &gt; y                   premise</span>
<span class="s">        2. max == x                premise</span>
<span class="s">        3. max ≥ x                 algebra 2</span>
<span class="s">        4. max ≥ y                 algebra 1 3</span>
<span class="s">        5. max ≥ x  ∧  max ≥ y     ∧i 3 4      }&quot;&quot;&quot;</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
  <span class="n">l</span><span class="s">&quot;&quot;&quot;{ 1. ¬(x &gt; y)                premise</span>
<span class="s">        2. y ≥ x                   algebra 1   }&quot;&quot;&quot;</span>
  <span class="n">max</span> <span class="k">=</span> <span class="n">y</span>
  <span class="n">l</span><span class="s">&quot;&quot;&quot;{ 1. max == y                premise</span>
<span class="s">        2. y ≥ x                   premise</span>
<span class="s">        3. max ≥ y                 algebra 1</span>
<span class="s">        4. max ≥ x                 algebra 1 2</span>
<span class="s">        5. max ≥ x  ∧  max ≥ y     ∧i 4 3      }&quot;&quot;&quot;</span>
<span class="o">}</span>
<span class="n">l</span><span class="s">&quot;&quot;&quot;{ 1. max ≥ x  ∧  max ≥ y       premise     }&quot;&quot;&quot;</span>
<span class="n">println</span><span class="o">(</span><span class="s">&quot;Maximum of &quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="s">&quot; and &quot;</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="s">&quot; is &quot;</span><span class="o">,</span> <span class="n">max</span><span class="o">,</span> <span class="s">&quot;.&quot;</span><span class="o">)</span>
</pre></div>
</td></tr></table></div>
<p>The last annotation, <code class="docutils literal"><span class="pre">l&quot;&quot;&quot;{</span> <span class="pre">...</span> <span class="pre">max</span> <span class="pre">&gt;=</span> <span class="pre">x</span> <span class="pre">∧</span> <span class="pre">max</span> <span class="pre">&gt;=</span> <span class="pre">y</span> <span class="pre">...</span> <span class="pre">}&quot;&quot;&quot;</span></code>, is a symbolic-logic
statement that <code class="docutils literal"><span class="pre">max</span></code> is guaranteed to be greater-or-equal to both inputs.
We now know, once the program is implemented, it will behave with this logical
property.</p>
<p>Here is a second example, a complete analysis of a function that squares all the
integers in an array that is passed to it as its argument:</p>
<div class="highlight-scala"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">// Updates parameter a, which is of type array of integers (ZS),</span>
<span class="c1">// in place so that each of its ints are squared</span>
<span class="k">def</span> <span class="n">square</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">ZS</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">l</span><span class="s">&quot;&quot;&quot;{ modifies a</span>
<span class="s">        post     ∀i: (0 ..&lt; a.size)  a(i) == a_in(i) * a_in(i)                  }&quot;&quot;&quot;</span>

  <span class="n">l</span><span class="s">&quot;&quot;&quot;{ 1. a == a_in                                         premise            }&quot;&quot;&quot;</span>

  <span class="k">var</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="n">l</span><span class="s">&quot;&quot;&quot;{ 1. a == a_in                                         premise</span>
<span class="s">        2. x == 0                                            premise</span>
<span class="s">        3. 0 ≤ x                                             algebra 2</span>
<span class="s">        4. 0 ≤ a.size                                        algebra</span>
<span class="s">        5. x ≤ a.size                                        subst2 2 4</span>
<span class="s">        6. {</span>
<span class="s">             7. j: Z</span>
<span class="s">             8. {</span>
<span class="s">                  9. 0 ≤ j ∧ j &lt; x                           assume</span>
<span class="s">                 10. 0 ≤ j                                   ∧e1 9</span>
<span class="s">                 11. j &lt; x                                   ∧e2 9</span>
<span class="s">                 12. ⊥                                       algebra 10 11 2</span>
<span class="s">                 13. a(j) == a_in(j) * a_in(j)               ⊥e 12</span>
<span class="s">                }</span>
<span class="s">            14. 0 ≤ j ∧ j &lt; x -&gt; a(j) == a_in(j) * a_in(j)   →i 8</span>
<span class="s">           }</span>
<span class="s">       15. ∀i: (0 ..&lt; x)  a(i) == a_in(i) * a_in(i)          ∀i 6</span>
<span class="s">       16. {</span>
<span class="s">            17. j: Z</span>
<span class="s">            18. {</span>
<span class="s">                 19. x ≤ j ∧ j &lt; a.size                      assume</span>
<span class="s">                 20. x ≤ j                                   ∧e1 19</span>
<span class="s">                 21. j &lt; a.size                              ∧e2 19</span>
<span class="s">                 22. a(j) == a_in(j)                         algebra 1 2 20 21</span>
<span class="s">                }</span>
<span class="s">            23. x ≤ j ∧ j &lt; a.size → a(j) == a_in(j)         →i 18</span>
<span class="s">           }</span>
<span class="s">       24. ∀i: (x ..&lt; a.size)  a(i) == a_in(i)               ∀i 16              }&quot;&quot;&quot;</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">l</span><span class="s">&quot;&quot;&quot;{ invariant  ∀i: (0 ..&lt; x)  a(i) == a_in(i) * a_in(i)</span>
<span class="s">                     ∀i: (x ..&lt; a.size)  a(i) == a_in(i)</span>
<span class="s">                     0 ≤ x</span>
<span class="s">                     x ≤ a.size</span>
<span class="s">          modifies   x, a                                                       }&quot;&quot;&quot;</span>

    <span class="n">l</span><span class="s">&quot;&quot;&quot;{ 1. ∀i: (0 ..&lt; x)  a(i) == a_in(i) * a_in(i)        premise</span>
<span class="s">          2. ∀i: (x ..&lt; a.size)  a(i) == a_in(i)             premise</span>
<span class="s">          3. 0 ≤ x                                           premise</span>
<span class="s">          4. x ≤ a.size                                      premise</span>
<span class="s">          5. x ≠ a.size                                      premise</span>
<span class="s">          6. x &lt; a.size                                      algebra 4 5        }&quot;&quot;&quot;</span>

    <span class="n">a</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=</span> <span class="n">a</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">*</span> <span class="n">a</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>

    <span class="n">l</span><span class="s">&quot;&quot;&quot;{ 1. a(x) == a_old(x) * a_old(x)                     premise</span>
<span class="s">          2. ∀i: (0 ..&lt; x)  a_old(i) == a_in(i) * a_in(i)    premise</span>
<span class="s">          3. ∀i: (x ..&lt; a_old.size)  a_old(i) == a_in(i)     premise</span>
<span class="s">          4. a.size == a_old.size                            premise</span>
<span class="s">          5. x &lt; a_old.size                                  premise</span>
<span class="s">          6. x &lt; a.size                                      subst2 4 5</span>
<span class="s">          7. ∀i: (x ..&lt; a.size)  a_old(i) == a_in(i)         subst2 4 3</span>
<span class="s">          8. x ≤ x ∧ x &lt; a.size → a_old(x) == a_in(x)        ∀e 7 x</span>
<span class="s">          9. x ≤ x                                           algebra</span>
<span class="s">         10. x ≤ x ∧ x &lt; a.size                              ∧i 9 6</span>
<span class="s">         11. a_old(x) == a_in(x)                             →e 8 10</span>
<span class="s">         12. a(x) == a_in(x) * a_in(x)                       subst1 11 1</span>
<span class="s">         13. ∀q_i: (0 ..&lt; a.size)</span>
<span class="s">               q_i ≠ x → a(q_i) == a_old(q_i)                premise</span>
<span class="s">         14. {</span>
<span class="s">              15. j: Z</span>
<span class="s">              16. 0 ≤ j ∧ j &lt; a.size →</span>
<span class="s">                    (j ≠ x → a(j) == a_old(j))               ∀e 13 j</span>
<span class="s">              17. {</span>
<span class="s">                   18. 0 ≤ j ∧ j ≤ x                         assume</span>
<span class="s">                   19. 0 ≤ j ∧ j &lt; x →</span>
<span class="s">                         a_old(j) == a_in(j) * a_in(j)       ∀e 2 j</span>
<span class="s">                   20. 0 ≤ j                                 ∧e1 18</span>
<span class="s">                   21. j ≤ x                                 ∧e2 18</span>
<span class="s">                   22. {</span>
<span class="s">                        23. j &lt; x                            assume</span>
<span class="s">                        24. 0 ≤ j ∧ j &lt; x                    ∧i 20 23</span>
<span class="s">                        25. a_old(j) == a_in(j) * a_in(j)    →e 19 24</span>
<span class="s">                        26. j &lt; a.size                       algebra 23 6</span>
<span class="s">                        27. j ≠ x                            algebra 23</span>
<span class="s">                        29. 0 ≤ j ∧ j &lt; a.size               ∧i 20 26</span>
<span class="s">                        30. j ≠ x → a(j) == a_old(j)         →e 16 29</span>
<span class="s">                        31. a(j) == a_old(j)                 →e 30 27</span>
<span class="s">                        32. a(j) == a_in(j) * a_in(j)        subst2 31 25</span>
<span class="s">                       }</span>
<span class="s">                   33. {</span>
<span class="s">                        34. j == x                           assume</span>
<span class="s">                        35. a(j) == a_in(j) * a_in(j)        subst2 34 12</span>
<span class="s">                       }</span>
<span class="s">                   36. a(j) == a_in(j) * a_in(j)             ∨e 21 22 33</span>
<span class="s">                  }</span>
<span class="s">              37. 0 ≤ j ∧ j ≤ x → a(j) == a_in(j) * a_in(j)  →i 17</span>
<span class="s">             }</span>
<span class="s">         38. ∀i: (0 .. x) a(i) == a_in(i) * a_in(i)          ∀i 14</span>
<span class="s">         39. 0 ≤ x                                           premise</span>
<span class="s">         40. {</span>
<span class="s">              41. j: Z</span>
<span class="s">              42. 0 ≤ j ∧ j &lt; a.size →</span>
<span class="s">                    (j ≠ x → a(j) == a_old(j))               ∀e 13 j</span>
<span class="s">              43. {</span>
<span class="s">                   44. x + 1 ≤ j ∧ j &lt; a.size                assume</span>
<span class="s">                   45. x + 1 ≤ j                             ∧e1 44</span>
<span class="s">                   46. j &lt; a.size                            ∧e2 44</span>
<span class="s">                   47. 0 ≤ j                                 algebra 45 39</span>
<span class="s">                   48. j ≠ x                                 algebra 45</span>
<span class="s">                   49. 0 ≤ j ∧ j &lt; a.size                    ∧i 47 46</span>
<span class="s">                   50. j ≠ x → a(j) == a_old(j)              →e 42 49</span>
<span class="s">                   51. a(j) == a_old(j)                      →e 50 48</span>
<span class="s">                   52. x ≤ j ∧ j &lt; a.size →</span>
<span class="s">                         a_old(j) == a_in(j)                 ∀e 7 j</span>
<span class="s">                   53. x ≤ j                                 algebra 45</span>
<span class="s">                   54. x ≤ j ∧ j &lt; a.size                    ∧i 53 46</span>
<span class="s">                   55. a_old(j) == a_in(j)                   →e 52 54</span>
<span class="s">                   56. a(j) == a_in(j)                       subst1 55 51</span>
<span class="s">                  }</span>
<span class="s">              57. x + 1 ≤ j ∧ j &lt; a.size → a(j) == a_in(j)   →i 43</span>
<span class="s">             }</span>
<span class="s">         58. ∀i: (x + 1 ..&lt; a.size)  a(i) == a_in(i)         ∀i 40              }&quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">l</span><span class="s">&quot;&quot;&quot;{ 1. x == x_old + 1                                  premise</span>
<span class="s">          2. 0 ≤ x_old                                       premise</span>
<span class="s">          3. x_old &lt; a.size                                  premise</span>
<span class="s">          4. ∀i: (0 .. x_old)  a(i) == a_in(i) * a_in(i)     premise</span>
<span class="s">          5. ∀i: (x_old + 1 ..&lt; a.size)  a(i) == a_in(i)     premise</span>
<span class="s">          6. 0 ≤ x                                           algebra 1 2</span>
<span class="s">          7. x ≤ a.size                                      algebra 1 3</span>
<span class="s">          8. ∀i: (x ..&lt; a.size)  a(i) == a_in(i)             subst2 1 5</span>
<span class="s">          9. {</span>
<span class="s">              10. j: Z</span>
<span class="s">              11. 0 ≤ j ∧ j ≤ x_old →</span>
<span class="s">                    a(j) == a_in(j) * a_in(j)                ∀e 4 j</span>
<span class="s">              12. {</span>
<span class="s">                   13. 0 ≤ j ∧ j &lt; x                         assume</span>
<span class="s">                   14. 0 ≤ j                                 ∧e1 13</span>
<span class="s">                   15. j &lt; x                                 ∧e2 13</span>
<span class="s">                   16. j ≤ x_old                             algebra 15 1</span>
<span class="s">                   17. 0 ≤ j ∧ j ≤ x_old                     ∧i 14 16</span>
<span class="s">                   18. a(j) == a_in(j) * a_in(j)             →e 11 17</span>
<span class="s">                  }</span>
<span class="s">              19. 0 ≤ j ∧ j &lt; x → a(j) == a_in(j) * a_in(j)  →i 12</span>
<span class="s">             }</span>
<span class="s">         20. ∀i: (0 ..&lt; x)  a(i) == a_in(i) * a_in(i)        ∀i 9               }&quot;&quot;&quot;</span>
  <span class="o">}</span>
  <span class="n">l</span><span class="s">&quot;&quot;&quot;{ 1. ∀i: (0 ..&lt; x)  a(i) == a_in(i) * a_in(i)          premise</span>
<span class="s">        2. not (x != a.size)                                 premise</span>
<span class="s">        3. x == a.size                                       algebra 2</span>
<span class="s">        4. ∀i: (0 ..&lt; a.size)  a(i) == a_in(i) * a_in(i)     subst1 3 1         }&quot;&quot;&quot;</span>
<span class="o">}</span>
</pre></div>
</td></tr></table></div>
<p>You are not expected to understand the above, but the function&#8217;s
<code class="docutils literal"><span class="pre">post</span></code>-condition list the guarantees of what goes out for any given
array of integers.
In this case, &#8220;what goes out&#8221; is an array whose elements are squared &#8211;
it is guaranteed to work, because it was analyzed the same way an electronics
engineer analyzes a circuit.</p>
<p>If the above somehow looks daunting, here is a shorter proof that leverages
<a class="reference internal" href="../../doc/01-getting-started/index.html#auto-mode"><span>Logika&#8217;s automation</span></a>:</p>
<div class="highlight-scala"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="n">square</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">ZS</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">l</span><span class="s">&quot;&quot;&quot;{ modifies     a</span>
<span class="s">        post         ∀i: (0 ..&lt; a.size)  a(i) == a_in(i) * a_in(i)              }&quot;&quot;&quot;</span>

  <span class="k">var</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">l</span><span class="s">&quot;&quot;&quot;{ invariant  ∀i: (0 ..&lt; x)  a(i) == a_in(i) * a_in(i)</span>
<span class="s">                     ∀i: (x ..&lt; a.size)  a(i) == a_in(i)</span>
<span class="s">                     0 ≤ x</span>
<span class="s">                     x ≤ a.size</span>
<span class="s">          modifies   x, a                                                       }&quot;&quot;&quot;</span>

    <span class="n">a</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=</span> <span class="n">a</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">*</span> <span class="n">a</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>

    <span class="n">l</span><span class="s">&quot;&quot;&quot;{ 1. x &lt; a.size                                                auto</span>
<span class="s">          2. ∀i: (0 .. x)  a(i) == a_in(i) * a_in(i)                   auto</span>
<span class="s">          3. ∀i: (x + 1 ..&lt; a.size)  a(i) == a_in(i)                   auto     }&quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table></div>
<hr class="docutils" />
<p align=right><small><em>
This note was adapted from David Schmidt's CIS 301, 2008,
<a href="http://people.cis.ksu.edu/~schmidt/301s14/Lectures/introT.html">Chapter 00</a>
course note.
</em></small></p></div>


    </div>
      
  </div>
</div>

  </body>
</html>