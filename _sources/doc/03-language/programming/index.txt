.. raw:: html

   <br/>
   <font color="darkgray">
   <big><big><b>
   Sireum Logika Documentation &mdash; <a href="../index.html">3. The Logika Formal Input Language</a>
   </b></big></big>
   </font>
   <br/>
   <font color="black">
   <big><big><big><big><b>
   3.4. Programming Logic
   </b></big></big></big></big>
   </font>

.. _programming-language:

Programming Logic
*****************

Logika's programming logic input language differs from its
propositional and predicate logics' in one main characteristic:
variable and function types have to be explicitly specified.

It has three built-in types:
(1) ``B`` -- boolean type,
(2) ``Z`` -- arbitrary-precision integer type, and
(3) ``ZS`` -- mutable integer sequence (array) type
(whose index and element type is ``Z`` with indices starting
at ``0``). There is no ``null`` value in Logika, which simplifies
reasoning.

In addition, in contrast to regular Scala,
Logika's programming language separates between
commands (statements) and queries (expressions).
(In Scala, commands are simply expressions whose return value is of
``Unit`` type.)
Logika statements are evaluated for their side effect, and
expressions are evaluated purely for their resulting value
(side-effect free -- they do not change values stored in variables).

The following pattern notation is used to describe a statement's side-effects
(similar to :ref:`schematic-pattern`, but enclosed in ``l"""`` … ``"""`` to
distinguish it from statement blocks):

.. literalinclude:: claim-transformation-notation.txt
   :language: scala
   :caption: **Statement Claim Transformation Rule Notation**
   :name: claim-transformation-notation

``P`` represents any claim that holds (is true) before the statement (precondition)
and ``R`` represents any claim that holds after the statement (postcondition).
The notation uses an identifier such as ``P`` and ``R`` to represent
multiple claims.

In essence, a statement is a claim transformer -- a function that transforms
its precondition to its postcondition.
To relate to program execution,
the precondition essentially characterizes the program state before the statement is executed,
and the postcondition characterizes the program state after the statement is executed.
Thus, the whole program execution can be characterized by composing the claim transformations
done by each of the program statements.

As a convention:

* ``P``, ``Q``, and ``R`` are used to represent claims.

* ``X`` and ``Y`` are used to represent variable identifiers.

* ``ZS`` (prefix) is used to represent variable identifiers of type ``ZS``.

* ``T`` is used to represent a type.

* ``F`` is used to represent a function/method identifier.

* ``E`` is used to represent a general expression.

* ``C`` is used to represent a command/statement or a sequence of statements.

The subsequent sections describe Logika's renditions of programming
logic rules that are described in
:ref:`algebra`, :ref:`programming-logic`, :ref:`functions-procedures`,
and :ref:`loops-invariants-induction`.

Program
=======

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 1 - 12

A Logika program can be empty, or
it consists of an import statement followed
by a zero or more program elements.
A program element can be either
a :ref:`prog-statement`,
an :ref:`prog-invariant`,
a :ref:`prog-method-decl`,
or a :ref:`prog-fact` (axiom or proof function).

Similar to Java or Scala, methods can be forward-referenced
(referenced before their declaration).
In addition, axioms and proof functions defined in
:ref:`prog-fact` can also be forward-referenced.

.. _prog-statement:

Statement
=========

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 60 - 72

A Logika statement can be either
a :ref:`prog-var-assign`,
an :ref:`prog-assert`,
an :ref:`prog-conditional`,
a :ref:`prog-while-loop`,
a :ref:`prog-seq-assign`,
a :ref:`prog-print` statement,
a :ref:`prog-proof`, or
a :ref:`prog-sequent`.
Method invocation ``invoke`` is discussed in :ref:`prog-invoke`.

.. _prog-var-assign:

Variable Declaration and Assignment
-----------------------------------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 60 - 63, 26 - 29, 73 - 78, 98 - 101

A variable declaration is a special assignment form that also declares
the variable that it assigns at the same time.
The variable has to be declared as either read-only (using the ``val`` keyword) --
which cannot be reassigned later on, or read/write (using the ``var`` keyword).
Note a variable cannot be forward-referenced.

The claim transformation rule for a variable declaration is the same as for
assignment.
Below are the claim transformation rules for an assignment based on
the form of its right-hand side (``rhs``).
Note that any claim referring to the generated ``_old`` variable is *transient*;
it does not survive the next (non-proof/sequent) statement. Thus,
such claim has to be transformed in a :ref:`prog-proof`/:ref:`prog-sequent`
statement in order for the information that it contains to be propagated.

.. literalinclude:: var-assign-exp-rule.txt
   :language: scala
   :caption: **Variable Assignment Rule**
   :name: var-assign-exp-rule

The :ref:`var-assign-exp-rule` indicates that any claim in its precondition
is rewritten by substituting the assigned variable ``X`` with the newly
introduced variable ``X_old`` that stores the value of ``X`` before the
assignment, and the value of ``X`` is now equal to the value of expression
``E`` (which leverages the fact that any Logika expression is pure --
side-effect free).

To avoid aliasing issues of mutable objects that complicate reasoning,
Logika forces ``ZS`` to be cloned (resulting in a new object copy of the sequence)
when assigned to a different variable.
That is, ``X = Y`` are ill-formed if ``X`` and ``Y`` are of type ``ZS``.
The ``ZS`` cloning rule is as follows.

.. literalinclude:: var-assign-clone-rule.txt
   :language: scala
   :caption: **ZS Cloning Rule**
   :name: var-assign-clone-rule

``ZS`` variable can also be assigned as a result of ``ZS``
appending operation
(``E ≡ E1 :+ E2``, where ``E1`` is of type ``ZS`` and ``E2`` is of type ``Z``)
or prepending operation
(``E ≡ E1 +: E2``, where ``E1`` is of type ``Z`` and ``E2`` is of type ``ZS``),
both of which also produce a new ``ZS`` object.

The ``readInt`` built-in function asks for an integer input through the program
console input (an optional string literal prompt ``STRING`` can be provided to
display a custom message). Since the resulting integer value depends on
the user input, which cannot be predicted, there is no claim that can be stated
regarding the value the can be deduced,
which is reflected in :ref:`var-assign-readint-rule`.

.. literalinclude:: var-assign-readint-rule.txt
   :language: scala
   :caption: **readInt Rule**
   :name: var-assign-readint-rule

The ``randomInt`` built-in function generates a random integer value.
Similar to ``readInt``, there is no claim that can be stated regarding the value.

.. literalinclude:: var-assign-randomint-rule.txt
   :language: scala
   :caption: **randomInt Rule**
   :name: var-assign-randomint-rule

The rule for ``invoke`` is discussed in :ref:`prog-invoke`
(just replace occurrence of ``F_result`` in the rules with the assigned variable
identifier ``X``).

.. _prog-assert:

Assertion and Assumption
------------------------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 228, 64 - 65

In Scala, both assertion and assumption check whether
the specified boolean expression is true;
if not, it throws an ``AssertionError`` (if assertion
checking is enabled).

The two differ in the intention behind it for verification
purposes.
Assertion's expression has to be proven (i.e.,
``E`` is required as a precondition of :ref:`assert-rule`),
while assumption's expression can be taken as an axiom
(i.e., ``E`` is not required as
a precondition of :ref:`assume-rule`, but can be concluded
in the postcondition).
When a program has been verified, all assertions can be
safely erased.

.. literalinclude:: assert-rule.txt
   :language: scala
   :caption: **Assertion Rule**
   :name: assert-rule

.. literalinclude:: assume-rule.txt
   :language: scala
   :caption: **Assumption Rule**
   :name: assume-rule


.. _prog-conditional:

If-Else Conditional
-------------------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 228, 66, 79 - 84

Logika's conditional can omit the else-branch, in which case
it is treated as an empty statement block.

The :ref:`if-else-rule` specifies that
its precondition ``P`` hold in the beginning of
both branches. In the true-branch, the conditional
test expression ``E`` can be deduced, while
its negation ``¬E`` can be deduced in the false-branch.
At the end of the conditional,
the claim ``R1 ∨ R2`` can be deduced, where ``R1`` is
the postcondition of ``C1`` and ``R2`` is the postcondition
of ``C2`` (if there no such ``C2``, then ``R2`` represents ``P`` and ``¬E``).
If ``R1 ≡ R2``, then one can also deduce just ``R1``.

.. literalinclude:: if-else-rule.txt
   :language: scala
   :caption: **If-Else Conditional Rule**
   :name: if-else-rule


.. _prog-while-loop:

While-Loop
----------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 228, 67, 85 - 97, 51 - 54

While-loops in Logika can include a loop invariant and a modifies clause
(verified programs most likely include loop invariants and modifies clauses).

The loop invariant specifies the condition that has to be true before (hence, at the beginning of the loop body)
and after the statement. At the end of the loop body, the invariant has to be proven to be true.
These are reflected in :ref:`while-loop-rule`.

The invariant can be specified as a sequence of boolean claim expressions; they implicitly form a conjunction
where each claim is a conjunct.
The main benefit of separating the invariant into several expressions is that Logika can specifically pinpoint
which invariant conjunct has yet to be proven as one works through the verification process.
In the case that no loop invariant is specified, then it is considered as ``⊤``.

The modifies clause should comprehensively lists all variables that may be modified by the loop body.
The program is ill-formed if the loop body modifies a variable, but it is not listed in the modifies clause.
The set of variables that are modified include variables that are assigned in the loop, modified by nested loops,
and side-effects of method invocations.

A loop precondition ``P`` is also treated as an invariant if it does not refer to any of the
variables listed in the loop's modifies clause.
The loop test condition ``E`` holds at the beginning of the loop body, and its negation ``¬E`` is a
postcondition of loop.

.. literalinclude:: while-loop-rule.txt
   :language: scala
   :caption: **While-Loop Rule**
   :name: while-loop-rule

.. _prog-seq-assign:

Sequence Element Assignment
---------------------------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 228, 68

A ``ZS`` sequence value stored in a variable ``X`` can be mutated by updating
one of its elements at a certain index expressed by ``E1`` with a new value
expressed by an expression ``E2`` (see :ref:`seq-assign-rule`).

The avoid runtime errors, ``E1`` has to be within the bound of
``X``'s indices, i.e., ``0 ≤ E1`` and ``E1 < X.size``; thus,
they are required as the statement's precondition.

At the postcondition, ``E1`` and ``E2`` and all precondition claims are rewritten to refer to
``X_old`` if they refer to ``X``.
Similar to the variable assignment rules, any claim referring to the generated
``_old`` variable is transient.

The update does not change the size of ``X``, thus, one can deduce ``X.size == X_old.size``.
Furthermore, only the updated element got changed to the new value.

.. literalinclude:: seq-assign-rule.txt
   :language: scala
   :caption: **Sequence Element Assignment Rule**
   :name: seq-assign-rule


.. _prog-print:

Print
-----

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 228, 69, 102 - 107

The ``print`` and ``println`` built-in methods are
provided for logging purposes (albeit primitive ones).
They are n-ary methods accepting any number of arguments,
which can be string literals, and
``B``,  ``Z``, and ``ZS`` values.

Logika does not reason about their side-effects as they are
tangential to Logika's verification focus.

For example, a Logika verified program may still be unsafe
if the program console output is piped through a disk and
as it turns out, the disk does not have enough space for the
printed text. (Similarly, Logika does not guarantee that
a program cannot be out of memory.)

At any rate, the two methods do not change program states so
any claim in the precondition can be deduced in
the postcondition.

.. literalinclude:: print-rule.txt
   :language: scala
   :caption: **Print Rule**
   :name: print-rule


.. _prog-proof:

Proof
-----

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 228, 70, 126 - 144

A proof statement contains a natural deduction proof similar to a proof in
:ref:`predicate-language` and :ref:`propositional-language`.
It can be used to deduce new claims from existing/transient claims
(e.g., to satisfy the next statement's precondition).

The behavior of a proof statement differs on whether the :ref:`auto-mode` is
enabled.
When enabled, the proof statement *adds* its deduced claims to existing ones.
Otherwise, it *replaces* existing ones with its deduce claims, which
results in a Logika program where all deductions necessary to verify the program
are forced to be explicitly written (and proof statements intermingled with
non-proof/sequent statements as a side-effect).

Note that the deduced claims of a proof statement consists of all claims in regular
proof steps at the proof-level (i.e., claims in sub-proofs are excluded).

.. _prog-sequent:

Sequent
-------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 228, 71, 145 - 154

A sequent statement can only be used in :ref:`auto-mode`.
While the form is similar to the ones in :ref:`predicate-language`
and :ref:`propositional-language`, it has a different purpose in
Logika's programming logic.
That is, it serves as a convenient syntactic sugar for
:ref:`prog-auto`.

There are two ways the form can be used:
with or without premises.

When some premises are specified to automatically conclusions, such as:

.. code-block:: scala

   l"""premise1,  …,  premiseN  ⊢  conclusion1,  …, conclusionM"""

it desugars to the following proof statement:

.. literalinclude:: sequent-premise-sugar.txt
   :language: scala

When no premise is specified, such as:

.. code-block:: scala

   l"""⊢  conclusion1,  …, conclusionM"""

it desugars to the following proof statement:

.. literalinclude:: sequent-no-premise-sugar.txt
   :language: scala



Expression
==========

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 109 - 126, 100 - 101

Logika's expression in the programming context is a subset of
its claim expression language in the proof context
in that it does not support math symbols and quantifications.

It supports typical operators on integer values.
The integer literal form ``NUM`` can only be used for
value up to 2` :sup:`31` - 1;
otherwise the ``Z(STRING)`` form
(e.g., ``Z("2147483648")``, ``Z("-2147483649")``)
has to be used instead.
This is because Scala's integer literal by default is
a 32-bit signed integer.
Logika detects the erroneous situation when
``NUM`` is used for integers that cannot fit into 32-bit.
It also detects expressions involving 32-bit integer literal
that result in values that do not fit into 32-bit such
as ``1 + 2147483647`` and signal an error; this is because
such expression can be optimized to a 32-bit integer value
when compiled (but overflows/underflows).

The ``ZS(`` … ``)`` literal form is used to create a ``ZS``
object whose elements are listed.
For example ``ZS(2, 5, 3)`` creates a ``ZS`` object whose
size is 3 and the element 2 at index 0, 5 at index 1, and
3 at index 2. The ``ZS`` append (``:+``) and prepend
(``+:``) operations create a new ``ZS`` object from an
existing one.

Unlike a sequence element update, ``:+`` and ``+:`` are
are directly represented in the proof context.
For example,

.. code-block:: scala

   X = Y :+ 2

generates a postcondition claim ``X == Y :+ 2`` instead of::

    X.size == Y.size + 1
    X(Y.size) == 2
    ∀q_i: (0 ..< Y.size)  X(q_i) == Y(q_i)

The first two claims can be "extracted" using ``algebra``
and the last claim can only be extracted using ``auto``.
This means fully reasoning about ``:+`` and ``+:`` can
only be done by enabling :ref:`auto-mode`.
This is done by design instead of due to the Logika's
limitation; at some point, it is best to switch to
a more automatic/machine-assisted approach in order not
overwhelm oneself with mundane details.

One last thing to note is that ``&`` and ``|`` operators
are logical-and and logical-or operators instead of
the short-circuit ``&&`` and ``||`` operators used in
many languages such as Java.

The rest of the operatoions have similar meaning to
other programming languages.

Runtime Checks
--------------

Some operators such as ``/`` and ``%`` are not defined
on certain argument values (i.e., when the divisor is
zero).
Such situations are typically checked at runtime
(e.g., in Java, the VM throws an ``ArithmeticException``
for a division by zero).

Instead, Logika requires precondition claims to avoid such
issue when certain expressions are used in the programming
context.

Below are the list of expressions that require some
precondition related to runtime errors:

* ``E1 / E2`` requires ``E2 ≠ 0``.

* ``E1 % E2`` requires ``E2 ≠ 0``.

* ``X(E)`` requires ``0 ≤ E`` and ``E < X.size``.

When :ref:`auto-mode` is enabled,
:ref:`auto <prog-auto>` is implicitly used to satisfy
all the above preconditions whenever possible.

.. _prog-invariant:

Invariant
=========

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 31 - 33

The invariant statement declares global invariants
that the program's (non-helper)
:ref:`methods <prog-method-decl>` have to maintain.
Similar to a :ref:`loop invariant <prog-while-loop>`,
the invariant claim expression conjuncts can be
specified separately.

The claim expressions have to be proven true before
the invariant statements.
When :ref:`auto-mode` is enabled,
:ref:`auto <prog-auto>` is implicitly used to satisfy
all the invariant claims whenever possible.


.. _prog-method-decl:

Method Declaration
==================

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 35 - 58

A Logika method can have an associated contract that specifies its ``precondition``
(claims that have to be true in order for the method to properly function),
``modifies`` clause (that comprehensively lists all variables that will be modified
by the method during its execution, similar to the modifies clause in
the modifies clause in :ref:`loop invariants <prog-while-loop>`), and
``postcondition`` (claims that the method has to satisfy once it finishes executing).
If the precondition or the postcondition are not specified, then they are treated
as ``⊤``. Moreover, if the modifies clause is not specified, that means the
method does not modify any variable (pure).

There are two kinds of methods in Logika: helper and regular (non-helper) methods;
helper methods are declared by using the ``@helper`` annotation, and regular
ones are those without the annotation.
Regular methods maintain the program global :ref:`prog-invariant`,
while helper methods do not have to.

That is, a regular method:
(1) can assume the program global invariant when it starts to execute,
(2) do not have to maintain the invariant during its execution, and
(3) have to re-establish the invariant by the end of its execution;
these are reflected in :ref:`method-decl-rule`.
In essence, the invariant claims are both precondition claims and postcondition claims
of regular methods.

.. literalinclude:: method-decl-rule.txt
   :language: scala
   :caption: **Method Declaration Rule**
   :name: method-decl-rule

On the other hand, helper methods:
(1) cannot assume the program global invariant when it starts to execute,
(2) do not have to maintain the invariant during its execution, and
(3) do not have to establish the invariant by the end of its execution;
these are reflected in :ref:`method-decl-helper-rule`.

.. literalinclude:: method-decl-helper-rule.txt
   :language: scala
   :caption: **Helper Method Declaration Rule**
   :name: method-decl-helper-rule

Helper and regular methods have some similarities. That is:

A. Each of them can assume ``PRE`` before it starts executing.

B. For any modified variable ``XI``, it can assume ``XI == XI_in`` before
   it starts executing. The ``_in`` variables represent the corresponding
   variable values before they are modified during the execution, and they
   can be referred in claim expressions (in proof context) throughout the
   method's body and in its postcondition claims.

C. The method has to establish ``POST``.
   If the method's return type is not ``Unit``, it has to ``return`` a value,
   expressed by ``E`` and stored in the special variable ``result``.
   The variable ``result`` can be used on ``POST``;
   hence, at the end of the method ``[E/result]POST`` has to be established.

.. _prog-invoke:

Method Invocation
=================

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 98 - 101

.. literalinclude:: method-invoke-rule.txt
   :language: scala
   :caption: **Method Invocation Rule**
   :name: method-invoke-rule

.. literalinclude:: method-invoke-helper-rule.txt
   :language: scala
   :caption: **Helper Method Invocation Rule**
   :name: method-invoke-helper-rule

.. _prog-fact:

Fact
====

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 13 - 29

Extended Assume Step
====================

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 157 - 160
   :emphasize-lines: 2 - 4

Extended Claim Expression
=========================

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 162 - 196
   :emphasize-lines: 4 - 8, 11, 13 - 23, 27 - 29

Extended Justification and Inference Rules
==========================================

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 198 - 220
   :emphasize-lines: 7, 14 - 23

Or-Elimination (∨e)
-------------------

The ∨e patterns now work for ``≤`` and ``≥``,
where ``E1 ≤ E2`` is treated as ``E1 < E2  ∨  E1 == E2`` and
``E1 ≥ E2`` is tread as ``E1 > E2  ∨  E1 == E2``.

Quantified Claim Inference Rules (∀i, ∀e, ∃i, ∃e)
-------------------------------------------------

Quantifications using the integer range domain form
are simplified first before applying quantified
claim inference rules.

For example, the claim ``∀x: (0 ..< 3) P{x}`` is
simplified first to ``∀x: Z  0 ≤ x ∧ x < 3  →  P{x}``
before applying any of the ∀-quantified claim rules.

Fact (fact)
-----------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 227, 216

.. literalinclude:: fact-rule.txt
   :language: scala
   :caption: **Fact Schematic Pattern**
   :name: fact-rule

Invariant (invariant)
---------------------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 227, 217

.. literalinclude:: invariant-rule.txt
   :language: scala
   :caption: **Invariant Schematic Pattern**
   :name: invariant-rule

Substitutions (subst1 and subst2)
---------------------------------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 227, 218 - 219

.. literalinclude:: subst1-rule.txt
   :language: scala
   :caption: **Substitution1 (subst1) Schematic Pattern**
   :name: subst1-rule

.. literalinclude:: subst2-rule.txt
   :language: scala
   :caption: **Substitution2 (subst1) Schematic Pattern**
   :name: subst2-rule


Summonings
==========

Logika summonings are special justifications;
they are distinguished because the deduction is checked by
leveraging the work of giants such as using Z3
(see
`a classical example <https://www.youtube.com/embed/gb2zIR2rvRQ?rel=0&autoplay=1&start=30>`__ or
`a modern example <https://www.youtube.com/embed/Qs51cQUuEOM?rel=0&autoplay=1&start=280>`__
on how summoning works).


Algebra (algebra)
-----------------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 227, 220

.. literalinclude:: algebra-rule.txt
   :language: scala
   :caption: **Algebra Schematic Pattern (with some arguments)**
   :name: algebra-rule

.. literalinclude:: algebra-empty-rule.txt
   :language: scala
   :caption: **Algebra Schematic Pattern (without argument)**
   :name: algebra-empty-rule

.. _prog-auto:

Auto (auto)
-----------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 227, 221

.. literalinclude:: auto-rule.txt
   :language: scala
   :caption: **Auto Schematic Pattern (with some arguments)**
   :name: auto-rule

.. literalinclude:: auto-empty-rule.txt
   :language: scala
   :caption: **Auto Schematic Pattern (without argument)**
   :name: auto-empty-rule


Well-formed-ness
================


Programming Logic Input Language Grammar
========================================

Note that extended language elements from
that of the :ref:`pred-grammar` are highlighted.

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 1 - 221
   :emphasize-lines: 158 - 160, 165 - 169, 172, 174 - 184, 188 - 190, 205, 212 - 221
