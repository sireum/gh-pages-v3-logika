.. raw:: html

   <br/>
   <font color="darkgray">
   <big><big><b>
   Sireum Logika Documentation &mdash; <a href="../index.html">3. The Logika Formal Input Language</a>
   </b></big></big>
   </font>
   <br/>
   <font color="black">
   <big><big><big><big><b>
   3.4. Programming Logic
   </b></big></big></big></big>
   </font>

.. _programming-language:

Programming Logic
*****************

Logika's programming logic input language differs from its
propositional and predicate logics' in one main characteristic:
variable and function types have to be explicitly specified.

It has three built-in types:
(1) ``B`` -- boolean type,
(2) ``Z`` -- arbitrary-precision integer type, and
(3) ``ZS`` -- mutable integer sequence (array) type
(whose index and element type is ``Z`` with indices starting
at ``0``).

In contrast to regular Scala,
Logika's programming language separates between
commands (statements) and queries (expressions).
(In Scala, commands are expressions whose return value is of
``Unit`` type.)
Logika statements are evaluated for their side effect, and
expressions are evaluated purely for their resulting value
(side-effect free -- they do not change values stored in variables).

The following pattern notation is used to describe a statement's side-effects:

.. literalinclude:: claim-transformation-notation.txt
   :language: scala
   :caption: **Statement Claim Transformation Rule Notation**
   :name: claim-transformation-notation

``P`` represents any claim that holds (is true) before the statement (precondition)
and ``R`` represents any claim that holds after the statement (postcondition).
The notation uses an identifier such as ``P`` and ``R`` to represent
multiple claims.

In essence, a statement is a claim transformer -- a function that transforms
its precondition to its postcondition.
To relate to program execution,
the precondition essentially characterizes the program state before the statement is executed,
and the postcondition characterizes the program state after the statement is executed.
Thus, the whole program execution can be characterized by composing the claim transformations
done by each of the program statements.

As a convention:

* ``P``, ``Q``, and ``R`` are used to represent claims.

* ``X`` and ``Y`` are used to represent variable identifiers.

* ``ZS`` (prefix) is used to represent variable identifiers of type ``ZS``.

* ``T`` is used to represent a type.

* ``F`` is used to represent function/method identifier.

* ``E`` is used to represent a general expression.

* ``C`` is used to represent a command/statement or a sequence of statements.


Program
=======

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 1 - 12

A Logika program can be empty, or
it consists of an import statement followed
by a zero or more program elements.
A program element can be either
a :ref:`prog-statement`,
an :ref:`prog-invariant`,
a :ref:`prog-method-decl`,
or a :ref:`prog-fact` (axiom or proof function).

Similar to Java or Scala, methods can be forward-referenced
(referenced before their declaration).
In addition, axioms and proof functions defined in
:ref:`prog-fact` can also be forward-referenced.

.. _prog-statement:

Statement
=========

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 60 - 72

A Logika statement can be either
a :ref:`prog-var-assign`,
an :ref:`prog-assert`,
an :ref:`prog-conditional`,
a :ref:`prog-while-loop`,
a :ref:`prog-seq-assign`,
a :ref:`prog-print` statement,
a :ref:`prog-proof`, or
a :ref:`prog-sequent`.
Method invocation ``invoke`` is discussed in :ref:`prog-invoke`.

.. _prog-var-assign:

Variable Declaration and Assignment
-----------------------------------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 60 - 63, 26 - 29, 73 - 78, 98 - 101

A variable declaration is a special assignment form that also declares
the variable that it assigns at the same time.
The variable has to be declared as either read-only (using the ``val`` keyword) --
which cannot be reassigned later on, or read/write (using the ``var`` keyword).
Note a variable cannot be forward-referenced.

The claim transformation rule for a variable declaration is the same as for
assignment.
Below are the claim transformation rules for an assignment based on
the form of its right-hand side (``rhs``).
Note that any claim referring to the generated ``_old`` variable does not
survive the next statement.

.. literalinclude:: var-assign-exp-rule.txt
   :language: scala
   :caption: **Variable Assignment Rule**
   :name: var-assign-exp-rule

.. literalinclude:: var-assign-clone-rule.txt
   :language: scala
   :caption: **Sequence Cloning Rule**
   :name: var-assign-clone-rule

.. literalinclude:: var-assign-readint-rule.txt
   :language: scala
   :caption: **readInt Rule**
   :name: var-assign-readint-rule

.. literalinclude:: var-assign-randomint-rule.txt
   :language: scala
   :caption: **randomInt Rule**
   :name: var-assign-randomint-rule

The rule for ``invoke`` is discussed in :ref:`prog-invoke`
(replace ``F_result`` in the rules with the assigned variable identifier).

.. _prog-assert:

Assertion and Assumption
------------------------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 228, 64 - 65

.. literalinclude:: assert-rule.txt
   :language: scala
   :caption: **Assertion Rule**
   :name: assert-rule

.. literalinclude:: assume-rule.txt
   :language: scala
   :caption: **Assumption Rule**
   :name: assume-rule


.. _prog-conditional:

If-Else Conditional
-------------------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 228, 66, 79 - 84

.. literalinclude:: if-else-rule.txt
   :language: scala
   :caption: **If-Else Conditional Rule**
   :name: if-else-rule


.. _prog-while-loop:

While-Loop
----------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 228, 67, 85 - 97, 51 - 54

.. literalinclude:: while-loop-rule.txt
   :language: scala
   :caption: **While-Loop Rule**
   :name: while-loop-rule

.. _prog-seq-assign:

Sequence Element Assignment
---------------------------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 228, 68

.. literalinclude:: seq-assign-rule.txt
   :language: scala
   :caption: **Sequence Element Assignment Rule**
   :name: seq-assign-rule

Note that any claim referring to the generated ``_old`` variable does not
survive the next statement.

.. _prog-print:

Print
-----

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 228, 69, 102 - 107

.. literalinclude:: print-rule.txt
   :language: scala
   :caption: **Print Rule**
   :name: print-rule


.. _prog-proof:

Proof
-----

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 228, 70, 126 - 144

.. _prog-sequent:

Sequent
-------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 228, 71, 145 - 154

Expression
==========

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 109 - 125

Runtime Checks
--------------


.. _prog-invariant:

Invariant
=========

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 31 - 33

.. _prog-method-decl:

Method Declaration
==================

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 35 - 58

.. literalinclude:: method-decl-rule.txt
   :language: scala
   :caption: **Method Declaration Rule**
   :name: method-decl-rule

.. literalinclude:: method-decl-helper-rule.txt
   :language: scala
   :caption: **Helper Method Declaration Rule**
   :name: method-decl-helper-rule

.. _prog-invoke:

Method Invocation
=================

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 98 - 101

.. literalinclude:: method-invoke-rule.txt
   :language: scala
   :caption: **Method Invocation Rule**
   :name: method-invoke-rule

.. literalinclude:: method-invoke-helper-rule.txt
   :language: scala
   :caption: **Helper Method Invocation Rule**
   :name: method-invoke-helper-rule

.. _prog-fact:

Fact
====

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 13 - 29

Extended Assume Step
====================

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 156 - 159
   :emphasize-lines: 2 - 4

Extended Claim Expression
=========================

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 161 - 195
   :emphasize-lines: 4 - 8, 11, 13 - 23, 27 - 29

Extended Justification and Inference Rules
==========================================

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 197 - 219
   :emphasize-lines: 7, 14 - 23

Or-Elimination (∨e)
-------------------

The ∨e patterns now work for ``≤`` and ``≥``,
where ``E1 ≤ E2`` is treated as ``E1 < E2  ∨  E1 == E2`` and
``E1 ≥ E2`` is tread as ``E1 > E2  ∨  E1 == E2``.

Quantified Claim Inference Rules (∀i, ∀e, ∃i, ∃e)
-------------------------------------------------

Quantifications using the integer range domain form
are simplified first before applying quantified
claim inference rules.

For example, the claim ``∀x: (0 ..< 3) P{x}`` is
simplified first to ``∀x: Z  0 ≤ x ∧ x < 3  →  P{x}``
before applying any of the ∀-quantified claim rules.

Fact (fact)
-----------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 226, 215

.. literalinclude:: fact-rule.txt
   :language: scala
   :caption: **Fact Rule**
   :name: fact-rule

Invariant (invariant)
---------------------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 226, 216

.. literalinclude:: invariant-rule.txt
   :language: scala
   :caption: **Invariant Rule**
   :name: invariant-rule

Substitutions (subst1 and subst2)
---------------------------------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 226, 217 - 218

.. literalinclude:: subst1-rule.txt
   :language: scala
   :caption: **Substitution1 (subst1) Rule**
   :name: subst1-rule

.. literalinclude:: subst2-rule.txt
   :language: scala
   :caption: **Substitution2 (subst1) Rule**
   :name: subst2-rule


Summonings
==========

Logika summonings are special justifications;
they are distinguished because the deduction is checked by
leveraging the work of giants such as using Z3
(see
`a classical example <https://www.youtube.com/embed/gb2zIR2rvRQ?rel=0&autoplay=1&start=30>`__ or
`a modern example <https://www.youtube.com/embed/Qs51cQUuEOM?rel=0&autoplay=1&start=280>`__
on how summoning works).


Algebra (algebra)
-----------------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 226, 219

.. literalinclude:: algebra-rule.txt
   :language: scala
   :caption: **Algebra Rule (with some arguments)**
   :name: algebra-rule

.. literalinclude:: algebra-empty-rule.txt
   :language: scala
   :caption: **Algebra Rule (without argument)**
   :name: algebra-empty-rule

.. _prog-auto:

Auto (auto)
-----------

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 226, 220

.. literalinclude:: auto-rule.txt
   :language: scala
   :caption: **Auto Rule (with some arguments)**
   :name: auto-rule

.. literalinclude:: auto-empty-rule.txt
   :language: scala
   :caption: **Auto Rule (without argument)**
   :name: auto-empty-rule


Well-formed-ness
================


Programming Logic Input Language Grammar
========================================

Note that extended language elements from
that of the :ref:`pred-grammar` are highlighted.

.. literalinclude:: programming.txt
   :language: antlr
   :lines: 1 - 220
   :emphasize-lines: 157 - 159, 164 - 168, 171, 173 - 183, 187 - 189, 204, 211 - 220
