.. raw:: html

   <br/>
   <font color="darkgray">
   <big><big><b>
   Sireum Logika Documentation &mdash; <a href="../index.html">3. The Logika Formal Input Language</a>
   </b></big></big>
   </font>
   <br/>
   <font color="black">
   <big><big><big><big><b>
   3.2. Propositional Logic
   </b></big></big></big></big>
   </font>

.. _propositional-language:

Propositional Logic
*******************

**Propositional Logic Input Language Grammar**

.. literalinclude:: propositional.txt
   :language: antlr
   :lines: 1

The propositional logic input language consists of two main parts:
(1) a sequent, which is followed by (2) a proof of the
sequent.

An example input has been shown in the :ref:`logika-examples` section.

Sequent
=======

.. literalinclude:: propositional.txt
   :language: antlr
   :lines: 3-6

A sequent consists of premises (optional) and conclusions that are
separated either by a turnstile ``⊢`` or a horizontal line
(``HLINE``, i.e., three or more continuous dashes ``-``).
In the former, the premise and conclusion expressions are
separated by a comma ``,``; the latter separates them using
whitespaces (newlines are considered as whitespaces inside
sequents).

Here is an example of sequent written using the turnstile notation.

.. literalinclude:: propositional-1a.logika
   :language: none
   :lines: 1

An equivalent sequent to that written using the horizontal line
notation is as follows.

.. literalinclude:: propositional-1b.logika
   :language: none
   :lines: 1-3

Either way to express a sequent is fine; it is just a matter of style.

Proof
=====

.. literalinclude:: propositional.txt
   :language: antlr
   :lines: 8-23

A proof consists of a sequence of proof steps delimited by curly braces
``{`` ... ``}``; the proof steps should be separated by newline(s).

Each proof step in the whole proof should be *uniquely*
``NUM``\ bered (but can be out of order), and it is either:
(a) a regular proof step (atomic), or (b) a sub-proof (composite).
(Regular step number ``rNUM`` and sub-proof number ``sNUM`` are
``NUM`` :ref:`literals <ops-literals>`, but distinguished here to
increase readability of the :ref:`justification grammar that applies inference rules <prop-rules>`
later.)

In addition to its unique number, a regular proof step consists of a
claim expression, followed by a :ref:`justification <prop-rules>` --
a valid application of one of propositional logic
:ref:`inference rules <prop-rules>` to deduce the claim.
A sub-proof in the propositional logic language starts with an assumption
(``assume`` justification) that is a regular proof step,
followed by zero or more proof steps (they are delimited inside
``{`` ... ``}`` similar to a proof); the steps, including the assumption,
should be separated by newline(s).

Here is an example proof of the above sequent: ``p → r,  q → r  ⊢  (p ∨ q) → r``.

.. literalinclude:: propositional-1a.logika
   :language: none
   :lines: 2-

Steps ``1``, ``2``, ``7``, ``10``, ``11``, and ``12`` are regular proof steps;
steps ``4``, ``6``, and ``9`` are assumptions; and ``3``, ``5``, and ``8`` are
sub-proofs, where ``5`` and ``8`` are nested inside ``3``.

.. _scoping:

Scoping Rules
-------------

When applying an :ref:`inference rule <prop-rules>` to justify a proof step,
one can refer to proof step numbers preceeding it
in the same level of ``{`` ... ``}`` (e.g., ``11`` refers to ``4``, ``5``, and ``8``)
or at the preeceding step numbers in its outer ``{`` ... ``}`` layers
(e.g., ``7`` refers ``1``).
As a non-example, Step ``10`` cannot refer to step ``7`` to deduce its claim.

Hence, the scoping rules are similar to variable scoping rules in various programming
languages such as Scala or Java (with the exception that, again, each proof step number
is unique throughout the whole proof, in order to avoid confusion).


Expression
==========

.. literalinclude:: propositional.txt
   :language: antlr
   :lines: 25-32

The claim boolean expression language in propositional logic is rather small; it
consists of boolean literals, variable reference (identifier),
parenthesized expression, one unary expression (negation),
and and/or/imply binary expressions.
Note that variables do not need to be explicitly declared in the propositional
input language.

Also, a parenthesized expression is structurally or semantically
indistinguishable from the expression it contains;
it is only used as a means to override operator precedences.
In other words, for any Logika expression ``e``, ``e ≡ (e)``.
This equivalence holds even for programming logic expressions.


.. _prop-rules:

Justification and Inference Rules
=================================

.. literalinclude:: propositional.txt
   :language: antlr
   :lines: 34-

Each regular proof step should justify the deduction that it makes
to derive its claim by applying some inference rules.
This section summarizes Logika's rendition of propositional logic
natural deduction rules that are intuitively described in
:ref:`propositional-logic`.

The discussion for each inference rules assumes that it is being
applied in a regular proof step numbered ``Z``
and whose claim expression is ``R``.
When ``Z`` applies an inference rule and refer to some other
proof step numbers, they should be in ``Z``'s :ref:`scope <scoping>`.

Suppose that ``Z`` uses an inference rule ``I`` that accepts two
claim arguments that can be retrieved from proof steps ``Y`` and ``Z``.
Here is a schematic pattern notation that we use throughout this section::

    …
    Y. …
    …
    Z. …
    …
    X. R    I Y Z
    …


In this notation, ``Y`` or ``Z`` could be the same and/or in the outer
:ref:`scope <scoping>` layers of ``X``.

Premise
-------

.. literalinclude:: propositional.txt
   :language: antlr
   :lines: 34

The ``premise`` justification can be used to call on one of the
sequent's premises associated with the proof.
That is, ``R`` has to be one of the sequent's premises.
For example,

.. literalinclude:: premise-1.logika
   :language: none

In this case, ``R`` is ``q`` and
proof step ``1`` uses ``premise`` to deduce its claim ``q``,
which is exactly the second sequent's premise.

The ``premise`` justification can also be used to conjure ``⊤`` (true).
For example, here is the shortest sequent and proof in Logika.

.. literalinclude:: premise-2.logika
   :language: none

In this example, there is no premise in the sequent needed to
justify for ``⊤``; one can always depend on ``⊤`` to be true
to its true self.

And-Introduction (∧i)
---------------------

.. literalinclude:: propositional.txt
   :language: antlr
   :lines: 48, 35

The ∧i rule requires two arguments, which are regular proof step
numbers.
Here is a valid schematic inference pattern for ∧i where ``R ≡ P ∧ Q``::

    …
    Y. P        … // justification for P
    …
    Z. Q        … // justification for Q
    …
    X. P ∧ Q    ∧i Y Z
    …

For example,

.. literalinclude:: and-intro-1.logika
   :language: none

In this case, ``Y ≡ Z ≡ 1``, ``P ≡ Q ≡ ⊤``, and ``R ≡ ⊤ ∧ ⊤``.

And-Elimination (∧e1, ∧e2)
--------------------------

Or-Introduction (∨i1, ∨i2)
--------------------------

Or-Elimination (∨e)
-------------------

Implication-Introduction (→i)
-----------------------------

Implication-Elimination (→e)
----------------------------

Negation-Introduction (¬i)
--------------------------

Negation-Elimination (¬e)
-------------------------

Bottom-Elimination  (⊥e)
------------------------

Proof-by-contradiction (Pbc)
----------------------------

Propositional Logic Input Language Grammar
==========================================

.. literalinclude:: propositional.txt
   :language: antlr
   :lines: 1 - 46
