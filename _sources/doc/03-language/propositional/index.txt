.. raw:: html

   <br/>
   <font color="darkgray">
   <big><big><b>
   Sireum Logika Documentation &mdash; <a href="../index.html">3. The Logika Formal Input Language</a>
   </b></big></big>
   </font>
   <br/>
   <font color="black">
   <big><big><big><big><b>
   3.2. Propositional Logic
   </b></big></big></big></big>
   </font>

.. _propositional-language:

Propositional Logic
*******************

**Propositional Logic Input Language Grammar**

.. literalinclude:: propositional.txt
   :language: antlr
   :lines: 1

The propositional logic input language consists of two main parts:
(1) a sequent, which is followed by (2) a proof of the
sequent.

An example input has been shown in the :ref:`logika-examples` section.

Sequent
=======

.. literalinclude:: propositional.txt
   :language: antlr
   :lines: 3-11

A sequent consists of premises (optional) and
conclusions that are separated either by a turnstile
``⊢`` or a ``HLINE``.
In the former, each premises and conclusions is
separated by a comma ``,``; the latter separates them using
whitespaces (newlines are considered as whitespaces inside
sequents).

Here is an example of sequent written using the turnstile notation.

.. literalinclude:: propositional-1a.logika
   :language: none
   :lines: 1

An equivalent sequent to that written using the horizontal line
notation is as follows.

.. literalinclude:: propositional-1b.logika
   :language: none
   :lines: 1-3

Either way to express a sequent is fine; it is just a matter of style.

Proof
=====

.. literalinclude:: propositional.txt
   :language: antlr
   :lines: 13-28

A proof consists of a sequence of proof steps delimited by curly braces
``{`` ... ``}``; the proof steps should be separated by newline(s).

Each proof step in the whole proof should be *uniquely*
``NUM``\ bered (but can be out of order), and it is either:
(a) a regular proof step (atomic), or (b) a sub-proof (composite).
(Regular step number ``rNUM`` and sub-proof number ``sNUM`` are
``NUM`` :ref:`literals <ops-literals>`, but distinguished here to
increase readability of the :ref:`justification grammar that applies inference rules <prop-rules>`
later.)

In addition to its unique number, a regular proof step consists of a
claim expression, followed by a :ref:`justification <prop-rules>` --
a valid application of one of propositional logic
:ref:`inference rules <prop-rules>` to deduce the claim.
A sub-proof in the propositional logic language starts with an assumption
(``assume`` justification) that is a regular proof step,
followed by zero or more proof steps (they are delimited inside
``{`` ... ``}`` similar to a proof); the steps, including the assumption,
should be separated by newline(s).

Here is an example proof of the above sequent: ``p → r,  q → r  ⊢  (p ∨ q) → r``.

.. literalinclude:: propositional-1a.logika
   :language: none
   :lines: 2-

Steps ``1``, ``2``, ``7``, ``10``, ``11``, and ``12`` are regular proof steps;
steps ``4``, ``6``, and ``9`` are assumptions; and ``3``, ``5``, and ``8`` are
sub-proofs, where ``5`` and ``8`` are nested inside ``3``.

.. _scoping:

Proof Scoping Rules
===================

When applying an :ref:`inference rule <prop-rules>` to justify a proof step,
one can refer to proof step numbers preceeding it
in the same level of ``{`` ... ``}`` (e.g., ``11`` refers to ``4``, ``5``, and ``8``)
or at the preeceding step numbers in its outer ``{`` ... ``}`` layers
(e.g., ``7`` refers ``1``).
As a non-example, Step ``10`` cannot refer to step ``7`` to deduce its claim.

Hence, the scoping rules are similar to variable scoping rules in various programming
languages such as Scala or Java (with the exception that, again, each proof step number
is unique throughout the whole proof, in order to avoid confusion).

.. _schematic-pattern:

Proof Schematic Pattern
=======================

The discussion on :ref:`justification and inference rules <prop-rules>`
uses the following schematic pattern rule and notation.

At any regular proof step numbered ``Z`` whose claim expression is ``R``,
when ``Z`` applies an inference rule and refer to some other
proof step numbers, they should be in ``Z``'s :ref:`scope <scoping>`.

Now, suppose that ``Z`` uses an inference rule ``I`` that accepts two
claim arguments that can be retrieved from proof steps ``Y`` and ``Z``.
Here is a schematic pattern notation that we use throughout this section::

    …
    Y. …
    …
    Z. …
    …
    X. R    I Y Z
    …


In this notation, ``Y`` or ``Z`` could be the same proof step,
out of order, and/or in the outer :ref:`scope <scoping>` layers of ``X``.


Claim Expression
================

.. literalinclude:: propositional.txt
   :language: antlr
   :lines: 30-37

The claim boolean expression language in propositional logic is rather small; it
consists of boolean literals, variable reference (identifier),
parenthesized expression, one unary expression (negation),
and and/or/imply binary expressions.
Note that variables do not need to be explicitly declared in the propositional
input language.

Also, a parenthesized expression is structurally or semantically
indistinguishable from the expression it contains;
it is only used as a means to override operator precedences.
In other words, for any Logika expression ``e``, ``e ≡ (e)``.
This equivalence holds even for programming logic expressions.


.. _prop-rules:

Justification and Inference Rules
=================================

.. literalinclude:: propositional.txt
   :language: antlr
   :lines: 39-51

Each regular proof step should justify the deduction that it makes
to derive its claim by applying some inference rules.
This section summarizes Logika's rendition of propositional logic
natural deduction rules that are intuitively described in
:ref:`propositional-logic`.

The subsequent discussion for each inference rules assumes that
it is being applied at a regular proof step numbered ``Z``
and whose claim expression is ``R``.


Premise
-------

.. literalinclude:: propositional.txt
   :language: antlr
   :lines: 39

The ``premise`` justification can be used to call on one of the
sequent's premises associated with the proof.
That is, ``R`` has to be one of the sequent's premises.
For example,

.. literalinclude:: premise-1.logika
   :language: none

In this case, ``R`` is ``q`` (``R ≡ q``) and
proof step ``1`` (``Z ≡ 1``) uses ``premise`` to deduce its
claim ``q``, which is exactly the second sequent's premise.

The ``premise`` justification can also be used to conjure ``⊤`` (true).
For example, here is the shortest sequent proof in Logika.

.. literalinclude:: premise-2.logika
   :language: none

In this example, ``Z ≡ 1`` and ``R ≡ ⊤``.
There is no premise in the sequent needed to
justify for ``⊤``; one can always depend on ``⊤`` to be true
to its true self.

And-Introduction (∧i)
---------------------

.. literalinclude:: propositional.txt
   :language: antlr
   :lines: 53, 40

The ∧i rule requires two arguments, which are regular proof step
numbers ``rNUM``\ s.

Here is a schematic pattern for valid inference using ∧i:

.. literalinclude:: and-intro-pattern.txt
   :language: none
   :caption: **∧i Schematic Pattern**
   :name: and-intro-pattern

For example,

.. literalinclude:: and-intro-1.logika
   :language: none

In this case, the pattern is instantiated with
``X ≡ Y ≡ 1``, ``P ≡ Q ≡ ⊤``, ``Z ≡ 2``, and ``R ≡ ⊤ ∧ ⊤``.

Another example,

.. literalinclude:: and-intro-2.logika
   :language: none

In this example, ``X ≡ 1``, ``P ≡ q``, ``Y ≡ 2``, ``Q ≡ p``,
``Z ≡ 3``, and ``R ≡ p ∧ q``.

The rest of this section assumes that one already "groks"
the schematic pattern by now, hence, without examples and
only discuss Logika nuances that enhance the natural
deduction rules in :ref:`propositional-logic`.

And-Eliminations (∧e1, ∧e2)
---------------------------

.. literalinclude:: and-elim1-pattern.txt
   :language: none
   :caption: **∧e1 Schematic Pattern**
   :name: and-elim1-pattern

.. literalinclude:: and-elim2-pattern.txt
   :language: none
   :caption: **∧e2 Schematic Pattern**
   :name: and-elim2-pattern


Or-Introductions (∨i1, ∨i2)
---------------------------

.. literalinclude:: or-intro1-pattern.txt
   :language: none
   :caption: **∨i1 Schematic Pattern**
   :name: or-intro1-pattern

.. literalinclude:: or-intro2-pattern.txt
   :language: none
   :caption: **∨i2 Schematic Pattern**
   :name: or-intro2-pattern


Or-Elimination (∨e)
-------------------

.. literalinclude:: or-elim-pattern.txt
   :language: none
   :caption: **∨e Schematic Pattern**
   :name: or-elim-pattern

Implication-Introduction (→i)
-----------------------------

Implication-Elimination (→e)
----------------------------

Negation-Introduction (¬i)
--------------------------

Negation-Elimination (¬e)
-------------------------

⊥-Elimination  (⊥e)
-------------------

Proof-by-contradiction (Pbc)
----------------------------

Propositional Logic Input Language Grammar
==========================================

.. literalinclude:: propositional.txt
   :language: antlr
   :lines: 1 - 46
