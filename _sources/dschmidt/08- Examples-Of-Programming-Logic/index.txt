.. raw:: html

   <br/>
   <font color="black">
   <big><big><big><big><b>
   8. Examples of Programming Logics
   </b></big></big></big></big>
   </font>

.. include:: ../def.rst

.. _course-notes:

Putting it all Together
***********************




.. The ``^``-rules in Programming Logic
.. ====================================
..
.. From time to time, the ``^i`` and ``^e`` rules have appeared in the programming
.. examples in the previous chapters.
.. We can now make the connection -- using the facts (premises) generated by the
.. program's commands, we use algebra and the deduction rules to deduce key
.. information in our program analysis.
.. Here is a precise treatment of a simple deduction we did in an earlier chapter:
..
.. .. code-block:: python
..
..   """{ x > y  ^  y == 3 }"""
..   x = x - 1
..   """
..   { 1. x = x_old - 1           premise (from the forwards-assignment law)
..     2. x_old > y ^ y = 3       premise (the fact that held before the assignment)
..     3. x_old > y               ^e1 2
..     4. x > y - 1               algebra 1 3
..     5. y == 3                  ^e2 2
..     6.  x > y - 1  ^  y = 3    ^i 4,5
..     (the last line of the proof must not mention any occurrence of  x_old) }
..   """

.. It is common to draw boxes around the subproofs, like this, rather than indent
.. with ellipses::
..
..   1. P v Q                premise
..   2. S                    premise
..   +--------------------------------------
..   | 3. P                  assumption
..   | 4. P ^ S              ^i 3,2
..   | 5. (P ^ S) v (Q ^ S)  vi1 4
..   +--------------------------------------
..   +--------------------------------------
..   | 6. Q                  assumption
..   | 7. Q ^ S              ^i 6,2
..   | 8. (P ^ S) v (Q ^ S)  vi2 7
..   +-------------------------------------
..   9.  (P ^ S) v (Q ^ S)   vE 1, 3-5, 6-8
..
.. Do as you please.

.. Examples from Programming Logic
.. ===============================
..
.. This function can accept two varieties of argument:
..
.. .. code-block:: python
..
..    def reciprocal(n) :
..        """
..        { pre    (n < 0) v (n > 0)
..          post   answer == 1.0 /n
..          return answer }
..        """
..        answer = 1.0 / n
..        return answer
..
..    # We show that the function's argument satisfies the precondition:
..    x = 5
..    """
..    { 1. x == 5                  premise
..      2. x > 0                   algebra 1
..      3. (x > 0) v (x < 0)       vi1 2 }
..    """
..    y = reciprocal(x)
..    """
..    { 1. y == 1.0/x              premise (by function-call law)
..      2. x == 5                  premise (from above)
..      3. x == 5  ^  y == 1.0/x   ^i 2,3
..    }
..    """
..
.. Here is a little programming trick:
..
.. .. code-block:: python
..
..    if x < 0 :
..        y = 0 - 1
..    else :
..        y = 1
..    x = x * y
..
.. At the end ``x`` is always nonnegative, because the if-command sets ``y`` to the
.. opposite parity (sign) as ``x``.
.. We can use ``ve`` to prove this:
..
.. .. code-block:: python
..
..    if x < 0 :
..        y = 0 - 1
..    else :
..        y = 1
..    """{ 1. (x < 0 ^ y == -1)  v  (x >=0 ^ y == 1)         premise (if-law) }"""
..    x = x * y
..    """
..    { 1. x == x_old * y                                    premise
..      2. (x_old < 0 ^ y == -1)  v  (x_old >= 0 ^ y == 1)   premise
..
..      ... 3. x_old < 0 ^ y == -1                           assumption
..      ... 4. x_old < 0                                     ^e1 3
..      ... 5. y == -1                                       ^e2 3
..      ... 6. x_old * y > 0                                 algebra 4 5
..      ... 7. x > 0                                         subst 1 6
..      ... 8. x >= 0                                        algebra 7
..
..      ... 9. x_old >=0 ^ y == 1                            assumption
..      ... 10. x_old >= 0                                   ^e1 9
..      ... 11. y == 1                                       ^e2 10
..      ... 12. xold * y >= 0                                algebra 10  11
..      ... 13. x >= 0                                       subst 1 12
..
..      14. x >= 0                                           ve 2,3-8,9-13 }
..    """
..
.. The proof matches exactly the informal reasoning why ``x = x * y`` makes ``x``
.. nonnegative at the end.

Examples from Programming Logic
===============================
Consider the loop for finding a value in a list of integers:

.. literalinclude:: \logika\09-example-10.logika
   :liinenos:

After the loop finishes, we use ``-->e`` with the invariant to ensure that we
print the correct answer:

.. Examples from Programming Logic
.. ===============================
..
.. Here is how we use the ``_|_e``-rule with an if-command to dismiss an impossible
.. case in an efficient way:
..
.. .. code-block:: python
..
..    x = 3
..    if x > 0
..        y = 1
..    else :
..        y = 2
..    """{ goal: y = 1 }"""
..
.. Clearly, the then-arm is executed to get the result -- the else-arm will never
.. execute.
.. But the law for conditionals says we must analyze *both* arms to conclude a
.. logical result in advance of execution.
.. Our analysis quickly concludes that the else-arm is impossible, and the
.. ``_|_e``-law finishes the job.
.. Say that the goal of the code that follows is to force ``y == 1``:
..
.. .. code-block:: python
..
..    x = 3
..    """{ 1. x == 3                 premise }"""
..    if x > 0
..        """
..        { 1. x > 0                 premise
..          2. x == 3                premise }
..        """
..        y = 1
..        """{ 1. y == 1             premise }"""
..    else :
..        """
..        { 1. ~(x > 0)              premise
..          2. x == 3                premise
..          3. (~(x > 0) ^ x == 3)   ^i 1,2 }
..        """
..        y = 2
..        """
..        { 1. y = 2                 premise
..          2. ~(x > 0) ^ x == 3     premise
..          3. ~(x > 0)              ^e1 2
..          4. x == 3                ^e2 2
..          5. x > 0                 algebra 4
..          6. _|_                   ~e 5,3
..          7. y == 1                _|_e 6   (!) }
..        """
..
..    """
..    { 1. (y == 1) v (y == 1)       premise
..      ... 2.  y == 1               assumption
..
..      ... 3.  y == 1               assumption
..      4. y == 1                    ve 1, 2-2, 3-3 }
..    """
..
.. Because it is impossible to have both ``~(x > 0)`` and ``x == 3`` at the same
.. time (line 6), we have reached an impossible situation, and we can conclude
.. whatever we want to finish this impossible case.
..
.. A useful way of thinking about a contradiction is a kind of "program crash".
.. A logic proof is like a computer program, and when one uses the premises
.. (the "inputs") of a proof to compute a contradiction, this is like a program
.. crash (a thrown exception).
.. The ``~e`` rule announces the crash/exception, and the ``_|_e`` rule acts like
.. an exception handler, cleaning up the mess and outputting some recovery answer.
.. Application of The Universal Quantifier to Programming Functions
.. ================================================================
..
.. We have been using the rules for the universal quantifier every time we call a
.. function.
.. A function's parameter names are like the variables ``x`` and ``y`` in
.. ``∀x`` and ``∀y``.
.. Here is an example:
..
.. .. code-block:: python
..
..    def fac(n) :
..        """
..        { pre    n >= 0
..          post   ans == n!
..          return ans }
..        """
..
.. We saw in the previous chapter that the pre- and post-condition can be combined
.. into this compound proposition::
..
..   (n >= 0)  -→  (fac(n) == n!)
..
.. which describes ``fac``'s behavior in terms of name ``n``.
..
.. But ``n`` is a parameter name that is *internal* to ``fac``'s code.
.. A more proper specification, one that makes sense to ``fac``'s caller, is::
..
..   ∀n ((n >= 0)  -→  (fac(n) == n!))
..
.. That is, "for all possible int arguments, if the argument is nonnegative, then
.. ``fac`` computes the argument's factorial".
..
.. We use this logical propery when we call the function.
.. Here is the proof of it:
..
.. .. code-block:: python
..
..    x = fac(6)
..    """
..    { 1. ∀n((n >= 0)  -→  (fac(n) == n!))    premise (about  fac )
..      2. 6 >= 0                                   algebra
..      3. (6 >= 0) -→  (fac(6) == 6!)              ∀e 1
..      4. fac(6) == 6!                             -→ e 3,2
..      5. x == fac(6)                              premise (the assign law)
..      6. x == 6!                                  subst 4,5 }
..    """
..
.. ``∀e`` *applies the function's logical property to its argument*.
.. The function-call law we learned in the Chapter on :ref:`functions-procedures`
.. hid the ``∀`` -- we weren't ready for it yet!
.. But the universal quantifier is implicit in the description of every function we
.. call.
..
.. When we wrote the coding of ``fac``, we also built a proof that fac computes and
.. returns ``n!``, for input parameter name, ``n``.
.. We didn't know if ``n`` will equal ``1`` or ``9`` or ``99999`` -- we just call
.. it ``n`` and work with the name.
.. This is just a "Mr. anybody", exactly as we have been using in our case analyses
.. that finish with ``∀i``.
.. *The rule for function building hides the use of* ``∀i`` -- we were not
.. ready for it in the :ref:`functions-procedures` chapter.
.. But writing a function is the same thing as writing a proof that finishes with
.. ``∀i``.
..
..
..
.. Application of The Universal Quantifier to Data Structures
.. ==========================================================
..
.. A data structure is a container for holding elements from a domain, and we often
.. use universal quantifiers to write assertions about the data structure and how
.. to compute upon it.
.. We use the ``∀i`` and ``∀e`` rules to reason about the elements that
.. are inserted and removed from the data structure.
..
.. We use arrays (lists) in the examples in this chapter.
.. First, recall these Python operators for arrays:
..
.. * For array ``r``, ``r.append(e)`` adds element ``e`` to the end of ``r``:
..
..   .. code-block:: python
..
..      a = [2, 3, 5, 7]
..      print a      # prints  [2, 3, 5, 7]
..      a.append(11)
..      print a      # prints  [2, 3, 5, 7, 11]
..
.. * For array ``r``, ``r[:index]`` computes a new array that is the "slice" of
..   ``r`` up to and not including ``r[index]``:
..
..   .. code-block:: python
..
..      c = [2, 3, 5, 7, 11, 13, 17, 19]
..      e = c[:6]
..      print e      # prints  [2, 3, 5, 7, 11, 13]
..      f = c[:0]
..      print f      # prints []
..      print c      # prints [2, 3, 5, 7, 11, 13, 17, 19]
..
.. * For array, ``r``, ``r[index;]`` computes a new array that is the "slice" of
..   ``r`` from ``r[index]`` to the end of ``r``:
..
..   .. code-block:: python
..
..      c = [2, 3, 5, 7, 11, 13, 17, 19]
..      g = c[4:]
..      print g      # prints  [11, 13, 17, 19]
..      h = c[:8]
..      print h      # prints []
..      print c      # prints [2, 3, 5, 7, 11, 13, 17, 19]
..
.. Here is an example; it is math-induction-like ("Approach 2" mentioned earlier).
.. We outline below how a procedure resets all the elements of an array (list) to
.. zeros:
..
.. .. code-block:: python
..
..    def zeroOut(a) :
..        """
..        { pre  isIntArray(a)
..          post ∀ 0 <= i < len(a),  a[i] == 0 }
..        """
..        j = 0
..        while j != len(a) :
..            """{ invariant  ∀ 0 <= i < j,  a[i] == 0 }"""
..            a[j] = 0
..            """
..            { assert      ∀ 0 <= i < j,  a[i] == 0   ∧  a[j] = 0
..              therefore,  ∀ 0 <= i < j+1,  a[i] == 0    (*) }
..            """
..            j = j + 1
..            """{ assert  ∀ 0 <= i < j,  a[i] == 0 }"""
..        #END LOOP
..       """
..       { assert      j == len(a)  ∧  (∀ 0 <= i < len(a),  a[i] == 0)
..         therefore,  ∀ 0 <= i < len(a),  a[i] == 0  }
..       """
..
.. We state that the range of elements from ``0`` up to (and not including) ``j``
.. are reset to ``0`` by stating::
..
..   ∀ 0 <= i < j,  a[i] == 0
..
.. This loop invariant leads to the goal as ``j`` counts through the range of ``0``
.. up to the length of array ``a``.
.. At the point marked (*), there is an informal use of ``∀i``.
.. Here is a second, similar example:
..
.. .. code-block:: python
..
..    def doubleArray(a) :
..        """doubleArray builds a new array that holds array  a's  values *2"""
..        """
..        {  pre:  isIntArray(a)
..           post: isIntArray(answer)  ∧  len(answer) == len(a)
..                 ∧ ∀ 0 <= i < len(a), answer[i] == 2 * a[i] }
..        """
..        index = 0
..        answer = []
..        while index != len(a) :
..            """
..            {  invariant  isIntArray(answer)  ∧  len(answer) == index  ∧
..                          ∀ 0 <= i < index, answer[i] == 2 * a[i] }
..            """
..            """{  assert:  index != len(a)  ∧  invariant }"""
..            answer.append([a[index]*2)
..            """
..            {  assert:   invariant ∧  answer[index] == 2 * a[index]
..               implies:  ∀ 0 <= i < index+1, answer[i] == 2 * a[i]  }
..            """   # (see Approach 2)
..            index = index + 1
..            """{  assert: invariant }"""
..
..        """
..        {  assert:   index == len(a) ∧ invariant
..           implies:  isIntArray(answer)  ∧  len(answer) == len(a)
..           implies:  ∀ 0 <= i < len(a),  answer[i] == 2 * a[i]  }
..        """
..        return answer
..
.. Notice how the postcondition notes that the answer array is the same length as
.. the parameter array.
.. This prevents the function's code from misbehaving and adding junk to the end of
.. the answer array.
..
.. See the Case Studies for more examples.

.. Applications of The Existential Quantifier
.. ==========================================
..
.. Since an existential quantifier hides knowledge, it is useful to describe a
.. function that returns some but not all the information that the function
.. computes.
.. Here is a simple example, for a computerized Wheel-of-Fortune game:
..
.. .. code-block:: python
..
..    board = ...   """{ invariant: isStringArray(board) ∧  len(board) > 0  }"""
..
..    def gameOver() :
..        """examines  board  to see if all squares uncovered.  Returns  True  if so,
..           otherwise returns False."""
..        """{  gameOver_pre   true }"""
..        """
..        {  gameOver_post  answer -→  ¬ (∃ 0 <= i < len(board), board[i] == "covered")
..           ∧  ¬ answer -→  (∃ 0 <= i < len(board), board[i] == "covered") }
..        """
..        answer = True
..
..        ... while loop that searches board for a  board[k] == "covered";
..              if it finds one, it resets  answer = False ...
..
..        return answer
..
.. The computerized Pat Sajak would use this function like this:
..
.. .. code-block:: python
..
..    done = gameOver()
..    if done :
..        print "We have a winner!  Time for a commercial!"
..    else :
..        print "There is still a letter that is covered. Let's continue!"
..
.. Here is the relevant deduction:
..
.. .. code-block:: python
..
..    done = gameOver()
..    """{  assert:  [done/answer]gameOver_post  }"""
..    if done :
..        """
..        {  1. done                                                          premise
..           2. [done/answer]gameOver_post                                    premise
..           3. done -→  ¬ (∃ 0 < i < len(board), board[i] == "covered")   ∧e 2
..           4. ¬ (∃ 0 < i < len(board), board[i] == "covered")            -→ e 3,1 }
..        """
..        print "We have a winner!  Time for a commercial!"
..    else :
..        """
..        {  1. ¬ done                                                         premise
..           2. [done/answer]gameOver_post                                    premise
..           3. ¬ done -→  (∃ 0 < i < len(board), board[i] == "covered")   ∧e 2
..           4. ∃ 0 < i < len(board), board[i] == "covered"               -→ e 3,1 }
..        """
..        print "There is still a letter that is covered. Let's continue!"
..
.. Notice that the answer returned by ``gameOver`` hides which square on the
.. ``board`` is still covered (``== "covered"``).
..
.. We repeat an example from a previous chapter to show another use of the
.. existential:
..
.. .. code-block:: python
..
..    def delete(c, s) :
..        """delete locates an occurrence of  c  in  s  and
..           removes it and returns the resulting string.
..           If  c  is not in  s, a copy of  s  is returned, unchanged.
..        """
..        """
..        {  pre:  isChar(c) ∧ isString(s)
..           post: (∃ 0 <= k < len(s), s[k] == c ∧ answer == s[:k] + s[k+1:])
..                 v
..                 (∀ 0 <= i < len(s), s[i] != c) ∧ answer == s }
..        """
..        index = 0
..        found = False
..        while index != len(s)  and  not found :
..            """
..            {  invariant (∀ 0 <= i < index, s[i] != c)  ∧
..                         (found -→   s[index] == c)   }
..            """
..            if  s[index] == c :
..                found = True
..            else :
..                index = index + 1
..        """{  assert: (index == len(s) v found)  ∧  above invariant  }"""
..        if found :
..            answer = s[:index] + s[index+1:]
..            """
..            {  1. found                                              premise
..               2. answer == s[:index] + s[index+1:]                  premise
..               3. invariant                                          premise
..               4. (found -→   s[index] == c)                         ∧e 3
..               5. s[index] == c                                      -→ e 4,1
..               6. s[index] == c ∧ answer == s[:index] + s[index+1:]  ∧i 5,2
..               7. 0 <= index < len(s)                                algebra 5
..               8. ∃ 0 <= k < len(s), s[k] == c ∧ answer == s[:k] + s[k+1:]  ∃i 7,6  (where [k/index]) }
..            """
..        else :
..            answer = s
..            """
..            {  1. ¬ found                                             premise
..               2. answer == s                                        premise
..               3. (index == len(s) v found)                          premise
..               4. invariant                                          premise
..               5. index == len(s)                                    by  P v Q, ¬ Q |- P, 3,1
..               6. ∀ 0 <= i < index, s[i] != c                   ∧e 4
..               7. ∀ 0 <= i < len(s), s[i] != c                  substitution 5,6
..               8. (∀ 0 <= i < len(s), s[i] != c) ∧ answer == s  ∧i 7,2 }
..            """
..        return answer
..
.. The ``∃i`` rule is used inside the then-arm of the last conditional, as
.. shown above.
..
.. It is important that ``delete`` hide the value of its local variable, ``index``,
.. from appearing in its postcondition, because we do not want confusion like this:
..
.. .. code-block:: python
..
..    index = 2
..    t = "abcd"
..    u = delete("a", t)
..    """{ at this point, we certainly cannot assert that t[2] = "a"! }"""
..
..
.. The Forwards Assignment Law Uses an Existential Quantifier
.. ==========================================================
..
.. The original, proper statement of the forwards assignment law reads like this:
..
.. .. code-block:: python
..
..    """{ assert: P }"""
..    x = e
..    """{ assert: ∃x_old ( (x == [x_old/x]e)  ∧  [x_old/x]P )  }"""
..
.. Our use of ``x_old`` was hiding the quantifier.
.. Using ``∃``, we can retain an assertion that uses the old value of ``x``.
.. In the earlier chapters, we worked examples like this:
..
.. .. code-block:: python
..
..    """{ x > 0 }"""
..    x = x + 1
..    """
..    { 1. x_old > 0        premise
..      2. x == x_old + 1   premise
..      3. x > 1            algebra 1,2 }
..    """
..
.. and noted that ``x_old`` must not appear in the last line of the proof.
..
.. The above proof is actually the subproof of a proof that finishes with
.. ``∃e``!
.. Here is the proper proof:
..
.. .. code-block:: python
..
..    """{ x > 0 }"""
..    x = x + 1
..    """
..    { 1. ∃x_old(x_old > 0  ∧  x == x_old + 1)     premise
..      ... 2. x_old     x_old > 0  ∧  x == x_old + 1   assumption
..      ... 3.          x_old > 0                       ∧e1 2
..      ... 4.          x == x_old + 1                  ∧e2 2
..      ... 5.          x > 1                           algebra 3,4
..      6. x > 1                                        ∃e 1, 2-5
..    }
..    """
..
.. Again, it is crucial that ``x_old`` not appear in the assertions on Lines 5 and 6.
..
.. We unconsciously use the existential quantifier and ``∃e`` every time we
.. reason about the old, overwritten value of an updated variable.
..
.. Also, when we introduce dummy names, like ``x_in`` and ``y_in``, to stand for
.. specific values, as an example like this,
..
.. .. code-block:: python
..
..    """{ assert: x == x_in  ∧  y == y_in }"""
..    temp = x
..    x = y
..    y = temp
..    """{ assert: x == y_in  ∧  y == x_in }"""
..
.. we are implicitly using existential quantifiers, again, like this:
..
.. .. code-block:: python
..
..    """{ assert: ∃x_in ∃y_in(x == x_in  ∧  y == y_in) }"""
..    temp = x
..    x = y
..    y = temp
..    """{ assert: ∃x_in∃y_in(x == y_in  ∧  y == x_in) }"""
..
.. The Law for Assigning to Individual Array Elements
.. **************************************************
..
.. A key property of the forwards law for an assignment, ``x = e``, is that the
.. "old" value of ``x`` cannot appear in the final consequence that is deduced from
.. the assignment.
.. The same principle holds for assignment to an individual array element:
.. ``a[e] = e'`` -- the "old" value of ``a[e]`` cannot appear in the assertion that
.. results from the assignment.
..
.. For example, if we have
..
.. .. code-block:: python
..
..    """{ assert: len(a) > 0 ∧ ∀ 0 <= i < len(a), a[i] > 0 }"""
..    a[0] = 0
..
.. we should be able to deduce that
..
.. .. code-block:: python
..
..    """
..    { assert:   a[0] == 0
..                ∧  len(a) > 0
..                ∧  ∀ 0 < i < len(a), a[i] > 0
..      implies:  ∀ 0 <= i < len(a), a[i] >= 0 }
..    """
..
.. How can we do this?
.. The existing assignment law is too weak.
.. We require a special law for assignment to array elements.
.. The situation gets delicate if we are unable to deduce the precise numerical
.. value of the index expression, ``e``, in an assignment, ``a[e] = e'``.
.. Unless we can prove otherwise, the assignment has essentially updated "all" of
.. ``a``!
..
.. Here is an example of a situation where we know nothing about which cell was
.. updated:
..
.. .. code-block:: python
..
..    n = readInt("Type an int between 0 and len(a)-1: ")
..    assert 0 <= n  and  n < len(a)
..    a[n] = a[n] - 1
..
.. Clearly only one element of a is decremented. Let's try to reason about this
.. situation:
..
.. .. code-block:: python
..
..    """{ assert: ∀ 0 <= i < len(a), a[i] > 0 }"""
..
..    n = readInt("Type an int between 0 and len(a)-1: ")
..    assert 0 <= n  and  n < len(a)
..    """{ assert: 0 <= n ∧ n < len(a)  ∧  ∀ 0 <= i < len(a), a[i] > 0 }"""
..
..    a[n] = a[n] - 1
..    """
..    {  assert:  a[n] == a_old[n] - 1  ∧  0 <= n  ∧  n < len(a)
..                ∧  ∀ 0 <= i < len(a), a_old[i] > 0
..       implies: ??? }
..    """
..
.. To move forwards, we must assert that all those variables ``a[i]``, such that
.. ``i != n``, retain their old values:
..
.. .. code-block:: python
..
..    a[n] = a[n] - 1
..    """
..    { 1. a[n] == a_old[n] - 1                                  premise
..      2. ∀ 0 <= i < len(a), (i!=n) -→  a[i] == a_old[i]   premise  NEW!
..      3. 0 <= n ∧ n < len(a)                                   premise
..      4. ∀ 0 <= i < len(a), a_old[i] > 0                  premise
..      5.  ... }
..    """
..
.. We accept the assertion (premise) on line 2 as a fact, and the forwards
.. assignment law for arrays includes this fact "for free" as part of its
.. postcondition.
..
.. Here is the law for array assignment:
..
.. .. code-block:: python
..
..    """{ assert: P }"""
..    a[e] = e'    # where  e  contains _no mention_ of  a
..    """
..    { 1. a[e] == [a_old/a]e'                                     premise
..      2. [a_old/a]P                                              premise
..      3. ∀ 0 <= i < len(a), (i != e) -→  a[i] == a_old[i]   premise
..      4. len(a) == len(a_old)                                    premise
..         ...
..      n. Q  # must not mention a_old
..    }
..    """
..
.. We gain the new premises in lines 3 and 4.
.. Line 2 is used with ``∀e`` to extract information about array elements that
.. were not affected by the assignment to ``a[e]``.
..
.. Now we have enough knowledge to make a useful deduction:
..
.. .. code-block:: python
..
..    a[n] = a[n] - 1
..    """
..    { 1. a[n] == a_old[n] - 1                                      premise
..      2. ∀ 0 <= i < len(a), (i!=n) -→  a[i] == a_old[i]       premise
..      3. 0 <= n ∧ n < len(a)                                       premise
..      4. ∀ 0 <= i < len(a), a_old[i] > 0                      premise
..      5. a_old[n] > 0                                              ∀e 4,3
..      6. a[n] >= 0                                                 algebra 1,5
..               (next, we salvage the facts about those  a[i] such that i != n: )
..      ... 8.  0 <= x < len(a)                                      assumption
..      ... 9.  a_old[x] > 0                                         ∀e 4,8
..      ... 10. (x!=n) -→  a[x] == a_old[x]                          ∀e 2,8
..      ... ... 11. x != n                                           assumption
..      ... ... 12. a[x] == a_old[x]                                 -→ e 10,11
..      ... ... 13. a[x] > 0                                         algebra 9,12
..      ... 14. (x!=n) -→  a[x] > 0                                  -→ i 11-13
..      15. ∀ 0 <= x < len(a): (x!=n) -→  a[x] > 0              ∀i 8-14
..
..      16. a[n] >= 0 ∧ ∀ 0 <= x < len(a): (x!=n) -→  a[x] > 0  ∧i 6,15  }
..    """
..
.. This tedious proof shows the difficulty in reasoning precisely about an array
.. update with an unknown index value.
..
.. It is easy to be discouraged by the length of the above proof, which says that
.. the ``n``th element of ``a`` was changed.
.. For this reason, some researchers use a picture notation to encode the
.. assertions.
.. For example, the assertion,
..
.. .. code-block:: python
..
..    ∀ 0 <= i < len(a), a[i] > 0
..
.. Might be drawn like this::
..
..         0  1  ... len(a)-1
..       +--+--+-- --+--+
..   a = |>0|>0| ... |>0|
..       +--+--+-- --+--+
..
.. so that after the assignment, a[n] = a[n]-1, we deduce this new pictorial assertion::
..
..         0  1 ...    n  ...  len(a)-1
..       +--+--+-   -+---+    -+--+
..   a = |>0|>0| ... |>=0| ... |>0|
..       +--+--+-   -+---+    -+--+
..
.. which is meant to portray
.. ``a[n] >= 0 ∧ ∀ 0 <= x < len(a), (x!=n) -→  a[x] > 0``.
..
.. These pictures can be helpful for informal reasoning, but they quickly get
.. confusing.
.. (For example, where do you draw ``n``'s cell in the above picture?
.. What if ``n == 0``? Etc.)
.. Use such drawings with caution.
..
.. To summarize, the forwards assignment law for individual array elements reads as
.. follows:
..
.. .. code-block:: python
..
..    """{ assert: P }"""
..    a[e] = e'    # where  e  contains _no mention_ of  a
..    """
..    { assert:  a[e] == [a_old/a]e'
..               ∧  ∀ 0 <= i < len(a), (i != e) -→  a[i] == a_old[i]
..               ∧  len(a) == len(a_old)
..               ∧  [a_old/a]P  }
..    """
..
..
.. Case Studies
.. ************
..
..
.. In-place Selection Sort
.. =======================
..
.. When an array holds elements that can be ordered by ``<``, it is useful to
.. rearrange the elements so that they are ordered (sorted).
.. There are several useful tecniques to sort an array's elements in place,
.. that is, move them around within the array until the array is sorted.
..
.. One useful and straightforward technique is *selection sort*, where the unsorted
.. segment of the array is repeatedly scanned for the smallest element therein,
.. which is extracted at moved to the end of the array's sorted segment.
..
.. A trace of a selection sort would look like this::
..
..     (sorted segment) | (unsorted segment)
..                      v
..                 a == ["f", "d", "c", "b", "e"]
..                      v
..             a == ["b", "d", "c", "f", "e"]   ("b" selected and moved to front
..                      v                            by exchanging it with "f")
..        a == ["b", "c", "d", "f", "e",]   ("c" selected and moved to front
..                      v                        by exchanging it with "d")
..   a == ["b", "c", "d", "f", "e"]   ("d" selected and moved to front
..                                         by exchanging it with itself)
..   (etc.)                       |
..                                v
..   a ==  ["b", "c", "d", "e", "f"]   (finished)
..
.. We require a function that searches the unsorted segment of the array and
.. locates the position of the least element therein:
..
.. .. code-block:: python
..
..    a = ["e", "d", "a", "c", "b" , "a"]   # data structure managed by this module
..
..    def select(start) :
..       """select returns the index of the smallest element in array  a's
..          segment from  a[start]...a[len(a)-1]."""
..       """
..       { pre:  0 <= start < len(a)
..         post: start <= answer < len(a)  ∧
..               ∀ start <= i < len(a), a[answer] <= a[i]  }
..       """
..       answer = start
..       index = start + 1
..       """{ invariant:  ∀ start <= i < index, a[answer] <= a[i] }"""
..       while index != len(a) :
..           if  a[index] < a[answer] :
..              answer = index
..           index = index + 1
..       return answer
..
.. The pre-postconditions tell us the knowledge the function computes.
..
.. Next, define these notions of "ordered" and "permuted" for arrays::
..
..   ordered(a) =  ∀ 0 < i < len(a), a[i-1] <= a[i]
..   perm(a, b) =  (len(a) = len(b))  ∧  (elements of  a  ==  elements of b)
..
.. The second predicate states what it means for one array, ``a``, to have the same
.. elements as another, ``b``, but maybe in a different order.
.. It is a little informal but good enough for us to use here.
..
.. The function that does a selection sort uses a loop to repeatedly call
.. ``select`` to find the elements to move to the front of the array.
..
.. Here's the function and the sketch of the proof.
.. The loop invariant is key -- the elements that have been already selected are
.. moved to the front of ``a`` are all guaranteed to be less-than-or-equal-to the
.. elements in ``a``'s rear that have not yet been selected:
..
.. .. code-block:: python
..
..    def selectionSort() :
..       """does an in-place sort on global array  a,  using  select."""
..       """
..       { pre  true
..         post ordered(a)  ∧  perm(a_in, a)   (Recall: a_in is the starting value for  a) }
..       """
..       global a
..
..       index = 0
..       """
..       { invariant   ordered(a[:index])  ∧  perm(a, a_in)  ∧
..                     ∀ 0 <= i < index, ∀ index <= j < len(a), a[i] <= a[j] }
..       """
..       while index != len(a) :
..          x = select(index)
..          """
..          { assert: start <= x < len(a)  ∧
..                    ∀ index <= i < len(a), a[x] <= a[i]
..                    ∧  invariant  }
..          """
..          least = a[x]       # exchange the least element with the one at the
..          a[x] = a[index]    #  front of the unsorted segment
..          a[index] = least
..          """
..          {  assert: ordered(a[:index])  ∧  perm(a, a_in) ∧
..                     index <= x < len(a) ∧
..                     a[index] = least  ∧
..                     ∀ index < i < len(a), least <= a[i]
..            implies: ∀ 0 <= i < index, a[i] <= least
..            implies: ordered(a[:index+1])  ∧
..                     ∀ 0 <= i < index+1, ∀ index+1 <= j < len(a): a[i] <= a[j] }
..          """
..          index = index + 1
..          """{  assert: invariant }"""
..
.. The key accomplishment of
..
.. .. code-block:: python
..
..    least = a[x]
..    a[x] = a[index]
..    a[index] = least
..
.. is to move the least element in the unsorted suffix of ``a`` to the *front* of
.. that suffix.
.. But that makes the least value eligible to be the *rear* element of the sorted
.. prefix of ``a``.
.. In this way, the loop's invariant is restored as we finish with
.. ``index = index + 1``.
..
..
.. Binary Search
.. =============
..
.. Once an array is sorted, it can be searched for a value quickly, much like you
.. search for a word in a dictionary: you open the dictionary in the middle and see
.. if you got lucky and found the word.
.. If so, you are finished.
.. If the word is earlier in the dictionary, then you ignore the back half of the
.. book and instead split open the front half.
.. (And vice versa for a word located in the back half in the dictionary.)
.. You repeat this technique till you find the page where your word is.
..
.. We can search a sorted array, ``a``, for a value, ``v``, but jumping in the
.. middle of ``a``.
.. If we find ``v`` there, we are done.
.. Otherwise, we repeat the step, jumping into the first half or the second half,
.. as needed.
.. Eventually, we find the value (if it is there).
..
.. Here is the function, which is famous for its difficulty to write correctly.
.. Glance at it, then read the paragraph underneath it, then return to the function
.. and study its assertions:
..
.. .. code-block:: python
..
..    def search(v, lower, upper) :
..       """searches for value  v  within array  a  in the range  a[lower]...a[upper].
..          If found, returns the index where  v  is; if not found, returns -1"""
..       """
..       {  search_pre   ordered(a)  ∧
..                       ∀ 0 <= i < lower, a[i] < v  ∧
..                       ∀ upper < j < len(a): v < a[j]
..                         (That is,  v  isn't in  a[:lower]  and  a[upper+1:].)
..          search_post  ((0 <= answer < len(a))  ∧  a[answer] == v)  v
..                          (answer = -1  ∧  ∀ 0 <= i < len(a), v != a[i]) }
..       """
..
..       if  upper < 0  or  lower > len(a)-1  or  lower > upper :  # empty range to search?
..          """
..          {  assert:  (upper < 0  v  lower > len(a)-1  v  lower > upper)  ∧
..                      search_pre
..             implies:  ∀ 0 <= i < len(a), v != a[i] }
..          """
..          answer = -1
..          """
..          {  assert:  answer = -1  ∧  (∀ 0 <= i < len(a), v != a[i]),
..                      that is,  search_post  }
..          """
..       else :
..          index = (lower + upper) / 2
..          if  v == a[index] :  # found v at a[index] ?
..             answer = index
..             """
..             {  assert:  a[answer] == v
..                implies: search_post }
..             """
..          elif  v > a[index] :
..             """
..             {  assert:  v > a[index]  ∧  search_pre
..                implies: ∀ 0 <= i <= index, a[i] < v
..                implies: [index+1/lower]search_pre  }
..             """
..             answer = searchFor(v, index+1, upper)
..             """{  assert:  search_post  }"""
..          else :  # a[index] < v
..             """
..             {  assert:   a[index] < v  ∧  search_pre
..                implies:  ∀ index <= j < len(a), v < a[j]
..                implies:  [index-1/upper]search_pre  }
..             """
..             answer = searchFor(v, lower, index-1)
..             """{  assert:  search_post  }"""
..       """{  assert: search_post  }"""
..       return answer
..
.. To search array, ``a``, for ``v``, we start the function like this:
..
.. .. code-block:: python
..
..    search(v, 0, len(a)-1)
..
.. The precondition is the key: to use correctly ``search(v, lower, upper)``,
.. we must already know that ``v`` is not in ``a[0]...a[lower-1]`` and not in
.. ``a[upper+1...a[len(a)-1]`` -- we have already narrowed the search to the range
.. of ``a[lower]...a[upper]``.
.. The function builds on this fact to narrow further the search in subsequent
.. self-calls until ``v`` is found or there is an empty range left to search.
..
.. The previous two examples display a style of documentation that is used when
.. correctness is critical and one is unable to perform enough testing to generate
.. high confidence that the coding is correctly -- the program must be correct from
.. the first time is it used.
.. Such an approach is taken with safety-critical systems, where money and life
.. depend on the correct functioning of software from the moment it is installed.
..
..
..
.. Maintaining a Board Game: Programming by Contract
.. =================================================
..
.. Many programs maintain a data structure like an edit buffer or a spreadsheet or
.. a game board.
.. Typically, the data structure is grouped with its maintenance functions (in its
.. own module or class).
.. This is often called the *model component*, because the data structure is a
.. computerized "model" of a real-life object.
.. Next, there is a *controller component* (module/class) that interacts with the
.. user and calls the maintenance functions in the model component.
.. (The controller sets the protocol and "controls" and "connects" the interactions
.. between user and model.)
.. If there is a graphical user interface to paint and maintain, yet another
.. component, called the *view*, must be written.
.. This trio of components forms a standard software architecture, called the
.. *Model-View-Controller (MVC)* architecture.
..
.. To build such a system, we must document the internal structure and connection
.. points of each component so that the system can be connected correctly.
.. This documentation is exactly the pre- and post-conditions for the functions in
.. each component as well as the invariants for the data structures therein.
..
.. Here is a small example.
.. It is an implementation of a tic-tac-toe game that follows the usual rules.
..
.. First, there is the model module, which models the game board as an array.
.. The game board has an important invariant that ensures that only legal game
.. tokens are placed on the board.
.. There is another data structure in this module that remembers the history of
.. moves made on the board.
.. Both data structures are documented with their invariants.
.. (If you are programming in an object-oriented language and have written a class
.. to model the game board, you call the data-structure invariants, class
.. invariants.)
..
.. .. code-block:: python
..
..    """
..    module GameBoard  models a Tic-Tac-Toe board.
..
..    There are two key data structures:
..    --- board,  the game board, which holds the players' moves
..    --- history,  a list of all the moves made during the game
..
..    The data structures are managed by calling the functions defined
..    in this module.
..    """
..
..    # The game players:
..    X = "X"
..    O = "O"
..    NOBODY = "neither player"
..
..    ###### The game board, a matrix sized  dimension x dimension:
..    EMPTY = "_"     # marks an empty square on the board
..    dimension = 3
..    BOARDSIZE = dimension * dimension
..    # the board itself:
..    board = []    # construct the board with this loop:
..    i = 0
..    while i != dimension :
..        board.append(dimension * [EMPTY])
..        i = i + 1
..    """
..    { global invariant for board:  Only legal markers are placed on it
..          ALL 0 < i,j < dimension,
..              board[i][j] == X  v  board[i][j] == O  v  board[i][j] == EMPTY }
..    """
..
..    #### A history log of all the moves:  it is a list of  Marker, Row, Col  tuples:
..    history = []
..    """
..    { global invariant for history:  All moves in  history  recorded in  board
..          forall 0 < i < len(history), history[i]==(m,r,c)  and  board[r,c] == m }
..    """
..
..    ### Functions that manage the  board  and  history:
..
..    def printBoard() :
..        """prints the board on the display"""
..        """
..        {  pre   true
..           post  forall 0 <= i,j < dimension, board[i][j] is printed  }
..        """
..        counter = 0
..        for row in board :
..            for square in row :
..                if square != EMPTY :
..                    print square,
..                else :
..                    print counter,
..                counter = counter + 1
..            print
..        print
..        #print history
..
..
..    def emptyAt(position) :
..        """
..        examines the ith square on board;  returns whether it equals EMPTY.
..
..        params: position - an int that falls between 0 and the BOARDSIZE
..        returns: whether or not square number  position on  board  is EMPTY
..        """
..        """
..        { pre   0 <= position < BOARDSIZE
..          post  answer == (board[position/dimension][position%dimension] == EMPTY) }
..        """
..        answer = False
..        (row,col) = (position/dimension, position%dimension)
..        if  0 <= row  and  row < dimension  and  0 <= col  and  col < dimension \
..           and  board[row][col] == EMPTY :
..            answer = True
..        return answer
..
..
..    def move(marker, position) :
..        """
..        attempts to move  marker  into the board at  position
..
..        params: marker - a string, should be  X  or  O
..                position -- an int, should be between 0 and the BOARDSIZE
..        """
..        """
..        {  pre   ((marker == X) v (marker == O)) &  (0 <= position < BOARDSIZE)
..           post  invariants for board and history are maintained }
..        """
..        global history, board   # because we update these global variabes,
..                                # we are OBLIGATED to maintain their invariants!
..        if emptyAt(position) :
..            (row,col) = (position/dimension, position%dimension)
..            board[row][col] = marker
..            history = history + [(marker,row,col)]
..        else :
..           pass
..
..    def winnerIs(mark) :
..        """
..        checks the game board to see if  mark  is the winner.
..
..        parameter:  mark - a string, should be  X  or  O
..        returns:    mark,  if it fills a complete row, column, or diagonal of
..                     the board;  returns  NOBODY, otherwise.
..        """
..        """
..        {  pre:  (mark == X) v (mark == O)
..           post: (answer == mark -→   mark has filled a row or column or diagonal)
..                 and  (answer == NOBODY) -→  mark has not filled any row/col/diag }
..        """
..
..        def winnerAlong(vector) :
..            """sees if all the elements in  vector  are filled by  mark"""
..            check = True
..            for index in range(dimension):
..                check = check and (vector[index] == mark)
..            return check
..
..        # check  row i  and  column i  for  i in 0,1,...,dimension-1:
..        for i in range(dimension) :
..            columni = []
..            for j in range(dimension):
..                columni = columni + [board[j][i]]
..            if winnerAlong(board[i]) or winnerAlong(columni) :
..                return mark
..
..        # check the left and right diagonals:
..        ldiag = []
..        rdiag = []
..        for i in range(dimension):
..            ldiag = ldiag + [board[i][i]]
..            rdiag = rdiag + [board[i][(dimension-1)-i]]
..        if winnerAlong(ldiag) or winnerAlong(rdiag) :
..            return mark
..        # else, no winner, so
..        return NOBODY
..
.. The data-structure invariants establish the internal well-formedness of the game
.. board, and the maintenance functions *are obligated to preserve and maintain the
.. invariants*.
.. In addition, each function is documented with its own pre-post conditions that
.. specify how the function should be called and what the function guarantees if it
.. is called correctly.
.. In the above coding, both informal English and formal logical specifications are
.. written.
.. Whether one writes English or logic depends on how critical absolute correctness
.. might be.
.. (Frankly, some programs, e.g., toys and games, need not be absolutely correct.)
..
.. The other module of this little example is the main program --- the controller
.. module --- which enforces the rules of the game, that is, the proper interaction
.. of the game's players with the game board.
.. The controller's main loop has its own invariant that asserts this point.
.. The loop
..
.. 1. displays the game board
..
.. 2. requests a player's next move
..
.. 3. implements the move on the board
..
.. Study the loop invariant first before you study anything else.
..
.. .. code-block:: python
..
..    """The Main module controls the tic-tac-toe game."""
..
..    import GameBoard
..    from GameBoard import *
..
..    def readInt(message):
..        """
..        readInt is a helper function that reads an int from the display.
..        If we had a View Module that painted a GUI, this function would
..        be found there.
..
..        param: message a string
..        returns: an int, denoting the number typed by a player
..        """
..        """
..        {  pre:  message:String
..           post: answer:int  }
..        """
..        needInput = True
..        answer = ""
..        while needInput :
..            text = raw_input(message)
..            if text.isdigit() :
..                answer = int(text)
..                needInput = False
..        return answer
..
..    player = X       # whose turn is it?  who goes first?
..    count = 0        # how many moves have been made?
..    winner = NOBODY  # who is the winner?
..
..    """
..    {  loop invariant:  The rules of the tic-tac-toe game are enforced:
..          (i) players take turns moving:
..                forall 0 <= i < count,
..                   (i % 2)== 0 -→   history[i][0] == X   and
..                   (i % 2)== 1 -→   history[i][0] = O
..          (ii) all moves are recorded on board:
..                 invariant for  history  remains true;
..          (iii) board holds only legal game markers:
..                 invariant for  board  remains true
..            (NOTE: (ii) and (iii) should hold _automatically provided
..            that we use the board's maintenance functions.) }
..    """
..    while winner == NOBODY  and  count != BOARDSIZE :
..
..        printBoard()
..
..        # get the next move:
..        awaitingMove = True
..        while awaitingMove :
..            """
..            { invariant
..                      awaitingMove -→  (0 <= m < BOARDSIZE) and emptyAt(m) }
..            """
..            m = readInt("Player " + player +  \
..                        ": type next move (0.." + str(BOARDSIZE) + "): ")
..
..            if (0 <= m) and (m < BOARDSIZE) and emptyAt(m) :
..                awaitingMove = False
..
..        # we have received a legal move:
..        """
..        { assert: ((player == X) v (player == O))
..                  and (0 <= m < BOARDSIZE) and  emptyAt(m)
..          implies:  [player/marker][m/position]move_pre  }
..        """
..        move(player, m)
..        """
..        {  assert:  movepost, that is,
..           invariants for  board  and   history  are maintained }
..        """
..
..        # determine whether this player is the winner:
..        winner = winnerIs(player)
..
..        # switch players for the next round:
..        if player == X :
..            player = O
..        else :
..            player = X
..        count = count + 1
..
..        """{ assert: loop invariant, all 3 parts, holds }"""
..
..    # the loop quit, and the game's over:
..    print winner + " won!"
..    printBoard()
..
.. Note how the controller uses the pre-post-conditions for the board's maintenance
.. functions to fulfill its own invariants.
.. In this way, we depend on the documentation from one module to program correctly
.. another.
.. Programming in this style is sometimes called *programming by contract*.
