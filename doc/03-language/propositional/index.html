
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>3.2. Propositional Logic &mdash; Sireum Logika</title>
    
    <link rel="stylesheet" href="../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/bootswatch-3.3.4/journal/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/sireum.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-3.3.4/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../../_static/logika.ico"/>
    <link rel="top" title="Sireum Logika" href="../../../index.html" />
    <link rel="up" title="3. The Logika Formal Input Language" href="../index.html" />
    <link rel="next" title="3.3. Predicate Logic" href="../predicate/index.html" />
    <link rel="prev" title="3.1. Basic Language Elements" href="../basic/index.html" />
  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          Logika</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../index.html">Documentation</a></li>
                <li><a href="../../../dschmidt/index.html">Course Notes</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html"> <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#"> <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">3.2. Propositional Logic</a><ul>
<li><a class="reference internal" href="#sequent">3.2.1. Sequent</a></li>
<li><a class="reference internal" href="#proof">3.2.2. Proof</a></li>
<li><a class="reference internal" href="#proof-scoping-rules">3.2.3. Proof Scoping Rules</a></li>
<li><a class="reference internal" href="#proof-schematic-pattern">3.2.4. Proof Schematic Pattern</a></li>
<li><a class="reference internal" href="#claim-expression">3.2.5. Claim Expression</a><ul>
<li><a class="reference internal" href="#newlines-in-expression">3.2.5.1. Newlines in Expression</a></li>
<li><a class="reference internal" href="#expression-equivalence">3.2.5.2. Expression Equivalence (<code class="docutils literal"><span class="pre">≡</span></code>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#justification-and-inference-rules">3.2.6. Justification and Inference Rules</a><ul>
<li><a class="reference internal" href="#premise">3.2.6.1. Premise</a></li>
<li><a class="reference internal" href="#and-introduction-i">3.2.6.2. And-Introduction (∧i)</a></li>
<li><a class="reference internal" href="#and-eliminations-e1-e2">3.2.6.3. And-Eliminations (∧e1, ∧e2)</a><ul>
<li><a class="reference internal" href="#and-elimination1-e1">And-Elimination1 (∧e1)</a></li>
<li><a class="reference internal" href="#and-elimination2-e2">And-Elimination2 (∧e2)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#or-introductions-i1-i2">3.2.6.4. Or-Introductions (∨i1, ∨i2)</a><ul>
<li><a class="reference internal" href="#or-introduction1-i1">Or-Introduction1 (∨i1)</a></li>
<li><a class="reference internal" href="#or-introduction1-i2">Or-Introduction1 (∨i2)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#or-elimination-e">3.2.6.5. Or-Elimination (∨e)</a></li>
<li><a class="reference internal" href="#implication-introduction-i">3.2.6.6. Implication-Introduction (→i)</a></li>
<li><a class="reference internal" href="#implication-elimination-e">3.2.6.7. Implication-Elimination (→e)</a></li>
<li><a class="reference internal" href="#negation-introduction-i">3.2.6.8. Negation-Introduction (¬i)</a></li>
<li><a class="reference internal" href="#negation-elimination-e">3.2.6.9. Negation-Elimination (¬e)</a></li>
<li><a class="reference internal" href="#elimination-e">3.2.6.10. ⊥-Elimination  (⊥e)</a></li>
<li><a class="reference internal" href="#proof-by-contradiction-pbc">3.2.6.11. Proof-by-Contradiction (pbc)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#propositional-logic-input-language-grammar">3.2.7. Propositional Logic Input Language Grammar</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <br/>
<font color="darkgray">
<big><big><b>
Sireum Logika Documentation &mdash; <a href="../index.html">3. The Logika Formal Input Language</a>
</b></big></big>
</font>
<br/>
<font color="black">
<big><big><big><big><b>
3.2. Propositional Logic
</b></big></big></big></big>
</font><div class="section" id="propositional-logic">
<span id="propositional-language"></span><h1>3.2. Propositional Logic<a class="headerlink" href="#propositional-logic" title="Permalink to this headline">¶</a></h1>
<p><strong>Propositional Logic Input Language Grammar</strong></p>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">propositional</span><span class="p">:</span><span class="w"> </span><span class="nv">sequent</span><span class="w"> </span><span class="nv">proof</span><span class="w">           </span><span class="c">// newlines are treated as whitespaces until start of proof</span><span class="w"></span>
</pre></div>
</div>
<p>The propositional logic input language consists of two main parts:
(1) a sequent, which is followed by (2) a proof of the
sequent.</p>
<p>We will show examples later, but an example input has been shown
in the <a class="reference internal" href="../../01-getting-started/index.html#logika-examples"><span>Verifying Examples</span></a> section.</p>
<div class="section" id="sequent">
<h2>3.2.1. Sequent<a class="headerlink" href="#sequent" title="Permalink to this headline">¶</a></h2>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">sequent</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="nv">claimList</span><span class="o">?</span><span class="w">               </span><span class="c">// premises</span><span class="w"></span>
<span class="w">              </span><span class="s">&#39;⊢&#39;</span><span class="w">                      </span><span class="c">// turnstile (&quot;turn-the-style&quot;), can also use &#39;|-&#39; for &#39;⊢&#39;</span><span class="w"></span>
<span class="w">              </span><span class="nv">claimList</span><span class="w">                </span><span class="c">// conclusions</span><span class="w"></span>

<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">claim</span><span class="o">*</span><span class="w">                   </span><span class="c">// premises</span><span class="w"></span>
<span class="w">              </span><span class="no">HLINE</span><span class="w">                    </span><span class="c">// HLINE is three or more dashes &#39;-&#39;</span><span class="w"></span>
<span class="w">              </span><span class="nv">claim</span><span class="o">+</span><span class="w">                   </span><span class="c">// conclusions</span><span class="w"></span>

<span class="nv">claimList</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="s">&#39;,&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="o">)*</span><span class="w"></span>
</pre></div>
</div>
<p>A sequent consists of premises (optional) and
conclusions that are separated either by a turnstile
<code class="docutils literal"><span class="pre">⊢</span></code> or a horizontal line (<code class="docutils literal"><span class="pre">HLINE</span></code>) of three or more dashes (<code class="docutils literal"><span class="pre">-</span></code>).
In the former, each premises and conclusions is
separated by a comma <code class="docutils literal"><span class="pre">,</span></code>; the latter separates them using
whitespaces (newlines are considered as whitespaces inside
sequents).</p>
<p>Here is an example sequent written using the turnstile notation.</p>
<div class="highlight-none"><div class="highlight"><pre>p → r,  q → r  ⊢  (p ∨ q) → r
</pre></div>
</div>
<p>An equivalent sequent to that written using the horizontal line
notation is as follows.</p>
<div class="highlight-none"><div class="highlight"><pre> p → r     q → r
-----------------
   (p ∨ q) → r
</pre></div>
</div>
<p>Either way to express yourself is fine.</p>
</div>
<div class="section" id="proof">
<h2>3.2.2. Proof<a class="headerlink" href="#proof" title="Permalink to this headline">¶</a></h2>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">proof</span><span class="w">       </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;{&#39;</span><span class="w"></span>
<span class="w">                </span><span class="nv">proofStep</span><span class="o">+</span><span class="w">             </span><span class="c">// separated by newline(s)</span><span class="w"></span>
<span class="w">              </span><span class="s">&#39;}&#39;</span><span class="w"></span>

<span class="nv">proofStep</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="nv">regularStep</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">subProof</span><span class="w"></span>

<span class="nv">regularStep</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">rNUM</span><span class="w"> </span><span class="s">&#39;.&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="nv">just</span><span class="w">        </span><span class="c">// rNUM is NUM, distinguished for readability of just arguments later</span><span class="w"></span>

<span class="nv">subProof</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="nv">sNUM</span><span class="w"> </span><span class="s">&#39;.&#39;</span><span class="w">                   </span><span class="c">// sNUM is NUM, distinguished for readability of just arguments later</span><span class="w"></span>
<span class="w">              </span><span class="s">&#39;{&#39;</span><span class="w"></span>
<span class="w">                </span><span class="nv">assumeStep</span><span class="w">               </span><span class="c">// separated by newline(s)</span><span class="w"></span>
<span class="w">                </span><span class="nv">proofStep</span><span class="o">*</span><span class="w">               </span><span class="c">// separated by newline(s)</span><span class="w"></span>
<span class="w">              </span><span class="s">&#39;}&#39;</span><span class="w"></span>

<span class="nv">assumeStep</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="nv">rNUM</span><span class="w"> </span><span class="s">&#39;.&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;assume&#39;</span><span class="w"></span>
</pre></div>
</div>
<p>A proof consists of a sequence of proof steps delimited by curly braces
<code class="docutils literal"><span class="pre">{</span></code> ... <code class="docutils literal"><span class="pre">}</span></code>; the proof steps should be separated by newline(s).</p>
<p>Each proof step in the whole proof should be <em>uniquely</em>
<code class="docutils literal"><span class="pre">NUM</span></code>bered (but can be out of order), and it is either:
(a) a regular proof step (atomic), or (b) a sub-proof (composite).
(Regular step number <code class="docutils literal"><span class="pre">rNUM</span></code> and sub-proof number <code class="docutils literal"><span class="pre">sNUM</span></code> are
<code class="docutils literal"><span class="pre">NUM</span></code> <a class="reference internal" href="../basic/index.html#ops-literals"><span>literals</span></a>, but distinguished here to
increase readability of the
<a class="reference internal" href="#prop-rules"><span>justification grammar where one applies some inference rules later</span></a>.)</p>
<p>In addition to its unique number, a regular proof step consists of a
claim expression, followed by a <a class="reference internal" href="#prop-rules"><span>justification</span></a> &#8211;
a valid application of one of propositional logic
<a class="reference internal" href="#prop-rules"><span>inference rules</span></a> to deduce the claim.
A sub-proof in the propositional logic language starts with an assumption
(<code class="docutils literal"><span class="pre">assume</span></code> justification) that is also a regular proof step with a claim expression,
followed by zero or more proof steps (they are delimited inside
<code class="docutils literal"><span class="pre">{</span></code> ... <code class="docutils literal"><span class="pre">}</span></code> similar to a proof); the steps, including the assumption,
should be separated by newline(s).</p>
<p>Here is an example proof of the above sequent: <code class="docutils literal"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">r,</span>&nbsp; <span class="pre">q</span> <span class="pre">→</span> <span class="pre">r</span>&nbsp; <span class="pre">⊢</span>&nbsp; <span class="pre">(p</span> <span class="pre">∨</span> <span class="pre">q)</span> <span class="pre">→</span> <span class="pre">r</span></code>.</p>
<div class="highlight-none"><div class="highlight"><pre>{
  1. p → r                    premise
  2. q → r                    premise
  3. {
       4. p ∨ q               assume
       5. {
            6. p              assume
            7. r              →e 1 6
          }
       8. {
            9. q              assume
           10. r              →e 2 9
          }
      11. r                   ∨e 4 5 8
     }
 12. (p ∨ q) → r              →i 3
}
</pre></div>
</div>
<p>Steps <code class="docutils literal"><span class="pre">1</span></code>, <code class="docutils literal"><span class="pre">2</span></code>, <code class="docutils literal"><span class="pre">7</span></code>, <code class="docutils literal"><span class="pre">10</span></code>, <code class="docutils literal"><span class="pre">11</span></code>, and <code class="docutils literal"><span class="pre">12</span></code> are regular proof steps;
steps <code class="docutils literal"><span class="pre">4</span></code>, <code class="docutils literal"><span class="pre">6</span></code>, and <code class="docutils literal"><span class="pre">9</span></code> are assumptions; and <code class="docutils literal"><span class="pre">3</span></code>, <code class="docutils literal"><span class="pre">5</span></code>, and <code class="docutils literal"><span class="pre">8</span></code> are
sub-proofs, where <code class="docutils literal"><span class="pre">5</span></code> and <code class="docutils literal"><span class="pre">8</span></code> are nested inside <code class="docutils literal"><span class="pre">3</span></code>.</p>
</div>
<div class="section" id="proof-scoping-rules">
<span id="scoping"></span><h2>3.2.3. Proof Scoping Rules<a class="headerlink" href="#proof-scoping-rules" title="Permalink to this headline">¶</a></h2>
<p>When applying an <a class="reference internal" href="#prop-rules"><span>inference rule</span></a> to justify a proof step,
one can refer to proof step numbers preceeding it
(i.e., in the order of appearance instead of by their number ordering)
in the same level of <code class="docutils literal"><span class="pre">{</span></code> ... <code class="docutils literal"><span class="pre">}</span></code>
(e.g., <code class="docutils literal"><span class="pre">11</span></code> refers to <code class="docutils literal"><span class="pre">4</span></code>, <code class="docutils literal"><span class="pre">5</span></code>, and <code class="docutils literal"><span class="pre">8</span></code>)
or at the preeceding step numbers in any of its outer <code class="docutils literal"><span class="pre">{</span></code> ... <code class="docutils literal"><span class="pre">}</span></code> layers
(e.g., <code class="docutils literal"><span class="pre">7</span></code> refers <code class="docutils literal"><span class="pre">1</span></code>).
As a non-example, step <code class="docutils literal"><span class="pre">10</span></code> cannot refer to step <code class="docutils literal"><span class="pre">7</span></code> to deduce its claim.</p>
<p>Hence, the scoping rules are similar to variable declaration-usage scoping rules
in various programming languages such as Scala or Java, where
(with the exception that, again, each proof step number is unique throughout
the whole proof, for clarity sake).</p>
</div>
<div class="section" id="proof-schematic-pattern">
<span id="schematic-pattern"></span><h2>3.2.4. Proof Schematic Pattern<a class="headerlink" href="#proof-schematic-pattern" title="Permalink to this headline">¶</a></h2>
<p>The discussion on <a class="reference internal" href="#prop-rules"><span>justification and inference rules</span></a>
uses the following schematic pattern rule and notation.</p>
<p>Consider the situation at a regular proof step numbered <code class="docutils literal"><span class="pre">Z</span></code> whose
claim expression is <code class="docutils literal"><span class="pre">R</span></code>,
where <code class="docutils literal"><span class="pre">Z</span></code> applies an inference rule <code class="docutils literal"><span class="pre">I</span></code> to deduce <code class="docutils literal"><span class="pre">R</span></code>,
and <code class="docutils literal"><span class="pre">I</span></code> requires some claim arguments that can be retrieved from
other proof steps, say, numbered <code class="docutils literal"><span class="pre">Y</span></code> and <code class="docutils literal"><span class="pre">Z</span></code>.
The notation is as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>X. …
Y. …
Z. R    I X Y
</pre></div>
</div>
<p>In this notation, <code class="docutils literal"><span class="pre">X</span></code> and <code class="docutils literal"><span class="pre">Y</span></code> could be the same proof step,
do not have be next to each other, out of order,
and/or in the same or outer <a class="reference internal" href="#scoping"><span>scope</span></a> layers of <code class="docutils literal"><span class="pre">Z</span></code>.</p>
<p>When curly braces are explicitly listed, however,
it means that the scope of proof steps are the same.
For example:</p>
<div class="highlight-python"><div class="highlight"><pre>X. {
     X1. …
     …
     XK. …
     …
   }
Z. R    I X
</pre></div>
</div>
<p>In this case, <code class="docutils literal"><span class="pre">X1</span></code> and <code class="docutils literal"><span class="pre">XK</span></code> have to be in same level and they indicate a prefix sequence of
proof steps of <code class="docutils literal"><span class="pre">X</span></code>.</p>
</div>
<div class="section" id="claim-expression">
<span id="prop-claim"></span><h2>3.2.5. Claim Expression<a class="headerlink" href="#claim-expression" title="Permalink to this headline">¶</a></h2>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">claim</span><span class="w">       </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;⊤&#39;</span><span class="w">                        </span><span class="c">// true literal, can also use &#39;T&#39; or &#39;true&#39; for &#39;⊤&#39;            (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;⊥&#39;</span><span class="w">                        </span><span class="c">// false literal, can also use &#39;F&#39;, &#39;false&#39;, or &#39;_|_&#39; for &#39;⊥&#39;  (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="no">ID</span><span class="w">                         </span><span class="c">// identifier</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;(&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;)&#39;</span><span class="w">              </span><span class="c">// parenthesized claim expression</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;¬&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w">                  </span><span class="c">// negation, can also use &#39;not&#39;, &#39;neg&#39;, &#39;&#39;!&#39;, or &#39;~&#39; for &#39;¬&#39;    (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;∧&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w">            </span><span class="c">// conjunction/and, can also use &#39;&amp;&#39;, &#39;and&#39;, or &#39;^&#39; for &#39;∧&#39;     (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;∨&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w">            </span><span class="c">// disjunction/or, can also use &#39;|&#39;, &#39;or&#39;, or &#39;V&#39; for &#39;∨&#39;       (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;→&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w">            </span><span class="c">// implication, can also use &#39;-&gt;&#39; or &#39;implies&#39; for &#39;→&#39;          (also apply in just)</span><span class="w"></span>
</pre></div>
</div>
<p>The claim boolean expression language in propositional logic is rather small; it
consists of boolean literals, variable reference (identifier),
parenthesized expression, one unary expression (negation),
and and/or/imply binary expressions;
they are listed in decreasing order of precedence (i.e., first is highest) that
is inline with the precedence ordering specified in the <a class="reference internal" href="../basic/index.html#ops-literals"><span>Operators and Literals</span></a> section.
Note that variables do not need to be explicitly declared nor typed (they are booleans)
in the propositional input language.</p>
<div class="section" id="newlines-in-expression">
<h3>3.2.5.1. Newlines in Expression<a class="headerlink" href="#newlines-in-expression" title="Permalink to this headline">¶</a></h3>
<p>One newline separator can be inserted after a binary expression operator.
For example, <code class="docutils literal"><span class="pre">P</span> <span class="pre">∧</span> <span class="pre">Q</span></code> is the same as:</p>
<div class="highlight-python"><div class="highlight"><pre>P ∧
  Q
</pre></div>
</div>
<p>but:</p>
<div class="highlight-python"><div class="highlight"><pre>P ∧

  Q
</pre></div>
</div>
<p>where the expressions are separated by more than one newlines, are not
because they considered as two separate expressions.</p>
<p>However, newlines are ignored when they appear inside parenthesis.
That is:</p>
<div class="highlight-python"><div class="highlight"><pre>(P ∧

   Q)
</pre></div>
</div>
<p>is the same as <code class="docutils literal"><span class="pre">P</span> <span class="pre">∧</span> <span class="pre">Q</span></code></p>
<p>These rules follow
<a class="reference external" href="http://www.scala-lang.org/files/archive/spec/2.11/01-lexical-syntax.html">Scala&#8217;s line-orientation</a>
(follow the link to see more examples).</p>
</div>
<div class="section" id="expression-equivalence">
<span id="structural-eq"></span><h3>3.2.5.2. Expression Equivalence (<code class="docutils literal"><span class="pre">≡</span></code>)<a class="headerlink" href="#expression-equivalence" title="Permalink to this headline">¶</a></h3>
<p>Logika&#8217;s propositional logic reasoning mainly uses structural equivalence
(<code class="docutils literal"><span class="pre">≡</span></code>) that determines equality of two expressions <code class="docutils literal"><span class="pre">E1</span></code> and <code class="docutils literal"><span class="pre">E2</span></code>
(i.e., <code class="docutils literal"><span class="pre">E1</span> <span class="pre">≡</span> <span class="pre">E2</span></code>) based on whether they have the same structure/form.</p>
<p>A parenthesized expression is structurally (and semantically)
equivalent to the expression it contains;
it is only used as a means to override operator precedences.
In other words, for any Logika expression <code class="docutils literal"><span class="pre">E</span></code>, <code class="docutils literal"><span class="pre">E</span> <span class="pre">≡</span> <span class="pre">(E)</span></code>.
This equivalence holds even for programming logic expressions.</p>
</div>
</div>
<div class="section" id="justification-and-inference-rules">
<span id="prop-rules"></span><h2>3.2.6. Justification and Inference Rules<a class="headerlink" href="#justification-and-inference-rules" title="Permalink to this headline">¶</a></h2>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;premise&#39;</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∧i&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">            </span><span class="c">// And-Introduction</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∧e1&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// And-Elimination1</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∧e2&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// And-Elimination2</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∨i1&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// Or-Introduction1</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∨i2&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// Or-Introduction2</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∨e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">sNUM</span><span class="w"> </span><span class="nv">sNUM</span><span class="w">       </span><span class="c">// Or-Elimination</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;→i&#39;</span><span class="w">  </span><span class="nv">sNUM</span><span class="w">                 </span><span class="c">// Implication-Introduction</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;→e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">            </span><span class="c">// Implication-Elimination</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;¬i&#39;</span><span class="w">  </span><span class="nv">sNUM</span><span class="w">                 </span><span class="c">// Negation-Introduction</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;¬e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">            </span><span class="c">// Negation-Elimination</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;⊥e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// ⊥-Elimination</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;pbc&#39;</span><span class="w"> </span><span class="nv">sNUM</span><span class="w">                 </span><span class="c">// Proof-by-Contradiction</span><span class="w"></span>
</pre></div>
</div>
<p>Each regular proof step should justify the deduction that it makes
to derive its claim by applying some inference rules.
This section summarizes Logika&#8217;s rendition of propositional logic
natural deduction rules that are intuitively described in
<a class="reference internal" href="../../../dschmidt/07-propositional-logic/index.html#propositional-logic"><span>Applications of Propositional Logic to Program Proving</span></a>.</p>
<p>The subsequent discussion for each inference rules assumes that
it is being applied at a regular proof step numbered <code class="docutils literal"><span class="pre">Z</span></code>
and whose claim expression that it deduces is <code class="docutils literal"><span class="pre">R</span></code>.</p>
<div class="section" id="premise">
<h3>3.2.6.1. Premise<a class="headerlink" href="#premise" title="Permalink to this headline">¶</a></h3>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;premise&#39;</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">premise</span></code> justification can be used to call on one of the
sequent&#8217;s premises associated with the proof.
That is, <code class="docutils literal"><span class="pre">R</span></code> has to be one of the sequent&#8217;s premises.
For example,</p>
<div class="highlight-none"><div class="highlight"><pre>p,  q  ⊢  q
{
  1. q    premise
}
</pre></div>
</div>
<p>In this case, <code class="docutils literal"><span class="pre">R</span></code> is <code class="docutils literal"><span class="pre">q</span></code> (<code class="docutils literal"><span class="pre">R</span> <span class="pre">≡</span> <span class="pre">q</span></code>) and
proof step <code class="docutils literal"><span class="pre">1</span></code> (<code class="docutils literal"><span class="pre">Z</span> <span class="pre">≡</span> <span class="pre">1</span></code>) uses <code class="docutils literal"><span class="pre">premise</span></code> to deduce its
claim <code class="docutils literal"><span class="pre">q</span></code>, which is exactly the second sequent&#8217;s premise.</p>
<p>The <code class="docutils literal"><span class="pre">premise</span></code> justification can also be used to conjure <code class="docutils literal"><span class="pre">⊤</span></code> (true).
For example, here is the shortest sequent proof in Logika.</p>
<div class="highlight-none"><div class="highlight"><pre>⊢  ⊤
{
  1. ⊤   premise
}
</pre></div>
</div>
<p>In this example, <code class="docutils literal"><span class="pre">Z</span> <span class="pre">≡</span> <span class="pre">1</span></code> and <code class="docutils literal"><span class="pre">R</span> <span class="pre">≡</span> <span class="pre">⊤</span></code>.
There is no premise in the sequent needed to
justify for <code class="docutils literal"><span class="pre">⊤</span></code>; one can always depend on <code class="docutils literal"><span class="pre">⊤</span></code> to be true
to its true self.</p>
</div>
<div class="section" id="and-introduction-i">
<h3>3.2.6.2. And-Introduction (∧i)<a class="headerlink" href="#and-introduction-i" title="Permalink to this headline">¶</a></h3>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="c">// …</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∧i&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">            </span><span class="c">// And-Introduction</span><span class="w"></span>
</pre></div>
</div>
<p>The ∧i rule requires two arguments, which are regular proof step
numbers (<code class="docutils literal"><span class="pre">rNUM</span></code>s).</p>
<p>Here is a schematic pattern for valid inference using ∧i:</p>
<div class="literal-block-wrapper container" id="and-intro-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>And-Introduction (∧i) Schematic Pattern</strong></span><a class="headerlink" href="#and-intro-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>X.  P          … // justification for P
Y.  Q          … // justification for Q
Z.  P ∧ Q      ∧i X Y      // R ≡ P ∧ Q
</pre></div>
</div>
</div>
<p>For example,</p>
<div class="highlight-none"><div class="highlight"><pre>⊢ ⊤ ∧ ⊤
{
  2. ⊤       premise  // out of order proof step numbering is fine, which is
  1. ⊤ ∧ ⊤   ∧i 2 2   // handy to insert unforeseen proof steps in between others
}
</pre></div>
</div>
<p>In this case, the pattern is instantiated with
<code class="docutils literal"><span class="pre">X</span> <span class="pre">≡</span> <span class="pre">Y</span> <span class="pre">≡</span> <span class="pre">2</span></code>, <code class="docutils literal"><span class="pre">P</span> <span class="pre">≡</span> <span class="pre">Q</span> <span class="pre">≡</span> <span class="pre">⊤</span></code>, <code class="docutils literal"><span class="pre">Z</span> <span class="pre">≡</span> <span class="pre">1</span></code>, and <code class="docutils literal"><span class="pre">R</span> <span class="pre">≡</span> <span class="pre">⊤</span> <span class="pre">∧</span> <span class="pre">⊤</span></code>.</p>
<p>Another example,</p>
<div class="highlight-none"><div class="highlight"><pre>p, q ⊢ p ∧ q
{
  1. q       premise
  2. p       premise
  3. p ∧ q   ∧i 2 1
}
</pre></div>
</div>
<p>In this example, <code class="docutils literal"><span class="pre">X</span> <span class="pre">≡</span> <span class="pre">2</span></code>, <code class="docutils literal"><span class="pre">P</span> <span class="pre">≡</span> <span class="pre">p</span></code>, <code class="docutils literal"><span class="pre">Y</span> <span class="pre">≡</span> <span class="pre">1</span></code>, <code class="docutils literal"><span class="pre">Q</span> <span class="pre">≡</span> <span class="pre">q</span></code>,
<code class="docutils literal"><span class="pre">Z</span> <span class="pre">≡</span> <span class="pre">3</span></code>, and <code class="docutils literal"><span class="pre">R</span> <span class="pre">≡</span> <span class="pre">p</span> <span class="pre">∧</span> <span class="pre">q</span></code>.</p>
<p>One last example,</p>
<div class="highlight-none"><div class="highlight"><pre>p, q ⊢ p ∧ q
{
  1. q       premise
  2. p       premise
  3. p ∧ q   ∧i 2 1
}
</pre></div>
</div>
<p>In this case, <code class="docutils literal"><span class="pre">X</span> <span class="pre">≡</span> <span class="pre">1</span></code>, <code class="docutils literal"><span class="pre">P</span> <span class="pre">≡</span> <span class="pre">q</span></code>, <code class="docutils literal"><span class="pre">Y</span> <span class="pre">≡</span> <span class="pre">2</span></code>, <code class="docutils literal"><span class="pre">Q</span> <span class="pre">≡</span> <span class="pre">p</span></code>,
<code class="docutils literal"><span class="pre">Z</span> <span class="pre">≡</span> <span class="pre">3</span></code>, and <code class="docutils literal"><span class="pre">R</span> <span class="pre">≡</span> <span class="pre">q</span> <span class="pre">∧</span> <span class="pre">p</span></code>.</p>
<p>The rest of this section assumes that one already &#8220;groks&#8221;
the basics of schematic pattern by now.
Hence, the subsequent is without examples and
only discusses new concepts and Logika nuances that enhance
the natural deduction rules described
in <a class="reference internal" href="../../../dschmidt/07-propositional-logic/index.html#propositional-logic"><span>Applications of Propositional Logic to Program Proving</span></a>.</p>
</div>
<div class="section" id="and-eliminations-e1-e2">
<h3>3.2.6.3. And-Eliminations (∧e1, ∧e2)<a class="headerlink" href="#and-eliminations-e1-e2" title="Permalink to this headline">¶</a></h3>
<div class="section" id="and-elimination1-e1">
<h4>And-Elimination1 (∧e1)<a class="headerlink" href="#and-elimination1-e1" title="Permalink to this headline">¶</a></h4>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="c">// …</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∧e1&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// And-Elimination1</span><span class="w"></span>
</pre></div>
</div>
<div class="literal-block-wrapper container" id="and-elim1-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>And-Elimination1 (∧e1) Schematic Pattern</strong></span><a class="headerlink" href="#and-elim1-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>X.  R ∧ Q      …
Z.  R          ∧e1 X
</pre></div>
</div>
</div>
</div>
<div class="section" id="and-elimination2-e2">
<h4>And-Elimination2 (∧e2)<a class="headerlink" href="#and-elimination2-e2" title="Permalink to this headline">¶</a></h4>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="c">// …</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∧e2&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// And-Elimination2</span><span class="w"></span>
</pre></div>
</div>
<div class="literal-block-wrapper container" id="and-elim2-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>And-Elimination2 (∧e2) Schematic Pattern</strong></span><a class="headerlink" href="#and-elim2-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>X.  P ∧ R      …
Z.  R          ∧e2 X
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="or-introductions-i1-i2">
<h3>3.2.6.4. Or-Introductions (∨i1, ∨i2)<a class="headerlink" href="#or-introductions-i1-i2" title="Permalink to this headline">¶</a></h3>
<div class="section" id="or-introduction1-i1">
<h4>Or-Introduction1 (∨i1)<a class="headerlink" href="#or-introduction1-i1" title="Permalink to this headline">¶</a></h4>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="c">// …</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∨i1&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// Or-Introduction1</span><span class="w"></span>
</pre></div>
</div>
<div class="literal-block-wrapper container" id="or-intro1-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>Or-Introduction1 (∨i1) Schematic Pattern</strong></span><a class="headerlink" href="#or-intro1-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>X.  P          …
Z.  P ∨ Q      ∨i1 X       // R ≡ P ∨ Q
</pre></div>
</div>
</div>
</div>
<div class="section" id="or-introduction1-i2">
<h4>Or-Introduction1 (∨i2)<a class="headerlink" href="#or-introduction1-i2" title="Permalink to this headline">¶</a></h4>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="c">// …</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∨i2&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// Or-Introduction2</span><span class="w"></span>
</pre></div>
</div>
<div class="literal-block-wrapper container" id="or-intro2-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>Or-Introduction2 (∨i2) Schematic Pattern</strong></span><a class="headerlink" href="#or-intro2-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>X.  Q          …
Z.  P ∨ Q      ∨i2 X       // R ≡ P ∨ Q
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="or-elimination-e">
<span id="or-elim"></span><h3>3.2.6.5. Or-Elimination (∨e)<a class="headerlink" href="#or-elimination-e" title="Permalink to this headline">¶</a></h3>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="c">// …</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∨e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">sNUM</span><span class="w"> </span><span class="nv">sNUM</span><span class="w">       </span><span class="c">// Or-Elimination</span><span class="w"></span>
</pre></div>
</div>
<p>The ∨e justification requires two sub-proofs as its second
and third arguments (referred by using their
proof step <code class="docutils literal"><span class="pre">sNUM</span></code>ber).</p>
<div class="literal-block-wrapper container" id="or-elim-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>Or-Elimination (∨e) Schematic Pattern</strong></span><a class="headerlink" href="#or-elim-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>X.  P ∨ Q      …
Y1. {
      Y11. P   assume
      …
      Y1K. R   …
      …
    }
Y2. {
      Y21. Q   assume
      …
      Y2K. R   …
      …
    }
Z.  R          ∨e X Y1 Y2
</pre></div>
</div>
</div>
<p>Note that in the <a class="reference internal" href="#or-elim-pattern"><span>Or-Elimination (∨e) Schematic Pattern</span></a> above,
assumptions <code class="docutils literal"><span class="pre">Y11</span></code> and <code class="docutils literal"><span class="pre">Y21</span></code> must be the first proof step in
their corresponding sub-proof.</p>
<p>However, <code class="docutils literal"><span class="pre">Y1K</span></code> and <code class="docutils literal"><span class="pre">Y2K</span></code> do not have to be the last proof
step. This allows the same sub-proofs to be used to &#8220;extract&#8221;
different claims (for example, see
<a class="reference external" href="https://github.com/sireum/v3-logika-examples/blob/master/src/programming/conditional-1.logika#L43-L44">logika-examples/src/programming/conditional-1.logika&#8217;s lines#43-44</a>;
note that &#8220;ore&#8221; is an alias for ∨e).</p>
<p>Justification of
<a class="reference external" href="https://github.com/sireum/v3-logika-examples/blob/master/src/programming/conditional-1.logika#L44">conditional-1.logika&#8217;s line#44</a>
leverages the following Logika alternative pattern for ∨e.</p>
<div class="literal-block-wrapper container" id="or-elim-alt-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>Alternative Or-Elimination (∨e) Schematic Pattern</strong></span><a class="headerlink" href="#or-elim-alt-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>X.  P ∨ Q      …
Y1. {
      Y11. P   assume
      …
      Y1K. R1  …
      …
    }
Y2. {
      Y21. Q   assume
      …
      Y2K. R2  …
      …
    }
Z.  R1 ∨ R2    ∨e X Y1 Y2  // R ≡ R1 ∨ R2s
</pre></div>
</div>
</div>
<p>That is, the <a class="reference internal" href="#or-elim-alt-pattern"><span>Alternative Or-Elimination (∨e) Schematic Pattern</span></a> actually
introduces a disjunction!</p>
<p>Note that this pattern is not so useful if
<code class="docutils literal"><span class="pre">Y11</span> <span class="pre">≡</span> <span class="pre">Y1K</span></code> (thus, <code class="docutils literal"><span class="pre">P</span> <span class="pre">≡</span> <span class="pre">R1</span></code>) and
<code class="docutils literal"><span class="pre">Y21</span> <span class="pre">≡</span> <span class="pre">Y2K</span></code> (thus, <code class="docutils literal"><span class="pre">Q</span> <span class="pre">≡</span> <span class="pre">R2</span></code>),
because then <code class="docutils literal"><span class="pre">R</span> <span class="pre">≡</span> <span class="pre">P</span> <span class="pre">∨</span> <span class="pre">Q</span></code>, which is <code class="docutils literal"><span class="pre">X</span></code>&#8216;s claim
(however, it is still a valid deduction).</p>
</div>
<div class="section" id="implication-introduction-i">
<h3>3.2.6.6. Implication-Introduction (→i)<a class="headerlink" href="#implication-introduction-i" title="Permalink to this headline">¶</a></h3>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="c">// …</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;→i&#39;</span><span class="w">  </span><span class="nv">sNUM</span><span class="w">                 </span><span class="c">// Implication-Introduction</span><span class="w"></span>
</pre></div>
</div>
<div class="literal-block-wrapper container" id="imply-intro-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>Implication-Introduction (→i) Schematic Pattern</strong></span><a class="headerlink" href="#imply-intro-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>X.  {
      X1. P    assume
      …
      XK. Q    …
      …
    }
Z.  P → Q      →i X        // R ≡ P → Q
</pre></div>
</div>
</div>
</div>
<div class="section" id="implication-elimination-e">
<h3>3.2.6.7. Implication-Elimination (→e)<a class="headerlink" href="#implication-elimination-e" title="Permalink to this headline">¶</a></h3>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="c">// …</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;→e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">            </span><span class="c">// Implication-Elimination</span><span class="w"></span>
</pre></div>
</div>
<div class="literal-block-wrapper container" id="imply-elim-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>Implication-Elimination (→e) Schematic Pattern</strong></span><a class="headerlink" href="#imply-elim-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>X.  P → R      …
Y.  P          …
Z.  R          →e X Y
</pre></div>
</div>
</div>
</div>
<div class="section" id="negation-introduction-i">
<h3>3.2.6.8. Negation-Introduction (¬i)<a class="headerlink" href="#negation-introduction-i" title="Permalink to this headline">¶</a></h3>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="c">// …</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;¬i&#39;</span><span class="w">  </span><span class="nv">sNUM</span><span class="w">                 </span><span class="c">// Negation-Introduction</span><span class="w"></span>
</pre></div>
</div>
<div class="literal-block-wrapper container" id="neg-intro-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>Negation-Introduction (¬i) Schematic Pattern</strong></span><a class="headerlink" href="#neg-intro-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>X.  {
      X1. P    assume
      …
      XK. ⊥    …
      …
    }
Z.  ¬P         ¬i X        // R ≡ ¬P
</pre></div>
</div>
</div>
</div>
<div class="section" id="negation-elimination-e">
<h3>3.2.6.9. Negation-Elimination (¬e)<a class="headerlink" href="#negation-elimination-e" title="Permalink to this headline">¶</a></h3>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="c">// …</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;¬e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">            </span><span class="c">// Negation-Elimination</span><span class="w"></span>
</pre></div>
</div>
<div class="literal-block-wrapper container" id="neg-elim-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>Negation-Elimination (¬e) Schematic Pattern</strong></span><a class="headerlink" href="#neg-elim-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>X.  P          …
Y.  ¬P         …
Z.  ⊥          ¬e X Y      // R ≡ ⊥
</pre></div>
</div>
</div>
</div>
<div class="section" id="elimination-e">
<span id="bottom-elim"></span><h3>3.2.6.10. ⊥-Elimination  (⊥e)<a class="headerlink" href="#elimination-e" title="Permalink to this headline">¶</a></h3>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="c">// …</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;⊥e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// ⊥-Elimination</span><span class="w"></span>
</pre></div>
</div>
<div class="literal-block-wrapper container" id="bottom-elim-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>⊥-Elimination (⊥e) Schematic Pattern</strong></span><a class="headerlink" href="#bottom-elim-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>X.  ⊥          …
Z.  R          ⊥e X        // R  can be anything! Be all you can be! From zero to hero!
</pre></div>
</div>
</div>
</div>
<div class="section" id="proof-by-contradiction-pbc">
<h3>3.2.6.11. Proof-by-Contradiction (pbc)<a class="headerlink" href="#proof-by-contradiction-pbc" title="Permalink to this headline">¶</a></h3>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="c">// …</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;pbc&#39;</span><span class="w"> </span><span class="nv">sNUM</span><span class="w">                 </span><span class="c">// Proof-by-Contradiction</span><span class="w"></span>
</pre></div>
</div>
<div class="literal-block-wrapper container" id="pbc-elim-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>Proof-by-Contradiction (pbc) Schematic Pattern</strong></span><a class="headerlink" href="#pbc-elim-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>X.  {
      X1. ¬R   assume
      …
      XK. ⊥    …
      …
    }
Z.  R          pbc
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="propositional-logic-input-language-grammar">
<span id="prop-grammar"></span><h2>3.2.7. Propositional Logic Input Language Grammar<a class="headerlink" href="#propositional-logic-input-language-grammar" title="Permalink to this headline">¶</a></h2>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">propositional</span><span class="p">:</span><span class="w"> </span><span class="nv">sequent</span><span class="w"> </span><span class="nv">proof</span><span class="w">           </span><span class="c">// newlines are treated as whitespaces until start of proof</span><span class="w"></span>

<span class="nv">sequent</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="nv">claimList</span><span class="o">?</span><span class="w">               </span><span class="c">// premises</span><span class="w"></span>
<span class="w">              </span><span class="s">&#39;⊢&#39;</span><span class="w">                      </span><span class="c">// turnstile (&quot;turn-the-style&quot;), can also use &#39;|-&#39; for &#39;⊢&#39;</span><span class="w"></span>
<span class="w">              </span><span class="nv">claimList</span><span class="w">                </span><span class="c">// conclusions</span><span class="w"></span>

<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">claim</span><span class="o">*</span><span class="w">                   </span><span class="c">// premises</span><span class="w"></span>
<span class="w">              </span><span class="no">HLINE</span><span class="w">                    </span><span class="c">// HLINE is three or more dashes &#39;-&#39;</span><span class="w"></span>
<span class="w">              </span><span class="nv">claim</span><span class="o">+</span><span class="w">                   </span><span class="c">// conclusions</span><span class="w"></span>

<span class="nv">claimList</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="s">&#39;,&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="o">)*</span><span class="w"></span>

<span class="nv">proof</span><span class="w">       </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;{&#39;</span><span class="w"></span>
<span class="w">                </span><span class="nv">proofStep</span><span class="o">+</span><span class="w">             </span><span class="c">// separated by newline(s)</span><span class="w"></span>
<span class="w">              </span><span class="s">&#39;}&#39;</span><span class="w"></span>

<span class="nv">proofStep</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="nv">regularStep</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">subProof</span><span class="w"></span>

<span class="nv">regularStep</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">rNUM</span><span class="w"> </span><span class="s">&#39;.&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="nv">just</span><span class="w">        </span><span class="c">// rNUM is NUM, distinguished for readability of just arguments later</span><span class="w"></span>

<span class="nv">subProof</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="nv">sNUM</span><span class="w"> </span><span class="s">&#39;.&#39;</span><span class="w">                   </span><span class="c">// sNUM is NUM, distinguished for readability of just arguments later</span><span class="w"></span>
<span class="w">              </span><span class="s">&#39;{&#39;</span><span class="w"></span>
<span class="w">                </span><span class="nv">assumeStep</span><span class="w">               </span><span class="c">// separated by newline(s)</span><span class="w"></span>
<span class="w">                </span><span class="nv">proofStep</span><span class="o">*</span><span class="w">               </span><span class="c">// separated by newline(s)</span><span class="w"></span>
<span class="w">              </span><span class="s">&#39;}&#39;</span><span class="w"></span>

<span class="nv">assumeStep</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="nv">rNUM</span><span class="w"> </span><span class="s">&#39;.&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;assume&#39;</span><span class="w"></span>

<span class="nv">claim</span><span class="w">       </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;⊤&#39;</span><span class="w">                        </span><span class="c">// true literal, can also use &#39;T&#39; or &#39;true&#39; for &#39;⊤&#39;            (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;⊥&#39;</span><span class="w">                        </span><span class="c">// false literal, can also use &#39;F&#39;, &#39;false&#39;, or &#39;_|_&#39; for &#39;⊥&#39;  (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="no">ID</span><span class="w">                         </span><span class="c">// identifier</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;(&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;)&#39;</span><span class="w">              </span><span class="c">// parenthesized claim expression</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;¬&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w">                  </span><span class="c">// negation, can also use &#39;not&#39;, &#39;neg&#39;, &#39;&#39;!&#39;, or &#39;~&#39; for &#39;¬&#39;    (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;∧&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w">            </span><span class="c">// conjunction/and, can also use &#39;&amp;&#39;, &#39;and&#39;, or &#39;^&#39; for &#39;∧&#39;     (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;∨&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w">            </span><span class="c">// disjunction/or, can also use &#39;|&#39;, &#39;or&#39;, or &#39;V&#39; for &#39;∨&#39;       (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;→&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w">            </span><span class="c">// implication, can also use &#39;-&gt;&#39; or &#39;implies&#39; for &#39;→&#39;          (also apply in just)</span><span class="w"></span>

<span class="nv">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;premise&#39;</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∧i&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">            </span><span class="c">// And-Introduction</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∧e1&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// And-Elimination1</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∧e2&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// And-Elimination2</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∨i1&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// Or-Introduction1</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∨i2&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// Or-Introduction2</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∨e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">sNUM</span><span class="w"> </span><span class="nv">sNUM</span><span class="w">       </span><span class="c">// Or-Elimination</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;→i&#39;</span><span class="w">  </span><span class="nv">sNUM</span><span class="w">                 </span><span class="c">// Implication-Introduction</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;→e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">            </span><span class="c">// Implication-Elimination</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;¬i&#39;</span><span class="w">  </span><span class="nv">sNUM</span><span class="w">                 </span><span class="c">// Negation-Introduction</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;¬e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">            </span><span class="c">// Negation-Elimination</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;⊥e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// ⊥-Elimination</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;pbc&#39;</span><span class="w"> </span><span class="nv">sNUM</span><span class="w">                 </span><span class="c">// Proof-by-Contradiction</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>


    </div>
      
  </div>
</div>

  </body>
</html>