
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>3.3. Predicate Logic &mdash; Sireum Logika</title>
    
    <link rel="stylesheet" href="../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/bootswatch-3.3.4/journal/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/sireum.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-3.3.4/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../../_static/logika.ico"/>
    <link rel="top" title="Sireum Logika" href="../../../index.html" />
    <link rel="up" title="3. The Logika Formal Input Language" href="../index.html" />
    <link rel="next" title="3.4. Programming Logic" href="../programming/index.html" />
    <link rel="prev" title="3.2. Propositional Logic" href="../propositional/index.html" />
  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          Logika</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../index.html">Documentation</a></li>
                <li><a href="../../../dschmidt/index.html">Course Notes</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html"> <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#"> <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">3.3. Predicate Logic</a><ul>
<li><a class="reference internal" href="#revised-sub-proof-assumption-step">3.3.1. Revised Sub-Proof Assumption Step</a></li>
<li><a class="reference internal" href="#extended-claim-expressions">3.3.2. Extended Claim Expressions</a><ul>
<li><a class="reference internal" href="#first-order-uninterpreted-predicate-and-function-applications">3.3.2.1. First-Order Uninterpreted Predicate and Function Applications</a></li>
<li><a class="reference internal" href="#universally-and-existensially-quantified-claims">3.3.2.2. Universally (∀) and Existensially (∃) Quantified Claims</a></li>
<li><a class="reference internal" href="#well-formed-ness">3.3.2.3. Well-Formed-ness</a></li>
<li><a class="reference internal" href="#abstract-notation-and-substitution">3.3.2.4. Abstract Notation and Substitution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#quantified-claim-justification-and-inference-rules">3.3.3. Quantified Claim Justification and Inference Rules</a><ul>
<li><a class="reference internal" href="#forall-introduction-i">3.3.3.1. Forall-Introduction (∀i)</a></li>
<li><a class="reference internal" href="#forall-elimination-e">3.3.3.2. Forall-Elimination (∀e)</a></li>
<li><a class="reference internal" href="#exists-introduction-i">3.3.3.3. Exists-Introduction (∃i)</a></li>
<li><a class="reference internal" href="#exists-elimination-e">3.3.3.4. Exists-Elimination (∃e)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#predicate-logic-input-language-grammar">3.3.4. Predicate Logic Input Language Grammar</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <br/>
<font color="darkgray">
<big><big><b>
Sireum Logika Documentation &mdash; <a href="../index.html">3. The Logika Formal Input Language</a>
</b></big></big>
</font>
<br/>
<font color="black">
<big><big><big><big><b>
3.3. Predicate Logic
</b></big></big></big></big>
</font><div class="section" id="predicate-logic">
<span id="predicate-language"></span><h1>3.3. Predicate Logic<a class="headerlink" href="#predicate-logic" title="Permalink to this headline">¶</a></h1>
<p>The Logika predicate logic input language is a small
extension of the <a class="reference internal" href="../propositional/index.html#propositional-language"><span>Propositional Logic</span></a> input language
where the additional language elements are:
(1) <a class="reference internal" href="#revised-assumptions"><span>Revised Sub-Proof Assumption Step</span></a>,
(2) <a class="reference internal" href="#uninterpreted-functions"><span>First-Order Uninterpreted Predicate and Function Applications</span></a>,
(3) <a class="reference internal" href="#quantified-claims"><span>Universally (∀) and Existensially (∃) Quantified Claims</span></a>,
(4) <a class="reference internal" href="#pred-rules"><span>Quantified Claim Justification and Inference Rules</span></a>.</p>
<p>Similar to the discussion in the <a class="reference internal" href="../propositional/index.html#propositional-language"><span>Propositional Logic</span></a> input
language chapter, this chapter only discuss
Logika&#8217;s rendition of predicate logic natural deductions;
the reader is referred to <a class="reference internal" href="../../../dschmidt/08-predicate-logic/index.html#predicate-logic"><span>The Predicate-Logic Quantifiers</span></a> for intuitive
discussion on predicate logic.</p>
<p><strong>Predicate Logic Input Language Grammar</strong></p>
<div class="highlight-antlr" id="predicate-1"><div class="highlight"><pre><span class="nl">predicate</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="nv">sequent</span><span class="w"> </span><span class="nv">proof</span><span class="w">              </span><span class="c">// newlines are treated as whitespaces until start of proof</span><span class="w"></span>
</pre></div>
</div>
<p>The predicate logic input language is similar to that of
<a class="reference internal" href="../propositional/index.html#propositional-language"><span>Propositional Logic</span></a> input language, where it consists
of a sequent and the sequent&#8217;s proof. Here is an example that is
also a <a class="reference external" href="https://en.wikipedia.org/wiki/Syllogism">syllogism</a>:</p>
<div class="highlight-none"><div class="highlight"><pre>∀x human(x) → mortal(x),  ∃y human(y)  ⊢  ∃z mortal(z)
{
  1. ∀x human(x) → mortal(x)               premise
  2. ∃y human(y)                           premise
  3. {
       4. a  human(a)                      assume
       5. human(a) → mortal(a)             ∀e 1 a
       6. mortal(a)                        →e 5 4
       7. ∃z mortal(z)                     ∃i 6 a
     }
  8. ∃z mortal(z)                          ∃e 2 3
}
</pre></div>
</div>
<p>In the subsequent description, only language elements that are new
or extend the <a class="reference internal" href="../propositional/index.html#propositional-language"><span>Propositional Logic</span></a> input language are
discussed. The complete predicate logic input language is
given in the <a class="reference internal" href="#pred-grammar"><span>Predicate Logic Input Language Grammar</span></a> section as a reference.</p>
<div class="section" id="revised-sub-proof-assumption-step">
<span id="revised-assumptions"></span><h2>3.3.1. Revised Sub-Proof Assumption Step<a class="headerlink" href="#revised-sub-proof-assumption-step" title="Permalink to this headline">¶</a></h2>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">assumeStep</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="nv">rNUM</span><span class="w"> </span><span class="s">&#39;.&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;assume&#39;</span><span class="w"></span>
<span class="hll"><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">rNUM</span><span class="w"> </span><span class="s">&#39;.&#39;</span><span class="w"> </span><span class="no">ID</span><span class="w">                </span><span class="c">// ID must be &quot;fresh&quot; in scope; used for ForAll-Introduction</span><span class="w"></span>
</span><span class="hll"><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">rNUM</span><span class="w"> </span><span class="s">&#39;.&#39;</span><span class="w"> </span><span class="no">ID</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;assume&#39;</span><span class="w"> </span><span class="c">// ID must be &quot;fresh&quot;; used for Exists-Elimination</span><span class="w"></span>
</span></pre></div>
</div>
<p>To support <a class="reference internal" href="#pred-rules"><span>Quantified Claim Justification and Inference Rules</span></a>, the sub-proof assumption form has to be
enhanced.</p>
<p>The first highlighted enhancement is to introduce a &#8220;fresh&#8221; variable
suitable for <a class="reference internal" href="#forall-intro"><span>introducing a universal quantification</span></a>;
here, &#8220;fresh&#8221; means that the identifier is not used in the
<a class="reference internal" href="../propositional/index.html#scoping"><span>scope</span></a> of the variable; this form is a special one
because it is not a regular proof step which has a claim associated with it.</p>
<p>The second highlighted form also introduces a fresh variable, but also
has an associated claim assumption that refers to the fresh variable.
This form is used for
<a class="reference internal" href="#exists-elim"><span>eliminating an existensial quantification</span></a>.</p>
</div>
<div class="section" id="extended-claim-expressions">
<h2>3.3.2. Extended Claim Expressions<a class="headerlink" href="#extended-claim-expressions" title="Permalink to this headline">¶</a></h2>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">claim</span><span class="w">       </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;⊤&#39;</span><span class="w">                        </span><span class="c">// true literal, can also use &#39;T&#39; or &#39;true&#39; for &#39;⊤&#39;            (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;⊥&#39;</span><span class="w">                        </span><span class="c">// false literal, can also use &#39;F&#39;, &#39;false&#39;, or &#39;_|_&#39; for &#39;⊥&#39;  (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="no">ID</span><span class="w">                         </span><span class="c">// identifier</span><span class="w"></span>
<span class="hll"><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="no">ID</span><span class="w"> </span><span class="s">&#39;(&#39;</span><span class="w"> </span><span class="nv">claimList</span><span class="o">?</span><span class="w"> </span><span class="s">&#39;)&#39;</span><span class="w">      </span><span class="c">// predicate application</span><span class="w"></span>
</span><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;(&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;)&#39;</span><span class="w">              </span><span class="c">// parenthesized claim expression</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;¬&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w">                  </span><span class="c">// negation, can also use &#39;not&#39;, &#39;!&#39;, or &#39;~&#39; for &#39;¬&#39;            (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;∧&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w">            </span><span class="c">// conjunction/and, can also use &#39;&amp;&#39;, &#39;and&#39;, or &#39;^&#39; for &#39;∧&#39;     (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;∨&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w">            </span><span class="c">// disjunction/or, can also use &#39;|&#39;, &#39;or&#39;, or &#39;V&#39; for &#39;∨&#39;       (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;→&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w">            </span><span class="c">// implication, can also use &#39;-&gt;&#39; or &#39;implies&#39; for &#39;→&#39;          (also apply in just)</span><span class="w"></span>
<span class="hll"><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="s">&#39;∀&#39;</span><span class="w">                      </span><span class="c">// univ. quant., can also use &#39;forall&#39;, &#39;all&#39;, &#39;A&#39; for &#39;∀&#39;      (also apply in just)</span><span class="w"></span>
</span><span class="hll"><span class="w">              </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∃&#39;</span><span class="w">                      </span><span class="c">// exist. quant., can also use &#39;exists&#39;, &#39;some&#39;, &#39;E&#39; for &#39;∃&#39;    (also apply in just)</span><span class="w"></span>
</span><span class="hll"><span class="w">              </span><span class="o">)</span><span class="w"> </span><span class="no">ID</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="s">&#39;,&#39;</span><span class="w"> </span><span class="no">ID</span><span class="o">)*</span><span class="w"> </span><span class="nv">claim</span><span class="w"></span>
</span></pre></div>
</div>
<p>Similar to <a class="reference internal" href="../propositional/index.html#prop-claim"><span>propositional logic claim expressions</span></a>,
the predicate logic claim expressions are untyped.
One can take the view that all variables in Logika&#8217;s predicate logic
language are of integer type and
all predicates/functions accepts only integers and returns an integer, where
zero is treated as <code class="docutils literal"><span class="pre">⊥</span></code> and non-zero as <code class="docutils literal"><span class="pre">⊤</span></code>.
Integers are desirable in this context instead of booleans because
it allows one to quantify over (infinitely) many objects
instead of only two.</p>
<p>At any rate, the claim expression language in Logika&#8217;s
predicate logic has two additional kinds of expression:
(1) predicate/function applications, and (2) quantified claims,
as highlighted above, and described next.</p>
<div class="section" id="first-order-uninterpreted-predicate-and-function-applications">
<span id="uninterpreted-functions"></span><h3>3.3.2.1. First-Order Uninterpreted Predicate and Function Applications<a class="headerlink" href="#first-order-uninterpreted-predicate-and-function-applications" title="Permalink to this headline">¶</a></h3>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">assumeStep</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="c">// …</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="no">ID</span><span class="w"> </span><span class="s">&#39;(&#39;</span><span class="w"> </span><span class="nv">claimList</span><span class="o">?</span><span class="w"> </span><span class="s">&#39;)&#39;</span><span class="w">      </span><span class="c">// predicate application</span><span class="w"></span>

<span class="nv">claimList</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="s">&#39;,&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="o">)*</span><span class="w"></span>
</pre></div>
</div>
<p>A predicate is a function that returns either <code class="docutils literal"><span class="pre">⊤</span></code> or <code class="docutils literal"><span class="pre">⊥</span></code>.
In predicate logic, the meaning of each function is unspecified,
thus, uninterpreted.</p>
<p>Instead of depending on function interpretations,
Logika&#8217;s predicate logic reasoning uses
<a class="reference internal" href="#subst-notation"><span>rewriting/substitution</span></a>, in addition to
<a class="reference internal" href="../propositional/index.html#structural-eq"><span>structural equivalence</span></a> (<code class="docutils literal"><span class="pre">≡</span></code>)
that is used in propositional logic.
The rewriting technique depends on the fact that each function is
pure, meaning that it produces the same result
when given the same arguments regardless of how many times
it is applied (invoked/called).</p>
<p>A predicate is applied by referring to its
identifier followed by some ordered arguments (optional)
which are separated by a comma (<code class="docutils literal"><span class="pre">,</span></code>) and delimited by a
parenthesis, such as shown in the
<a class="reference internal" href="#predicate-1"><span>syllogism</span></a> example above.</p>
<p>Predicates have to always be supplied with arguments whenever
referred. This makes it easy to distinguish whether an identifier is
a predicate, e.g.,:</p>
<div class="highlight-none"><div class="highlight"><pre>∀x human(x) → mortal(x),  human(Socrates)  ⊢  mortal(Socrates)
{
  1. ∀x human(x) → mortal(x)               premise
  2. human(Socrates)                       premise
  3. human(Socrates) → mortal(Socrates)    ∀e 1 Socrates
  4. mortal(Socrates)                      →e 3 2
}
</pre></div>
</div>
<p>In this popular syllogism,
<code class="docutils literal"><span class="pre">Socrates</span></code> is distinguishably a variable (intuitively, it points
to Socrates the person, which is mechanically modeled using
an integer object made up from <code class="docutils literal"><span class="pre">1</span></code>s and <code class="docutils literal"><span class="pre">0</span></code>s), but
<code class="docutils literal"><span class="pre">human</span></code> and <code class="docutils literal"><span class="pre">mortal</span></code> are predicates (which intuitively,
classify whether an object is a human and a mortal, respectively).</p>
<p>In Logika, all functions are first-order, i.e., they
do not accept function values as arguments. Note that this
does not preclude functions to accepts results of other functions,
as illustrated in the following example:</p>
<div class="highlight-none"><div class="highlight"><pre>∀x gt(inc(x), x)     ∀x gt(x, dec(x))
-------------------------------------
 ∀x gt(inc(x), x)  ∧  gt(x, dec(x))
{
  1. ∀x gt(inc(x), x)                      premise
  2. ∀x gt(x, dec(x))                      premise
  3. {
       4. a
       5. gt(inc(a), a)                    ∀e 1 a
       6. gt(a, dec(a))                    ∀e 2 a
       7. gt(inc(a), a)  ∧  gt(a, dec(a))  ∧i 5 6
     }
  8. ∀x gt(inc(x), x)  ∧  gt(x, dec(x))    ∀i 3
}
</pre></div>
</div>
<p>As can be observed, the <code class="docutils literal"><span class="pre">gt</span></code> predicate can accepts results of
applying functions <code class="docutils literal"><span class="pre">inc</span></code> and <code class="docutils literal"><span class="pre">dec</span></code>.
(By the way, the example uses uninterpreted functions/predicates
to model properties of integer arithmetic operators
due to the lack for
<a class="reference internal" href="../../../dschmidt/03-algebra/index.html#algebra"><span>algebra</span></a> support in Logika&#8217;s predicate logic;
it is supported in <a class="reference internal" href="../programming/index.html#programming-language"><span>programming logic</span></a>
instead.)</p>
<p>Furthermore, Logika functions cannot be overloaded;
each is only associated with exactly one signature.
In Logika&#8217;s predicate logic, the signature is
only determined by the number of its arguments; hence,
each function has a fixed number of arguments.</p>
</div>
<div class="section" id="universally-and-existensially-quantified-claims">
<span id="quantified-claims"></span><h3>3.3.2.2. Universally (∀) and Existensially (∃) Quantified Claims<a class="headerlink" href="#universally-and-existensially-quantified-claims" title="Permalink to this headline">¶</a></h3>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">claim</span><span class="w">       </span><span class="p">:</span><span class="w"> </span><span class="c">// …</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="s">&#39;∀&#39;</span><span class="w">                      </span><span class="c">// univ. quant., can also use &#39;forall&#39;, &#39;all&#39;, &#39;A&#39; for &#39;∀&#39;      (also apply in just)</span><span class="w"></span>
<span class="w">              </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∃&#39;</span><span class="w">                      </span><span class="c">// exist. quant., can also use &#39;exists&#39;, &#39;some&#39;, &#39;E&#39; for &#39;∃&#39;    (also apply in just)</span><span class="w"></span>
<span class="w">              </span><span class="o">)</span><span class="w"> </span><span class="no">ID</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="s">&#39;,&#39;</span><span class="w"> </span><span class="no">ID</span><span class="o">)*</span><span class="w"> </span><span class="nv">claim</span><span class="w"></span>
</pre></div>
</div>
<p>Logika&#8217;s quantification form can be used to quantify
over multiple variables at once (followed by a
claim expression), which means the same as if one
quantifies over the variables one by one in the same order.
For example,
<code class="docutils literal"><span class="pre">∀x</span> <span class="pre">∀y</span> <span class="pre">p(x,y)</span></code> is semantically equivalent as <code class="docutils literal"><span class="pre">∀x,y</span> <span class="pre">p(x,y)</span></code>;
however, for simplicity, they are not considered as structurally equivalent, i.e.,
<code class="docutils literal"><span class="pre">¬(∀x</span> <span class="pre">∀y</span> <span class="pre">p(x,y)</span> <span class="pre">≡</span> <span class="pre">∀x,y</span> <span class="pre">p(x,y))</span></code> or <code class="docutils literal"><span class="pre">∀x</span> <span class="pre">∀y</span> <span class="pre">p(x,y)</span> <span class="pre">≢</span> <span class="pre">∀x,y</span> <span class="pre">p(x,y)</span></code>.</p>
</div>
<div class="section" id="well-formed-ness">
<h3>3.3.2.3. Well-Formed-ness<a class="headerlink" href="#well-formed-ness" title="Permalink to this headline">¶</a></h3>
<p>For simplicity, Logika does not allow identifier &#8220;shadowing&#8221;,
which means that a variable cannot be quantified more than one time in the
same scope.
For example, <code class="docutils literal"><span class="pre">∀x</span> <span class="pre">(…</span> <span class="pre">∧</span> <span class="pre">∀x</span> <span class="pre">…)</span></code> is ill-formed in Logika, but
<code class="docutils literal"><span class="pre">(∀x</span> <span class="pre">…)</span>&nbsp; <span class="pre">∧</span>&nbsp; <span class="pre">(∀x</span> <span class="pre">…)</span></code> is well-formed.</p>
<p>In general, <code class="docutils literal"><span class="pre">x</span> <span class="pre">∧</span> <span class="pre">∀x</span> <span class="pre">…</span></code> is well-formed, because the first variable <code class="docutils literal"><span class="pre">x</span></code> is
different than the quantified variable <code class="docutils literal"><span class="pre">x</span></code>.
The first <code class="docutils literal"><span class="pre">x</span></code> is a <em>free</em> variable because it is not
defined/quantified in the expression where it is referred,
while the second <code class="docutils literal"><span class="pre">x</span></code> is defined in the quantification.</p>
<p>However, to avoid confusion, Logika disallows such claim expression.
This is because, in the context of a sequent and its proof, all free variables
are actually <em>implicitly universally-quantified</em> (even for propositional logic).
In that sense, disallowing the same identifier used for as both free and quantified
is consistent with the restriction of disallowing identifier shadowing.</p>
</div>
<div class="section" id="abstract-notation-and-substitution">
<span id="subst-notation"></span><h3>3.3.2.4. Abstract Notation and Substitution<a class="headerlink" href="#abstract-notation-and-substitution" title="Permalink to this headline">¶</a></h3>
<p>One abstract notation that is used from now on is to express that a claim
<code class="docutils literal"><span class="pre">R</span></code> that refers to some free (in the context of <code class="docutils literal"><span class="pre">R</span></code> itself) variables
such as <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code>, as: <code class="docutils literal"><span class="pre">R{a,b}</span></code>.
In this notation, the order appearance of variables <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code>
do not matter.
For example, one can abstract <code class="docutils literal"><span class="pre">∀x,y</span> <span class="pre">p(x,y))</span></code> as <code class="docutils literal"><span class="pre">∀x,y</span> <span class="pre">Q{x,y}</span></code> or
<code class="docutils literal"><span class="pre">∀x,y</span> <span class="pre">Q{y,x}</span></code> because both just say that the claim <code class="docutils literal"><span class="pre">Q</span></code> refers
to both <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code>.
Thus, in general, when defining a quantification, it is either one of the
following forms:
<code class="docutils literal"><span class="pre">∀a1,...,aN</span> <span class="pre">P{a1,...,aN}</span></code> (universal), or
<code class="docutils literal"><span class="pre">∃a1,...,aN</span> <span class="pre">P{a1,...,aN}</span></code> (existensial).</p>
<p>Another notation is for expression substitution.
The notation <code class="docutils literal"><span class="pre">[E2/E1]R</span></code> means all occurences of expression
<code class="docutils literal"><span class="pre">E1</span></code> in <code class="docutils literal"><span class="pre">R</span></code> is replaced with <code class="docutils literal"><span class="pre">E2</span></code>; one easy way to remember
which one replaces which one is to read <code class="docutils literal"><span class="pre">/</span></code> as &#8220;steps over&#8221;,
thus <code class="docutils literal"><span class="pre">[E2/E1]R</span></code> reads as <code class="docutils literal"><span class="pre">E2</span></code> steps over <code class="docutils literal"><span class="pre">E1</span></code> in <code class="docutils literal"><span class="pre">R</span></code>.</p>
<p>Here is a concrete example of a substitution, <code class="docutils literal"><span class="pre">[x/y]g(y)</span> <span class="pre">≡</span> <span class="pre">g(x)</span></code>.
Another example, <code class="docutils literal"><span class="pre">[f(g(x))/f(y)]g(f(y),</span> <span class="pre">f(x))</span> <span class="pre">≡</span> <span class="pre">g(f(g(x)),</span> <span class="pre">f(x))</span></code>.</p>
</div>
</div>
<div class="section" id="quantified-claim-justification-and-inference-rules">
<span id="pred-rules"></span><h2>3.3.3. Quantified Claim Justification and Inference Rules<a class="headerlink" href="#quantified-claim-justification-and-inference-rules" title="Permalink to this headline">¶</a></h2>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;premise&#39;</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∧i&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">            </span><span class="c">// And-Introduction</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∧e1&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// And-Elimination1</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∧e2&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// And-Elimination2</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∨i1&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// Or-Introduction1</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∨i2&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// Or-Introduction2</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∨e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">sNUM</span><span class="w"> </span><span class="nv">sNUM</span><span class="w">       </span><span class="c">// Or-Elimination</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;→i&#39;</span><span class="w">  </span><span class="nv">sNUM</span><span class="w">                 </span><span class="c">// Implication-Introduction</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;→e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">            </span><span class="c">// Implication-Elimination</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;¬i&#39;</span><span class="w">  </span><span class="nv">sNUM</span><span class="w">                 </span><span class="c">// Negation-Introduction</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;¬e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">            </span><span class="c">// Negation-Elimination</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;⊥e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// ⊥-Elimination</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;Pbc&#39;</span><span class="w"> </span><span class="nv">sNUM</span><span class="w">                 </span><span class="c">// Proof-by-Contradiction</span><span class="w"></span>
<span class="hll"><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∀i&#39;</span><span class="w">  </span><span class="nv">sNUM</span><span class="w">                 </span><span class="c">// Forall-Introduction</span><span class="w"></span>
</span><span class="hll"><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∀e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">claim</span><span class="o">+</span><span class="w">          </span><span class="c">// Forall-Elimination</span><span class="w"></span>
</span><span class="hll"><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∃i&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">claim</span><span class="o">+</span><span class="w">          </span><span class="c">// Exists-Introduction</span><span class="w"></span>
</span><span class="hll"><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∃e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">sNUM</span><span class="w">            </span><span class="c">// Exists-Elimination</span><span class="w"></span>
</span></pre></div>
</div>
<p>There are four new inference rules for Logika&#8217;s predicate
logic &#8211; one introduction rule and one elimination rule for
both universal and existensial quantifications.</p>
<div class="section" id="forall-introduction-i">
<span id="forall-intro"></span><h3>3.3.3.1. Forall-Introduction (∀i)<a class="headerlink" href="#forall-introduction-i" title="Permalink to this headline">¶</a></h3>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="c">// …</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∀i&#39;</span><span class="w">  </span><span class="nv">sNUM</span><span class="w">                 </span><span class="c">// Forall-Introduction</span><span class="w"></span>
</pre></div>
</div>
<div class="literal-block-wrapper container" id="forall-intro-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>Forall-Introduction (∀i) Schematic Pattern</strong></span><a class="headerlink" href="#forall-intro-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>…
X. {
     X1. a                                                   // variable  a  has to be fresh
     …
     XK. P{a}                                …
     …
   }
…
Z. ∀x P{x}                                   ∀i X            // P{x} ≡ [x/a]P{a}
</pre></div>
</div>
</div>
<div class="literal-block-wrapper container" id="forall-intro-alt-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>Alternative Forall-Introduction (∀i) Schematic Pattern</strong></span><a class="headerlink" href="#forall-intro-alt-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>…
X. {
     X1. a                                                   // variable  a  has to be fresh
     …
     XK. ∀y1,…,yN P{a}                       …               // N &gt; 0 (otherwise the previous applies)
     …
   }
…
Z. ∀x,y1,…,yN P{x}                           ∀i X            // P{x} ≡ [x/a]P{a}
</pre></div>
</div>
</div>
</div>
<div class="section" id="forall-elimination-e">
<h3>3.3.3.2. Forall-Elimination (∀e)<a class="headerlink" href="#forall-elimination-e" title="Permalink to this headline">¶</a></h3>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="c">// …</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∀e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">claim</span><span class="o">+</span><span class="w">          </span><span class="c">// Forall-Elimination</span><span class="w"></span>
</pre></div>
</div>
<div class="literal-block-wrapper container" id="forall-elim-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>Forall-Elimination (∀e) Schematic Pattern</strong></span><a class="headerlink" href="#forall-elim-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>…
X. ∀x P{x}                                   …
…
Z. [E/x]P{x}                                 ∀e X E
</pre></div>
</div>
</div>
<div class="literal-block-wrapper container" id="forall-elim-alt-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>Alternative Forall-Elimination (∀e) Schematic Pattern</strong></span><a class="headerlink" href="#forall-elim-alt-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>…
X. ∀x1,…,xN P{x1,…,xN}                       …               // N &gt; 1 (otherwise the previous applies)
…
Z. ∀x(K+1),…,xN [E1/x1]…[EK/xK]P{x1,…,xN}    ∀e X E1 … EK    // K &lt;= N
</pre></div>
</div>
</div>
<div class="literal-block-wrapper container" id="forall-elim-alt2-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>Alternative+1 Forall-Elimination (∀e) Schematic Pattern</strong></span><a class="headerlink" href="#forall-elim-alt2-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>…
X. ∀x1,…,xK ∀x(K+1),…,xN P{x1,…,xN}          …
…
Z. ∀x(J+1),…,xN [E1/x1]…[EJ/xK]P{x1,…,xN}    ∀e X E1 … EJ    // 0 &lt; K &lt; J &lt;= N
</pre></div>
</div>
</div>
</div>
<div class="section" id="exists-introduction-i">
<h3>3.3.3.3. Exists-Introduction (∃i)<a class="headerlink" href="#exists-introduction-i" title="Permalink to this headline">¶</a></h3>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="c">// …</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∃i&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">claim</span><span class="o">+</span><span class="w">          </span><span class="c">// Exists-Introduction</span><span class="w"></span>
</pre></div>
</div>
<div class="literal-block-wrapper container" id="exists-intro-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>Exists-Introduction (∃i) Schematic Pattern</strong></span><a class="headerlink" href="#exists-intro-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>…
X. [E/x]P{x}                                 …
…
Z. ∃x P{x}                                   ∀e X E
</pre></div>
</div>
</div>
<div class="literal-block-wrapper container" id="exists-intro-alt-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>Alternative Exists-Introduction (∃i) Schematic Pattern</strong></span><a class="headerlink" href="#exists-intro-alt-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>…
X. [E1/x1]…[EK/xK]P{x}                       …
…
Z. ∃x1,…,xN P{x}                             ∀e X E1 … EK    // K &lt;= N, N &gt; 1 (otherwise the previous applies)
</pre></div>
</div>
</div>
<div class="literal-block-wrapper container" id="exists-intro-alt2-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>Alternative+1 Exists-Introduction (∃i) Schematic Pattern</strong></span><a class="headerlink" href="#exists-intro-alt2-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>…
X. [E1/x1]…[EJ/xJ]P{x}                       …
…
Z. ∃x1,…,xK ∃x(K+1),…,xN P{x}                ∀e X E1 … EJ    // 0 &lt; K &lt; J &lt;= N
</pre></div>
</div>
</div>
</div>
<div class="section" id="exists-elimination-e">
<span id="exists-elim"></span><h3>3.3.3.4. Exists-Elimination (∃e)<a class="headerlink" href="#exists-elimination-e" title="Permalink to this headline">¶</a></h3>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="c">// …</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∃e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">sNUM</span><span class="w">            </span><span class="c">// Exists-Elimination</span><span class="w"></span>
</pre></div>
</div>
<div class="literal-block-wrapper container" id="exists-elim-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>Exists-Elimination (∃e) Schematic Pattern</strong></span><a class="headerlink" href="#exists-elim-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>…
X. ∃x P{x}
…
Y. {
     X1. a  P{a}                                             // variable  a  has to be fresh
     …
     XK. Q                                   …
     …
   }
…
Z. Q                                         ∃e X Y          // P{x} ≡ [x/a]P{a}
</pre></div>
</div>
</div>
<div class="literal-block-wrapper container" id="exists-elim-alt-pattern">
<div class="code-block-caption"><span class="caption-text"><strong>Alternative Exists-Elimination (∃e) Schematic Pattern</strong></span><a class="headerlink" href="#exists-elim-alt-pattern" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre>…
X. ∃x,y1,…,yN P{x}                                           // N &gt; 0 (otherwise the previous applies)
…
Y. {
     X1. a  ∃y1,…,yN P{a}                                    // variable  a  has to be fresh
     …
     XK. Q                                   …
     …
   }
…
Z. Q                                         ∃e X Y          // P{x} ≡ [x/a]P{a}
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="predicate-logic-input-language-grammar">
<span id="pred-grammar"></span><h2>3.3.4. Predicate Logic Input Language Grammar<a class="headerlink" href="#predicate-logic-input-language-grammar" title="Permalink to this headline">¶</a></h2>
<p>Note that extended language elements that are not
in the <a class="reference internal" href="../propositional/index.html#prop-grammar"><span>Propositional Logic Input Language Grammar</span></a> are highlighted.</p>
<div class="highlight-antlr"><div class="highlight"><pre><span class="hll"><span class="nl">predicate</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="nv">sequent</span><span class="w"> </span><span class="nv">proof</span><span class="w">              </span><span class="c">// newlines are treated as whitespaces until start of proof</span><span class="w"></span>
</span>
<span class="nv">sequent</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="nv">claimList</span><span class="o">?</span><span class="w">                 </span><span class="c">// premises</span><span class="w"></span>
<span class="w">              </span><span class="s">&#39;⊢&#39;</span><span class="w">                        </span><span class="c">// turnstile (&quot;turn-the-style&quot;), can also use &#39;|-&#39; for &#39;⊢&#39;</span><span class="w"></span>
<span class="w">              </span><span class="nv">claimList</span><span class="w">                  </span><span class="c">// conclusions</span><span class="w"></span>

<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">claim</span><span class="o">*</span><span class="w">                     </span><span class="c">// premises</span><span class="w"></span>
<span class="w">              </span><span class="no">HLINE</span><span class="w">                      </span><span class="c">// HLINE is three or more dashes &#39;-&#39;</span><span class="w"></span>
<span class="w">              </span><span class="nv">claim</span><span class="o">+</span><span class="w">                     </span><span class="c">// conclusions</span><span class="w"></span>

<span class="nv">claimList</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="s">&#39;,&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="o">)*</span><span class="w"></span>

<span class="nv">proof</span><span class="w">       </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;{&#39;</span><span class="w"></span>
<span class="w">                </span><span class="nv">proofStep</span><span class="o">+</span><span class="w">               </span><span class="c">// separated by newline(s)</span><span class="w"></span>
<span class="w">              </span><span class="s">&#39;}&#39;</span><span class="w"></span>

<span class="nv">proofStep</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="nv">regularStep</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">subProof</span><span class="w"></span>

<span class="nv">regularStep</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">rNUM</span><span class="w"> </span><span class="s">&#39;.&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="nv">just</span><span class="w">        </span><span class="c">// rNUM is NUM, distinguished for readability of just arguments later</span><span class="w"></span>

<span class="nv">subProof</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="nv">sNUM</span><span class="w"> </span><span class="s">&#39;.&#39;</span><span class="w">                   </span><span class="c">// sNUM is NUM, distinguished for readability of just arguments later</span><span class="w"></span>
<span class="w">              </span><span class="s">&#39;{&#39;</span><span class="w"></span>
<span class="w">                </span><span class="nv">assumeStep</span><span class="w">               </span><span class="c">// separated by newline(s)</span><span class="w"></span>
<span class="w">                </span><span class="nv">proofStep</span><span class="o">*</span><span class="w">               </span><span class="c">// separated by newline(s)</span><span class="w"></span>
<span class="w">              </span><span class="s">&#39;}&#39;</span><span class="w"></span>

<span class="nv">assumeStep</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="nv">rNUM</span><span class="w"> </span><span class="s">&#39;.&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;assume&#39;</span><span class="w"></span>
<span class="hll"><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">rNUM</span><span class="w"> </span><span class="s">&#39;.&#39;</span><span class="w"> </span><span class="no">ID</span><span class="w">                </span><span class="c">// ID must be &quot;fresh&quot; in scope; used for ForAll-Introduction</span><span class="w"></span>
</span><span class="hll"><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">rNUM</span><span class="w"> </span><span class="s">&#39;.&#39;</span><span class="w"> </span><span class="no">ID</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;assume&#39;</span><span class="w"> </span><span class="c">// ID must be &quot;fresh&quot;; used for Exists-Elimination</span><span class="w"></span>
</span>
<span class="nv">claim</span><span class="w">       </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;⊤&#39;</span><span class="w">                        </span><span class="c">// true literal, can also use &#39;T&#39; or &#39;true&#39; for &#39;⊤&#39;            (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;⊥&#39;</span><span class="w">                        </span><span class="c">// false literal, can also use &#39;F&#39;, &#39;false&#39;, or &#39;_|_&#39; for &#39;⊥&#39;  (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="no">ID</span><span class="w">                         </span><span class="c">// identifier</span><span class="w"></span>
<span class="hll"><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="no">ID</span><span class="w"> </span><span class="s">&#39;(&#39;</span><span class="w"> </span><span class="nv">claimList</span><span class="o">?</span><span class="w"> </span><span class="s">&#39;)&#39;</span><span class="w">      </span><span class="c">// predicate application</span><span class="w"></span>
</span><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;(&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;)&#39;</span><span class="w">              </span><span class="c">// parenthesized claim expression</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;¬&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w">                  </span><span class="c">// negation, can also use &#39;not&#39;, &#39;!&#39;, or &#39;~&#39; for &#39;¬&#39;            (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;∧&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w">            </span><span class="c">// conjunction/and, can also use &#39;&amp;&#39;, &#39;and&#39;, or &#39;^&#39; for &#39;∧&#39;     (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;∨&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w">            </span><span class="c">// disjunction/or, can also use &#39;|&#39;, &#39;or&#39;, or &#39;V&#39; for &#39;∨&#39;       (also apply in just)</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">claim</span><span class="w"> </span><span class="s">&#39;→&#39;</span><span class="w"> </span><span class="nv">claim</span><span class="w">            </span><span class="c">// implication, can also use &#39;-&gt;&#39; or &#39;implies&#39; for &#39;→&#39;          (also apply in just)</span><span class="w"></span>
<span class="hll"><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="s">&#39;∀&#39;</span><span class="w">                      </span><span class="c">// univ. quant., can also use &#39;forall&#39;, &#39;all&#39;, &#39;A&#39; for &#39;∀&#39;      (also apply in just)</span><span class="w"></span>
</span><span class="hll"><span class="w">              </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∃&#39;</span><span class="w">                      </span><span class="c">// exist. quant., can also use &#39;exists&#39;, &#39;some&#39;, &#39;E&#39; for &#39;∃&#39;    (also apply in just)</span><span class="w"></span>
</span><span class="hll"><span class="w">              </span><span class="o">)</span><span class="w"> </span><span class="no">ID</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="s">&#39;,&#39;</span><span class="w"> </span><span class="no">ID</span><span class="o">)*</span><span class="w"> </span><span class="nv">claim</span><span class="w"></span>
</span>
<span class="nv">just</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;premise&#39;</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∧i&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">            </span><span class="c">// And-Introduction</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∧e1&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// And-Elimination1</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∧e2&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// And-Elimination2</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∨i1&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// Or-Introduction1</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∨i2&#39;</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// Or-Introduction2</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∨e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">sNUM</span><span class="w"> </span><span class="nv">sNUM</span><span class="w">       </span><span class="c">// Or-Elimination</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;→i&#39;</span><span class="w">  </span><span class="nv">sNUM</span><span class="w">                 </span><span class="c">// Implication-Introduction</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;→e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">            </span><span class="c">// Implication-Elimination</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;¬i&#39;</span><span class="w">  </span><span class="nv">sNUM</span><span class="w">                 </span><span class="c">// Negation-Introduction</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;¬e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">rNUM</span><span class="w">            </span><span class="c">// Negation-Elimination</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;⊥e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w">                 </span><span class="c">// ⊥-Elimination</span><span class="w"></span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;Pbc&#39;</span><span class="w"> </span><span class="nv">sNUM</span><span class="w">                 </span><span class="c">// Proof-by-Contradiction</span><span class="w"></span>
<span class="hll"><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∀i&#39;</span><span class="w">  </span><span class="nv">sNUM</span><span class="w">                 </span><span class="c">// Forall-Introduction</span><span class="w"></span>
</span><span class="hll"><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∀e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">claim</span><span class="o">+</span><span class="w">          </span><span class="c">// Forall-Elimination</span><span class="w"></span>
</span><span class="hll"><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∃i&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">claim</span><span class="o">+</span><span class="w">          </span><span class="c">// Exists-Introduction</span><span class="w"></span>
</span><span class="hll"><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;∃e&#39;</span><span class="w">  </span><span class="nv">rNUM</span><span class="w"> </span><span class="nv">sNUM</span><span class="w">            </span><span class="c">// Exists-Elimination</span><span class="w"></span>
</span></pre></div>
</div>
</div>
</div>


    </div>
      
  </div>
</div>

  </body>
</html>