
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>4. Programming Logic for Assignments and Conditionals &mdash; Sireum Logika</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootswatch-3.3.4/journal/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sireum.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.4/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/logika.ico"/>
    <link rel="top" title="Sireum Logika" href="../index.html" />
    <link rel="up" title="Logika: Programming Logics" href="../notes.html" />
    <link rel="next" title="5. Functions and Procedures" href="../05-functions-procedures/index.html" />
    <link rel="prev" title="3. Circuits that Compute on Numbers: Algebra" href="../03-algebra/index.html" />
  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          Logika</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../doc.html">Documentation</a></li>
                <li><a href="../notes.html">Course Notes</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html"> <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#"> <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">4. Programming Logic for Assignments and Conditionals</a><ul>
<li><a class="reference internal" href="#assignment">4.1. Assignment</a><ul>
<li><a class="reference internal" href="#law-for-assignment-forwards-reasoning">4.1.1. Law for Assignment: Forwards Reasoning</a></li>
<li><a class="reference internal" href="#invariant-properties">4.1.2. Invariant Properties</a><ul>
<li><a class="reference internal" href="#properties-stated-in-terms-of-initial-input-values">Properties Stated in Terms of Initial Input Values</a></li>
<li><a class="reference internal" href="#mechanical-decidability-of-properties-of-assignment-code">Mechanical Decidability of Properties of Assignment Code</a></li>
</ul>
</li>
<li><a class="reference internal" href="#optional-section-the-backwards-law-for-assignment-and-goal-directed-reasoning">4.1.3. Optional Section: The Backwards Law for Assignment and Goal-Directed Reasoning</a></li>
</ul>
</li>
<li><a class="reference internal" href="#conditional-commands">4.2. Conditional Commands</a><ul>
<li><a class="reference internal" href="#optional-section-the-backwards-law-for-conditional-commands">4.2.1. Optional Section: The Backwards Law for Conditional Commands</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary">4.3. Summary</a><ul>
<li><a class="reference internal" href="#forwards-assignment-law">4.3.1. Forwards Assignment Law</a></li>
<li><a class="reference internal" href="#backwards-assignment-law">4.3.2. Backwards Assignment Law</a></li>
<li><a class="reference internal" href="#forwards-conditional-law">4.3.3. Forwards Conditional Law</a></li>
<li><a class="reference internal" href="#backwards-conditional-law">4.3.4. Backwards Conditional Law</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <br/>
<font color="darkgray">
<big><big><b>
Logika: Programming Logics
</b></big></big>
</font>
<br/>
<font color="black">
<big><big><big><big><b>
Programming Logic for Assignments and Conditionals
</b></big></big></big></big>
</font><div class="section" id="programming-logic-for-assignments-and-conditionals">
<span id="programming-logic"></span><h1>4. Programming Logic for Assignments and Conditionals<a class="headerlink" href="#programming-logic-for-assignments-and-conditionals" title="Permalink to this headline">¶</a></h1>
<p>The examples at the end of the previous chapter showed that assignment in
computer language is different from equality in algebra &#8211; in algebra,
<code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> is a self-contradiction, whereas in computer language,
it is a new assertion, <em>cancelling a previously known one</em>.
In this chapter, we make precise the semantics of assignment for the knowledge
that travels through a computer program.</p>
<div class="section" id="assignment">
<h2>4.1. Assignment<a class="headerlink" href="#assignment" title="Permalink to this headline">¶</a></h2>
<p>From the previous chapter, we know how to apply forwards-reasoning techniques to
single-assignment programs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">hours</span> <span class="o">=</span> <span class="mi">4</span>
<span class="sd">&quot;&quot;&quot;{ 1.  hours == 4          premise (generated by the assignment)  }&quot;&quot;&quot;</span>
<span class="n">minutes</span> <span class="o">=</span> <span class="n">hours</span> <span class="o">*</span> <span class="mi">60</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1.  hours == 4             premise  (the last-stated fact, unaltered)</span>
<span class="sd">  2.  minutes == hours * 60  premise   (the fact generated by the assignment)</span>
<span class="sd">  3.  minutes == 240         algebra 1 2 }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c"># here, we know that  minutes == 240</span>
<span class="k">print</span> <span class="n">hours</span><span class="p">,</span> <span class="n">minutes</span>
</pre></div>
</div>
<p>From now on, we enclose our logical and algebraic reasoning steps in set braces
to distinguish it from the text of the program.
We will number each reasoning step;
<em>premises</em> are facts that are generated by the assignment command or the
last-established fact prior to the assignment.
In Line 3 of the above example, <em>algebra</em>, like that in the previous chapter,
was applied to the facts in Lines 1 and 2 to deduce the result.
A fact is also called an <em>assertion</em>.</p>
<p>Since we use both assignments and equations, we use <code class="docutils literal"><span class="pre">==</span></code> to denote algebraic
equality.</p>
<p>In languages like C and Python, a programmer can insert <code class="docutils literal"><span class="pre">assert</span></code> commands into
the program script to <em>force</em> that a logical property holds true during the
execution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">hours</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s">&quot;Type an int &gt; 2: &quot;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">hours</span> <span class="o">&gt;</span> <span class="mi">2</span>
<span class="c"># execution reaches here _only if_ the value assigned to hours is &gt; 2</span>
<span class="n">minutes</span> <span class="o">=</span> <span class="n">hours</span> <span class="o">*</span> <span class="mi">60</span>
<span class="c"># here, we know that minutes &gt; 120</span>
<span class="k">print</span> <span class="n">hours</span><span class="p">,</span> <span class="n">minutes</span>
</pre></div>
</div>
<p>(Note: Our programming examples will be coded in Python.
This helper function will be used a lot, and we take it for granted:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">readInt</span><span class="p">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">&quot;Type an int: &quot;</span><span class="p">)</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;readInt is a helper function that reads an int from the display.</span>
<span class="sd">       parameter: message - a string, the input prompt; default is &#39;Type an int:&#39;</span>
<span class="sd">       returns an int, typed by the user&quot;&quot;&quot;</span>
    <span class="n">needInput</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">while</span> <span class="n">needInput</span> <span class="p">:</span>
        <span class="n">text</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">text</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="p">:</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="n">needInput</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="n">answer</span>
</pre></div>
</div>
<p>When the computer executes the program, it checks that the integer assigned to
<code class="docutils literal"><span class="pre">hours</span></code> is indeed greater than 2.
If it is, execution proceeds; if it is not, the computer halts the program with
an <em>assert exception</em> (a.k.a., assertion violation).
We can use <code class="docutils literal"><span class="pre">assert</span></code> in our analysis:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">hours</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">(</span><span class="s">&quot;Type an int &gt; 2: &quot;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">hours</span> <span class="o">&gt;</span> <span class="mi">2</span>
<span class="sd">&quot;&quot;&quot;{ 1. hours &gt; 2            premise (fact generated from the assert) }&quot;&quot;&quot;</span>
<span class="n">minutes</span> <span class="o">=</span> <span class="n">hours</span> <span class="o">*</span> <span class="mi">60</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1.  hours &gt; 2              premise</span>
<span class="sd">  2.  minutes == hours * 60  premise</span>
<span class="sd">  3.  minutes &gt; 120          algebra 1 2 }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c"># THE GOAL,   minutes &gt; 120,  IS SATISFIED</span>
<span class="k">print</span> <span class="n">hours</span><span class="p">,</span> <span class="n">minutes</span>
</pre></div>
</div>
<p>As noted at the end of the previous chapter, when we violate single assignment,
our reasoning goes wrong. Consider:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">hours</span> <span class="o">=</span> <span class="mi">4</span>
<span class="sd">&quot;&quot;&quot;{ 1.  hours == 4           premise  }&quot;&quot;&quot;</span>
<span class="n">minutes</span> <span class="o">=</span> <span class="n">hours</span> <span class="o">*</span> <span class="mi">60</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1.  hours == 4              premise</span>
<span class="sd">  2.  minutes == hours * 60   premise }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">hours</span> <span class="o">=</span> <span class="mi">5</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1.  hours == 5              premise</span>
<span class="sd">  2.  minutes == hours * 60 ???  (NO --- this fact is corrupted) }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>A first modification of our reasoning for an assignment, <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">e</span></code>, says that
we must cancel all facts that mention the old value of <code class="docutils literal"><span class="pre">x</span></code>.
For the example, we might deduce:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">hours</span> <span class="o">=</span> <span class="mi">4</span>
<span class="sd">&quot;&quot;&quot;{ 1.  hours == 4          premise }&quot;&quot;&quot;</span>
<span class="n">minutes</span> <span class="o">=</span> <span class="n">hours</span> <span class="o">*</span> <span class="mi">60</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. hours == 4              premise</span>
<span class="sd">  2.  minutes == hours * 60  premise</span>
<span class="sd">  3.  minutes == 240         algebra 1 2 }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">hours</span> <span class="o">=</span> <span class="mi">5</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1.  hours == 5             premise</span>
<span class="sd">  2.  minutes == 240         premise }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>But this isn&#8217;t good enough. Consider:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">assert</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="sd">&quot;&quot;&quot;{ 1. x &gt; 0                premise  }&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. x == x + 1              ??  No.</span>
<span class="sd">  We want to prove that  x &gt; 1.  How? }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="section" id="law-for-assignment-forwards-reasoning">
<h3>4.1.1. Law for Assignment: Forwards Reasoning<a class="headerlink" href="#law-for-assignment-forwards-reasoning" title="Permalink to this headline">¶</a></h3>
<p>In the assignment, <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code>, we must distinguish between the &#8220;old&#8221; value of
<code class="docutils literal"><span class="pre">x</span></code>, which appears on the assignment&#8217;s right-hand side, and its &#8220;new&#8221; value,
which appears on its left-hand side.
With this distinction, we can reason correctly about <code class="docutils literal"><span class="pre">x</span></code>.
Here is the example repeated, with the distinction made clear:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">assert</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="sd">&quot;&quot;&quot;{ 1.  x &gt; 0         premise }&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. x_old &gt; 0         premise    (from the previously established fact)</span>
<span class="sd">  2. x == x_old + 1    premise    (from the assignment)</span>
<span class="sd">  3. x_old == x - 1    algebra 2</span>
<span class="sd">  4. x - 1 &gt; 0         subst 3 1  (we substitute the equality stated in Line 3 into Line 1)</span>
<span class="sd">  5. x &gt; 1             algebra 4  (this last line, which must not mention  x_old,</span>
<span class="sd">                                   can be carried forwards as a premise to subsequent commands) }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c"># WE&#39;VE PROVED THAT  x &gt; 1</span>
</pre></div>
</div>
<p>When we have an assertion, <code class="docutils literal"><span class="pre">P</span></code>, that holds true just before an assignment,
<code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">e</span></code>, we calculate the assertions after the assignment, in two stages:</p>
<ol class="arabic simple">
<li>We assert that <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">[x_old/x]e</span></code> and also <code class="docutils literal"><span class="pre">[x_old/x]P</span></code>.
The notation, <code class="docutils literal"><span class="pre">[x_old/x]E</span></code>, means that we substitute (replace) all
occurrences of <code class="docutils literal"><span class="pre">x</span></code> within expression <code class="docutils literal"><span class="pre">E</span></code> by <code class="docutils literal"><span class="pre">x_old</span></code>.</li>
<li>We next apply deductions, giving us a new assertion, <code class="docutils literal"><span class="pre">Q</span></code>, that does not
mention <code class="docutils literal"><span class="pre">x_old</span></code>.
This assertion can be carried forwards as a premise for future deduction.</li>
</ol>
<p>This is what we did in the earlier example &#8211; we deduced <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, which we can
carry forwards.
We then forget all the assertions that mentioned <code class="docutils literal"><span class="pre">x_old</span></code>.</p>
<p>The rule&#8217;s schematic looks likes this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ ...</span>
<span class="sd">  m. P }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">e</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. x == [x_old/x]e      premise</span>
<span class="sd">  2. [x_old/x]P           premise</span>
<span class="sd">  ...</span>
<span class="sd">  n. Q                    (where  Q  must _not_ mention  x_old) }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Here is a second example that shows the form of reasoning we follow when working
with assignments.
Say that <code class="docutils literal"><span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">x</span></code> at the outset, and we wish to preserve this property as the
computation progresses.
We can prove it with algebra:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">()</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">x</span>
<span class="sd">&quot;&quot;&quot;{ 1.  y &gt; x         premise }&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1.  y &gt; x_old        premise</span>
<span class="sd">  2.  x == x_old - 1   premise</span>
<span class="sd">  3.  x_old == x + 1   algebra 2    # This line abbreviates multiple small steps.</span>
<span class="sd">  4.  y &gt; x + 1        subst 3 1    # Substitute the equality on line 3 into the formula on line 1.</span>
<span class="sd">  5.  y &gt; x            algebra 4    # There is no mention of  x_old }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. y_old &gt; x         premise</span>
<span class="sd">  2. y == y_old + 1    premise</span>
<span class="sd">  3. y &gt; x             algebra 1 2  # This line abbreviates these steps:</span>
<span class="sd">                                    #   y_old == y - 1</span>
<span class="sd">                                    #   y - 1 &gt; x</span>
<span class="sd">                                    #   y &gt; x + 1 }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>After each command, a proof segment begins with the premises and then <em>subst</em>
and <em>algebra</em> steps lead to the last line, which states the knowledge that
travels forwards to the next command.
We must ensure that no &#8220;old&#8221; variables appear in the last line.</p>
<p>Here is a third example, where we wish to show that the value within variable
<code class="docutils literal"><span class="pre">x</span></code> falls in a certain range (perhaps <code class="docutils literal"><span class="pre">x</span></code> is used as an index to an array):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">()</span>
<span class="c"># the precondition is that int  x  falls in the range, 1,2,...,99</span>
<span class="k">assert</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">^</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">100</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. x_old &gt; 0  ^  x_old &lt; 100     premise</span>
<span class="sd">  2. x_old &gt; 0                     ^e 1</span>
<span class="sd">  3. x == x_old + 1                premise</span>
<span class="sd">  4. x_old + 1 &gt; 1                 algebra 1</span>
<span class="sd">  5. x &gt; 1                         subst 3 4</span>
<span class="sd">  6. x_old &lt; 100                   ^e 1</span>
<span class="sd">  7. x &lt; 101                       algebra 3 6</span>
<span class="sd">  8. x &gt; 1 ^ x &lt; 101               ^i 5 7 }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c"># the postcondition is that  x  falls in the range,  2,3,...,100</span>
<span class="k">print</span> <span class="n">x</span>
</pre></div>
</div>
<p>The starting assertion about <code class="docutils literal"><span class="pre">x</span></code> is sometimes called a <em>precondition</em>, because
it is the input property that the program requires to operate successfully.
The goal of the program is its <em>postcondition</em>.
The example uses new deduction laws that let us combine together and pull apart
assertions connected by <code class="docutils literal"><span class="pre">^</span></code> (&#8220;and&#8221;).
There is also an explicit use of substitution (<code class="docutils literal"><span class="pre">subst</span></code>), where the equality
substituted and the formula substituted into are both listed as line numbers.</p>
<p>Because our deductions often consist of multiple steps, it is convenient to use
the <code class="docutils literal"><span class="pre">^i</span></code> law (&#8220;and-introduction&#8221;) to collect together the facts we wish to
carry forwards as premises for future use &#8211; from here on, we will carry
forwards only the <em>last line</em> of a proof as the premise for future use.
If we want to carry forwards multiple facts, we connect them together with
<code class="docutils literal"><span class="pre">^i</span></code>.
Later, we use <code class="docutils literal"><span class="pre">^e</span></code> (&#8220;and-elimination&#8221;) to extract the facts as needed.</p>
</div>
<div class="section" id="invariant-properties">
<h3>4.1.2. Invariant Properties<a class="headerlink" href="#invariant-properties" title="Permalink to this headline">¶</a></h3>
<p>Real-time controller software maintains <em>invariant properties</em> on the variables
it manipulates.
Here is a simplistic example: perhaps we build an electronic piggy bank, which
displays the value of the dimes inserted into it.
The bank&#8217;s controller software must maintain the relationship between the
quantity of dimes inserted in the bank and the dimes&#8217; monetary value:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># the _invariant property_ is that  money == dimes * 10 :</span>
<span class="k">assert</span> <span class="n">money</span> <span class="o">==</span> <span class="n">dimes</span> <span class="o">*</span> <span class="mi">10</span>
<span class="sd">&quot;&quot;&quot;{ 1. money == dimes * 10    premise  }&quot;&quot;&quot;</span>
<span class="c"># Say that one more dime is inserted into the bank:</span>
<span class="n">dimes</span> <span class="o">=</span> <span class="n">dimes</span> <span class="o">+</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. dimes == dimes_old + 1            premise</span>
<span class="sd">  2. money == dimes_old * 10           premise</span>
<span class="sd">  3. dimes_old == dimes - 1            algebra 1</span>
<span class="sd">  4. money == (dimes - 1) * 10         subst 3 2    # we use Lines 1 and 2 to eliminate  dimes_old  from the knowledge we have }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c"># The amount of money is less that what it should be; we fix this:</span>
<span class="n">money</span> <span class="o">=</span> <span class="n">money</span> <span class="o">+</span> <span class="mi">10</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. money_old == (dimes - 1) * 10     premise</span>
<span class="sd">  2. money == money_old + 10           premise</span>
<span class="sd">  3. money_old == money - 10           algebra 2</span>
<span class="sd">  4. money - 10 == (dimes - 1) * 10    subst 3 1</span>
<span class="sd">  5. money == dimes * 10               algebra 4 }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c"># The invariant property is restored:  money == dimes * 10</span>
<span class="k">print</span> <span class="n">dimes</span><span class="p">,</span> <span class="n">money</span>
</pre></div>
</div>
<p>The proof explains why we wrote the assignments that we did &#8211; we wanted to
maintain the logical property that <code class="docutils literal"><span class="pre">money</span> <span class="pre">==</span> <span class="pre">dimes</span> <span class="pre">*</span> <span class="pre">10</span></code>.</p>
<p>The above software is embedded in a chip within the piggy bank: when the child
inserts a dime, this activates the above code, which resets <code class="docutils literal"><span class="pre">dimes</span></code> and
<code class="docutils literal"><span class="pre">money</span></code> so that the invariant property is always holding true.
Then, when the values of <code class="docutils literal"><span class="pre">dimes</span></code> and <code class="docutils literal"><span class="pre">money</span></code> are displayed on the LED on the
side of the bank, their relationship, as stated by the invariant property, is
maintained.</p>
<p>Invariant properties are central to the development of real-time software, which
iteratively monitors the values of input sensors and adjusts program variables
so that invariants are maintained.
This is the crucial concept within flight-control software, which uses inputs
from a plane&#8217;s sensors to adjust rudders, joystick, and fuel intake so that
a plane flies stably and on course.</p>
<p>The form of reasoning (invariant maintenance) just seen occurs automatically and
unconsciously in seasoned programmers all the time, every time assignments are
written.
It plays a crucial role in object-oriented programming, where an object holds
private variables and methods that maintain invariant properties of the private
variables.</p>
<div class="section" id="properties-stated-in-terms-of-initial-input-values">
<h4>Properties Stated in Terms of Initial Input Values<a class="headerlink" href="#properties-stated-in-terms-of-initial-input-values" title="Permalink to this headline">¶</a></h4>
<p>Sometimes we really must discuss the &#8220;old&#8221; value of a variable after an
assignment completes.
Here is a small but tricky program that swaps the values of the its two
variables, <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">()</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">()</span>
<span class="n">temp</span> <span class="o">=</span> <span class="n">x</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">temp</span>
<span class="k">print</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<p>At the end of the program, we want to assert that <code class="docutils literal"><span class="pre">y</span></code> has <code class="docutils literal"><span class="pre">x</span></code>&#8216;s value and
<code class="docutils literal"><span class="pre">x</span></code> has <code class="docutils literal"><span class="pre">y</span></code>&#8216;s.
To do this, we may invent dummy constants called <code class="docutils literal"><span class="pre">x_in</span></code> and <code class="docutils literal"><span class="pre">y_in</span></code> and
pretend they are the input values to <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> respectively:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">()</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">()</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. x == x_in                                      premise</span>
<span class="sd">  2. y == y_in                                      premise</span>
<span class="sd">  3. x == x_in  ^  y == y_in                        ^i 1 2 }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">temp</span> <span class="o">=</span> <span class="n">x</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1.  temp == x                                     premise</span>
<span class="sd">  2.  x == x_in  ^  y == y_in                       premise</span>
<span class="sd">  3.  temp == x_in  ^  x == x_in  ^  y == y_in      ^i 1 2 }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. x == y                                         premise</span>
<span class="sd">  2. temp == x_in  ^   x_old == x_in  ^  y == y_in  premise</span>
<span class="sd">  3. y == y_in                                      ^e 2</span>
<span class="sd">  4. x == y_in                                      subst 3 1</span>
<span class="sd">  5. temp == x_in  ^  y == y_in                     ^e 2</span>
<span class="sd">  6. x == y_in ^ temp == x_in ^ y == y_in           ^i 4 5 }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">temp</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. y = temp                                       premise</span>
<span class="sd">  2. x = y_in ^ temp = x_in ^ y_old = y_in          premise</span>
<span class="sd">     . . . (you fill in the steps) . . .</span>
<span class="sd">  4. y = x_in  ^  x = y_in }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c"># We&#39;ve proved that  x  and  y  swapped their original values.</span>
<span class="k">print</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<p>The dummy values <code class="docutils literal"><span class="pre">x_in</span></code> and <code class="docutils literal"><span class="pre">y_in</span></code> plus the assignment law navigate us
through the deduction.</p>
</div>
<div class="section" id="mechanical-decidability-of-properties-of-assignment-code">
<h4>Mechanical Decidability of Properties of Assignment Code<a class="headerlink" href="#mechanical-decidability-of-properties-of-assignment-code" title="Permalink to this headline">¶</a></h4>
<p>After several examples, we are tempted to conclude that deducing forwards
knowledge is a mechanical activity, where we do an assignment and then eliminate
occurrences of the &#8220;old&#8221; variable, like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;{ P }&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">e</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1.  [x_old/x]P        premise</span>
<span class="sd">  2. x == [x_old/x]e    premise</span>

<span class="sd">  # solve for  x_old  in terms of  x  and  e :</span>
<span class="sd">  3. x_old = ...x...    algebra 2</span>

<span class="sd">  # eliminate  x_old  in Line 1 :</span>
<span class="sd">  4. [...x.../x]P       subst 3 1</span>
<span class="sd">}&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>We can apply this pattern to an earlier example &#8211; it works!</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">^</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">100</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. x_old &gt; 0  ^  x_old &lt; 100     premise</span>
<span class="sd">  2. x == x_old + 1                premise</span>
<span class="sd">  #  Solve for  x_old :</span>
<span class="sd">  3. x_old == x - 1                algebra 2</span>
<span class="sd">  #  Eliminate  x_old:</span>
<span class="sd">  4. x - 1 &gt; 0  ^  x - 1 &lt; 100     subst 3 1</span>
<span class="sd">}</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="k">print</span> <span class="n">x</span>
</pre></div>
</div>
<p>One step of algebra gives us the desired goal that <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> and <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">101</span></code>.</p>
<p>Here is the piggy-bank example, which also works in this style:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">assert</span> <span class="n">money</span> <span class="o">==</span> <span class="n">dimes</span> <span class="o">*</span> <span class="mi">10</span>
<span class="sd">&quot;&quot;&quot;{ 1. money == dimes * 10            premise  }&quot;&quot;&quot;</span>
<span class="n">dimes</span> <span class="o">=</span> <span class="n">dimes</span> <span class="o">+</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. dimes == dimes_old + 1            premise</span>
<span class="sd">  2. money == dimes_old * 10           premise</span>
<span class="sd">  3. dimes_old == dimes - 1            algebra 1    # Solve for  dimes_old</span>
<span class="sd">  4. money == (dimes - 1) * 10         subst 3 2    # Eliminate  dimes_old }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">money</span> <span class="o">=</span> <span class="n">money</span> <span class="o">+</span> <span class="mi">10</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. money_old == (dimes - 1) * 10     premise</span>
<span class="sd">  2. money == money_old + 10           premise</span>
<span class="sd">  3. money_old == money - 10           algebra 2    # Solve for  money_old</span>
<span class="sd">  4. money - 10 == (dimes - 1) * 10    subst 3 1    # Eliminate  money_old</span>
<span class="sd">  5. money == dimes * 10               algebra 4 }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c"># reprove the invariant,   money == dimes * 10</span>
<span class="k">print</span> <span class="n">dimes</span><span class="p">,</span> <span class="n">money</span>
</pre></div>
</div>
<p>Will the variable-elimination technique always lead us to the final goal?
If so, perhaps we can write a proof generator that will automatically write the
proofs for us!</p>
<p>Unfortunately, the answer here is &#8220;no&#8221;.
The reason is that important intermediate knowledge can be lost, and here is
a simple example that shows how:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
<span class="sd">&quot;&quot;&quot;{ 1. y == x * 2        premise  }&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. y == x_old * 2       premise</span>
<span class="sd">  2. x == 3               premise</span>
<span class="sd">  3. x_old == y / 2       algebra 1   # Solve for  x_old</span>
<span class="sd">  #  We cannot eliminate  x_old  from  Line 2 ?!</span>
<span class="sd">  #  The knowledge that travels forwards is only</span>
<span class="sd">  #    x == 3</span>
<span class="sd">  #  We lose knowledge about  y. }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">z</span> <span class="o">=</span> <span class="mi">4</span>
<span class="c"># prove here that  y % 2 == 0,  that is,  y is an even-valued int</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. x == 3               premise</span>
<span class="sd">  2. z == 4               premise</span>
<span class="sd">  # We cannot use   x_old == y / 2  as a premise .... x_old has disappeared.</span>
<span class="sd">  # Lines 1 and 2 cannot prove the goal. }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>A human sees how to repair the above proof &#8211; extract new knowledge about <code class="docutils literal"><span class="pre">y</span></code>
from premise <code class="docutils literal"><span class="pre">y</span> <span class="pre">==</span> <span class="pre">x_old</span> <span class="pre">*</span> <span class="pre">2</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
<span class="sd">&quot;&quot;&quot;{ 1. y == x * 2        premise }&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. y == x_old * 2       premise</span>
<span class="sd">  2. y % 2 == 0           algebra 1   # because  y  is even-valued, even though</span>
<span class="sd">                                      # we don&#39;t know what value it has }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">z</span> <span class="o">=</span> <span class="mi">4</span>
<span class="c"># prove here that  y % 2 == 0,  that is,  y is an even-valued int</span>
<span class="sd">&quot;&quot;&quot;{ 1. y % 2 == 0        premise     # DONE }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>When we analyze a program in a forwards direction, we work together with an
automated checker tool to reach our goal.</p>
</div>
</div>
<div class="section" id="optional-section-the-backwards-law-for-assignment-and-goal-directed-reasoning">
<h3>4.1.3. Optional Section: The Backwards Law for Assignment and Goal-Directed Reasoning<a class="headerlink" href="#optional-section-the-backwards-law-for-assignment-and-goal-directed-reasoning" title="Permalink to this headline">¶</a></h3>
<p>The previous examples raise this question:
When we analyze a program from start to finish, which facts should we try to
deduce and carry forwards after each assignment?
We cannot answer this question unless we know the <em>goal assertion</em> we are trying
to prove at the program&#8217;s end.
For this reason, we should learn how to reason <em>backwards</em> from the goal at the
end of a program to the asserts at the beginning.
This is called <em>goal-directed reasoning</em>, and there is a simple, beautiful
deduction rule for assignments that takes the guesswork out of goal-directed
reasoning.</p>
<p>Here is an example.
Say that at program&#8217;s end, <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">2</span></code> must hold, and the program ends like this:</p>
<div class="highlight-python"><div class="highlight"><pre>  <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
<span class="sd">&quot;&quot;&quot;{ subgoal: ??? }&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;{ goal: x &gt; 2 }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>What is the subgoal needed for success?
It appears that <code class="docutils literal"><span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> must hold just before the assignment.
How did we calculate this?
Since the assignment &#8220;equates&#8221; <code class="docutils literal"><span class="pre">x</span></code> with <code class="docutils literal"><span class="pre">y</span> <span class="pre">+</span> <span class="pre">1</span></code>, it must be <code class="docutils literal"><span class="pre">y</span> <span class="pre">+</span> <span class="pre">1</span></code> that
is greater than 2 &#8211; we <em>substitute</em> <code class="docutils literal"><span class="pre">y</span> <span class="pre">+</span> <span class="pre">1</span></code> into the goal, for <code class="docutils literal"><span class="pre">x</span></code>,
that is, we compute the subgoal as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>  <span class="o">=</span>  <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span>
</pre></div>
</div>
<p>that is, y &gt; 1 is the subgoal:</p>
<div class="highlight-python"><div class="highlight"><pre>  <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
<span class="sd">&quot;&quot;&quot;{ subgoal: y &gt; 1 }&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;{ goal: x &gt; 2 }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>This reasoning is the basis of a &#8220;backwards law&#8221; for assignment commands.</p>
<p>The formal statement of the backwards-assignment law is this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;{ subgoal:  [e/x]G }&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">e</span>
<span class="sd">&quot;&quot;&quot;{ goal: G }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>The goal, <code class="docutils literal"><span class="pre">G</span></code>, is sometimes called the assignment&#8217;s <em>postcondition</em>, and
the subgoal, <code class="docutils literal"><span class="pre">[e/x]G</span></code>, is the <em>precondition</em>.
It is a formal, proved result that every such precondition, postcondition pair
calculated by the backwards-assignment law can be proved as a correct forwards
deduction with the forwards-assignment law.
Let&#8217;s use the backwards assignment law on an example from the previous section.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">^</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">100</span>
<span class="sd">&quot;&quot;&quot;{  ??? }&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;{ x &gt; 1  ^  x &lt; 101    (goal) }&quot;&quot;&quot;</span>
<span class="k">print</span> <span class="n">x</span>
</pre></div>
</div>
<p>The backwards assignment law tells us <code class="docutils literal"><span class="pre">???`</span></code> should be
<code class="docutils literal"><span class="pre">[x</span> <span class="pre">+</span> <span class="pre">1/</span> <span class="pre">x](x</span> <span class="pre">&gt;</span> <span class="pre">1</span> <span class="pre">^</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">101)</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">^</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">100</span>
<span class="sd">&quot;&quot;&quot;{ x + 1 &gt; 1  and  x + 1 &lt; 101  (subgoal) }&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;{ x &gt; 1  ^  x &lt; 101            (goal) }&quot;&quot;&quot;</span>
<span class="k">print</span> <span class="n">x</span>
</pre></div>
</div>
<p>Now, we use algebra to show that the assert proves the subgoal:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">^</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">100</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. x &gt; 0 ^ x &lt; 100                      premise</span>
<span class="sd">  2. x + 1 &gt; 1  and  x + 1 &lt; 101          algebra 1   (subgoal achieved) }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. x_old + 1 &gt; 1  and  x_old + 1 &lt; 101  premise</span>
<span class="sd">  2. x == x_old + 1                       premise</span>
<span class="sd">  3. x &gt; 1  ^  x &lt; 101                    subst 2 1  (goal achived) }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="k">print</span> <span class="n">x</span>
</pre></div>
</div>
<p>The backwards law helps us calculate exactly the correct knowledge at
intermediate program points that will lead to the desired final goal.</p>
<p>This technique works well on programs that are sequences of assignments.
Here are two examples from the previous section, reworked in backwards style:</p>
<div class="highlight-python"><div class="highlight"><pre>assert WHAT??
dimes = dimes + 1
money = money + 10
# GOAL:   money == dimes * 10
print dimes, money
</pre></div>
</div>
<p>We fill in the subgoals one by one:</p>
<div class="highlight-python"><div class="highlight"><pre>assert WHAT??
&quot;&quot;&quot;{ SUBGOAL II:  (money + 10) == (dimes + 1) * 10 }&quot;&quot;&quot;
dimes = dimes + 1
&quot;&quot;&quot;{ SUBGOAL I:  (money + 10) == dimes * 10 }&quot;&quot;&quot;
money = money + 10
# GOAL:   money == dimes * 10
print dimes, money
</pre></div>
</div>
<p>Some algebra simplifies the second subgoal into just <code class="docutils literal"><span class="pre">money</span> <span class="pre">==</span> <span class="pre">dimes</span> <span class="pre">*</span> <span class="pre">10</span></code>,
which must be asserted at the beginning.
Here is a previous problematic example, now neatly handled:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ ENTRY CONDITION:  (x * 2) % 2 == 0  (which must always hold true!),</span>
<span class="sd">             SO,  true   is the entry condition }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
<span class="sd">&quot;&quot;&quot;{ SUBGOAL II:    y % 2 == 0   (x doesn&#39;t matter!) }&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
<span class="sd">&quot;&quot;&quot;{ SUBGOAL I:     y % 2 == 0   (z doesn&#39;t matter!) }&quot;&quot;&quot;</span>
<span class="n">z</span> <span class="o">=</span> <span class="mi">4</span>
<span class="c"># GOAL:             y % 2 == 0,  that is,  y is an even-valued int</span>
</pre></div>
</div>
<p>The backwards technique works even when there is a self-referential assignment:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">assert</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;{ goal: x &gt; 2 }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>We calculate that the subgoal before the assignment must be
<code class="docutils literal"><span class="pre">[x</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">/</span> <span class="pre">x](x</span> <span class="pre">&gt;</span> <span class="pre">2)</span></code>, which is <code class="docutils literal"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">&gt;</span> <span class="pre">2</span></code>.
A small algebra step completes the forwards proof of the backwards deduction:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">assert</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. x &gt; 1            premise</span>
<span class="sd">  2. x + 1 &gt; 2        algebra 1 }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. x = x_old + 1    premise</span>
<span class="sd">  2. x_old + 1 &gt; 2    premise</span>
<span class="sd">  3. x &gt; 2            subst 1 2 }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>By reasoning backwards, we avoid the need to work directly with <code class="docutils literal"><span class="pre">x_old</span></code> &#8211;
the subgoals we calculate by substitution are correctly expressed in terms of
<code class="docutils literal"><span class="pre">x</span></code>.
So, if your program has a clearly stated goal, you <em>can use backwards reasoning
to prove that the goal is achieved</em>.</p>
</div>
</div>
<div class="section" id="conditional-commands">
<h2>4.2. Conditional Commands<a class="headerlink" href="#conditional-commands" title="Permalink to this headline">¶</a></h2>
<p>To deduce the knowledge generated by a conditional (if-else) command, we must
analyze both arms (paths) within the command.
This is because some executions will follow the then-arm and some will follow
the else-arm.
Before we state the rules for forwards and backwards reasoning, we motivate the
key ideas with examples.
This conditional command sets <code class="docutils literal"><span class="pre">max</span></code> to the larger of numbers <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="p">:</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="n">x</span>
<span class="k">else</span> <span class="p">:</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="n">y</span>
</pre></div>
</div>
<p>What can we assert when the command finishes, no matter what the values of <code class="docutils literal"><span class="pre">x</span></code>
and <code class="docutils literal"><span class="pre">y</span></code> might be?
First, when we analyze the then-arm, we have:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">max</span> <span class="o">=</span> <span class="n">x</span>
<span class="sd">&quot;&quot;&quot;{ max == x }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>and when we analyze the else-arm, we have:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">max</span> <span class="o">=</span> <span class="n">y</span>
<span class="sd">&quot;&quot;&quot;{ max == y }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>These two deductions imply that, when the conditional finishes, one or the other
property holds true:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="p">:</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="n">x</span>
<span class="k">else</span> <span class="p">:</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="n">y</span>
<span class="sd">&quot;&quot;&quot;{ max == x  v  max == y }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>This illustrates the first principle of conditional commands:
the knowledge producted by the command is the <em>disjunction</em> (or) of the
knowledge produced by each arm.
Later, we will learn how to apply cases analyses on disjunctive assertions to
extract useful knowledge.</p>
<p>Recall that the intent of the conditional was to set <code class="docutils literal"><span class="pre">max</span></code> so that it holds
the larger of <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code>.
The assertion we proved so far does not imply the desired goal.
This is because we ignored a critical feature of a conditional command:
<em>By asking a question &#8212; the test &#8212; the conditional command generates new
knowledge.</em></p>
<p>For the then arm, we have the new knowledge that <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code>;
for the else-arm, we have that <code class="docutils literal"><span class="pre">~(x</span> <span class="pre">&gt;</span> <span class="pre">y)</span></code>, that is, <code class="docutils literal"><span class="pre">y</span> <span class="pre">&gt;=</span> <span class="pre">x</span></code>.
We can embed these assertions into the analysis of the conditional command,
like this, and conclude that, in both cases, <code class="docutils literal"><span class="pre">max</span></code> holds the maximum of <code class="docutils literal"><span class="pre">x</span></code>
and <code class="docutils literal"><span class="pre">y</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;{ 1. x &gt; y                premise }&quot;&quot;&quot;</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="n">x</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    { 1. x &gt; y                   premise</span>
<span class="sd">      2. max == x                premise</span>
<span class="sd">      3. max &gt;= x                algebra 2</span>
<span class="sd">      4. max &gt;= y                algebra 1 3</span>
<span class="sd">      5. max &gt;= x  ^  max &gt;= y   ^i 3 4 }</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="k">else</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    { 1. ~(x &gt; y)                premise</span>
<span class="sd">      2. y &gt;= x                  algebra 1 }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="n">y</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    { 1. max == y                premise</span>
<span class="sd">      2. y &gt;= x                  premise</span>
<span class="sd">      3. max &gt;= y                algebra 1</span>
<span class="sd">      4. max &gt;= x                algebra 1 2</span>
<span class="sd">      5. max &gt;= x  ^  max &gt;= y   ^i 4 3 }</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;{ 1. max &gt;= x  ^  max &gt;= y    premise (from the if-command) }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Each arm generates the assertion that <code class="docutils literal"><span class="pre">max</span> <span class="pre">&gt;=</span> <span class="pre">x</span> <span class="pre">^</span> <span class="pre">max</span> <span class="pre">&gt;=</span> <span class="pre">y</span></code>.
Now, in both cases of the or-formula, we can conclude merely
<code class="docutils literal"><span class="pre">max</span> <span class="pre">&gt;=</span> <span class="pre">x</span> <span class="pre">^</span> <span class="pre">max</span> <span class="pre">&gt;=</span> <span class="pre">y</span></code>, as listed in the proof&#8217;s last line.</p>
<p>More precisely stated, the proof&#8217;s last line is
<code class="docutils literal"><span class="pre">(max</span> <span class="pre">&gt;=</span> <span class="pre">x</span> <span class="pre">^</span> <span class="pre">max</span> <span class="pre">&gt;=</span> <span class="pre">y)</span> <span class="pre">v</span> <span class="pre">(max</span> <span class="pre">&gt;=</span> <span class="pre">x</span> <span class="pre">^</span> <span class="pre">max</span> <span class="pre">&gt;=</span> <span class="pre">y)</span></code>, but this is exactly the same
as <code class="docutils literal"><span class="pre">max</span> <span class="pre">&gt;=</span> <span class="pre">x</span> <span class="pre">^</span> <span class="pre">max</span> <span class="pre">&gt;=</span> <span class="pre">y</span></code>.</p>
<p>We are not yet finished with this example; the desired goal is truly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">max</span> <span class="o">&gt;=</span> <span class="n">x</span>  <span class="o">^</span>  <span class="nb">max</span> <span class="o">&gt;=</span> <span class="n">y</span>  <span class="o">^</span>  <span class="p">(</span><span class="nb">max</span> <span class="o">==</span> <span class="n">x</span>  <span class="n">v</span>  <span class="nb">max</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>You should build a proof of this goal assertion by combining the two partial
proofs that we have already constructed.</p>
<p>Here is the schematic of the forwards law for conditionals:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;{ ... P }&quot;&quot;&quot;</span>
<span class="k">if</span> <span class="n">B</span> <span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  { 1. B          premise</span>
<span class="sd">    2. P          premise</span>
<span class="sd">    ... }</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">C1</span>
  <span class="sd">&quot;&quot;&quot;{ ... Q1  }&quot;&quot;&quot;</span>
<span class="k">else</span> <span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  { 1. ~B         premise</span>
<span class="sd">    2. P          premise</span>
<span class="sd">    ... }</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">C2</span>
  <span class="sd">&quot;&quot;&quot;{ ... Q2 }&quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;{ 1. Q1 v Q2   premise }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>That is, given the assertion, <code class="docutils literal"><span class="pre">P</span></code>, at the conditional&#8217;s start, the then-arm,
<code class="docutils literal"><span class="pre">C1</span></code> uses <code class="docutils literal"><span class="pre">P</span></code> and <code class="docutils literal"><span class="pre">B</span></code> to generate assertion, <code class="docutils literal"><span class="pre">Q1</span></code>, and the else-arm,
<code class="docutils literal"><span class="pre">C2</span></code>, uses <code class="docutils literal"><span class="pre">P</span></code> and <code class="docutils literal"><span class="pre">~B</span></code> to generate assertion <code class="docutils literal"><span class="pre">Q2</span></code>.
These two conclusions are joined at the conditional&#8217;s conclusion.</p>
<p>When a conditional command lacks an else-arm, e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">x</span>
</pre></div>
</div>
<p>we analyze it with an empty one, e.g., with an else-arm that holds pass:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;{ 1. x &lt; 0            premise  }&quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">x</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    { 1. x == 0 - x_old      premise</span>
<span class="sd">      2. x_old &lt; 0           premise</span>
<span class="sd">      3. x &gt; 0               algebra 1 2 }</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="k">else</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    { 1. ~(x &lt; 0)            premise</span>
<span class="sd">      2. x &gt;= 0              algebra 1 }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
    <span class="sd">&quot;&quot;&quot;{ 1. x &gt;= 0           premise }&quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. (x &gt; 0)  v  (x &gt;= 0)    premise</span>
<span class="sd">  2. x &gt;= 0                  ore 1 }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Here, the conclusion of the if-command is <code class="docutils literal"><span class="pre">(x</span> <span class="pre">&gt;</span> <span class="pre">0)</span> <span class="pre">v</span> <span class="pre">(x</span> <span class="pre">&gt;=</span> <span class="pre">0)</span></code>, but clearly
it is the case that <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> implies <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> (and clearly, the other case,
<code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> implies <code class="docutils literal"><span class="pre">`x</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>, holds), so we conclude at the very last line
that <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>;
the justification is <code class="docutils literal"><span class="pre">ore</span></code> &#8212; <a href="#id1"><span class="problematic" id="id2">``</span></a>or elimination&#8217;&#8217; &#8212; commonly known as
<em>proof by cases</em>.</p>
<div class="section" id="optional-section-the-backwards-law-for-conditional-commands">
<h3>4.2.1. Optional Section: The Backwards Law for Conditional Commands<a class="headerlink" href="#optional-section-the-backwards-law-for-conditional-commands" title="Permalink to this headline">¶</a></h3>
<p>Assertions that are disjunctions are cumbersome to handle, and we should avoid
them when possible.
Given that the forwards law for conditionals generates a disjunction, reflecting
the two possibilities for execution, it is important to learn how to reason
backwards from a goal through the arms of a conditional command.
As usual, we motivate the law through an example.
Using the previously seen program that assigns to <code class="docutils literal"><span class="pre">max</span></code>, perhaps we want to
prove the goal, <code class="docutils literal"><span class="pre">max</span> <span class="pre">&gt;=</span> <span class="pre">x</span> <span class="pre">^</span> <span class="pre">max</span> <span class="pre">&gt;=</span> <span class="pre">y</span></code>.
Our intuition tells us that this goal must be achieved through through both
paths of the conditional command.
That is, there are two subgoals to calculate, one for the then-arm and one for
the else-arm:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;{  subgoal_1 : ??? }&quot;&quot;&quot;</span>
<span class="nb">max</span> <span class="o">=</span> <span class="n">x</span>
<span class="sd">&quot;&quot;&quot;{  goal: max &gt;= x  ^  max &gt;= y }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>and also</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;{  subgoal_2 : ??? }&quot;&quot;&quot;</span>
<span class="nb">max</span> <span class="o">=</span> <span class="n">y</span>
<span class="sd">&quot;&quot;&quot;{  goal: max &gt;= x  ^  max &gt;= y }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Using the backwards assignment law, we calculate the subgoals for the two arms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{  subgoal_1: x &gt;= x  ^  x &gt;= y</span>
<span class="sd">   that is,  x &gt;= y   (since  x &gt;= x  is always true) }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="nb">max</span> <span class="o">=</span> <span class="n">x</span>
<span class="sd">&quot;&quot;&quot;{  goal: max &gt;= x  ^  max &gt;= y }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>and also:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{  subgoal_2: y &gt;= x  ^  y &gt;= y</span>
<span class="sd">   that is,  y &gt;= x   (since  y &gt;= y  is always true) }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="nb">max</span> <span class="o">=</span> <span class="n">y</span>
<span class="sd">&quot;&quot;&quot;{  goal: max &gt;= x  ^  max &gt;= y }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Now, given the extra knowledge that the conditional&#8217;s test is <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code>, we can
apply this knowledge to the subgoals.</p>
<p>First, the then-arm will achieve the final goal if the conditional&#8217;s test
provides enough extra information to achive the subgoal:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>  <span class="o">--&gt;</span>  <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span>
</pre></div>
</div>
<p>The logical operator, <code class="docutils literal"><span class="pre">--&gt;</span></code> (read as &#8220;implies&#8221;), can be read as a
&#8220;logical if-then&#8221;: &#8220;if <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code> is assumed as a fact, then <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">y</span></code> follows
as a consequence&#8221;.
Or, read it as, &#8220;when <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code> holds true, then so must <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">y</span></code>&#8221;.</p>
<p>Similarly, the else-arm will achieve the final goal if the test provides enough
extra information to achive the subgoal:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="o">~</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span>  <span class="o">--&gt;</span>  <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">x</span>
</pre></div>
</div>
<p>Overall, the subgoal for the completed if-command is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>  <span class="o">--&gt;</span>  <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span> <span class="p">)</span>  <span class="o">^</span>  <span class="p">(</span> <span class="o">~</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span>  <span class="o">--&gt;</span>  <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">x</span> <span class="p">)</span>
</pre></div>
</div>
<p>Here is a summary of what we have uncovered:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;{  if&#39;s subgoal: (x &gt; y  --&gt;  x &gt;= y)  ^  (~(x &gt; y)  --&gt;  y &gt;= x) }&quot;&quot;&quot;</span>
<span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>
   <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   {  subgoal_1: x &gt;= x  ^  x &gt;= y</span>
<span class="sd">      that is,  x &gt;= y }</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="nb">max</span> <span class="o">=</span> <span class="n">x</span>
   <span class="sd">&quot;&quot;&quot;{  goal: max &gt;= x  ^  max &gt;= y }&quot;&quot;&quot;</span>
<span class="k">else</span> <span class="p">:</span>
   <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   {  subgoal_2: y &gt;= x  ^  y &gt;= y</span>
<span class="sd">      that is,  y &gt;= x  }</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="nb">max</span> <span class="o">=</span> <span class="n">y</span>
   <span class="sd">&quot;&quot;&quot;{  goal: max &gt;= x  ^  max &gt;= y }&quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;{  final goal: max &gt;= x  ^  max &gt;= y }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>The implication operator, <code class="docutils literal"><span class="pre">--&gt;</span></code>, is new to us, and we must study it carefully,
which we do in a later chapter.
For now, pretend it is a &#8220;logical if&#8221;.</p>
<p>Let&#8217;s analyze the subgoal we calculated for the if-command.
First, is <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span> <span class="pre">--&gt;</span> <span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">y</span></code> a true fact?
Well, whenever <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code> holds true, then by algebra, <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">y</span></code> must hold true,
too &#8211; the latter is a consequence of the assumption that <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code> holds true.
Similarly, <code class="docutils literal"><span class="pre">~(x</span> <span class="pre">&gt;</span> <span class="pre">y)</span> <span class="pre">--&gt;</span> <span class="pre">y</span> <span class="pre">&gt;=</span> <span class="pre">x</span></code> is a true fact, because whenever <code class="docutils literal"><span class="pre">~(x</span> <span class="pre">&gt;</span> <span class="pre">y)</span></code>
holds, then <code class="docutils literal"><span class="pre">y</span> <span class="pre">&gt;=</span> <span class="pre">x</span></code> follows.
So, the subgoal is true, that is, <code class="docutils literal"><span class="pre">(x</span> <span class="pre">&gt;</span> <span class="pre">y</span> <span class="pre">--&gt;</span> <span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">y)</span> <span class="pre">^</span> <span class="pre">(~(x</span> <span class="pre">&gt;</span> <span class="pre">y)</span> <span class="pre">--&gt;</span> <span class="pre">y</span> <span class="pre">&gt;=</span> <span class="pre">x)</span></code>
has the same meaning as <code class="docutils literal"><span class="pre">t</span></code>. (and <code class="docutils literal"><span class="pre">v</span></code> and <code class="docutils literal"><span class="pre">~</span></code> and <code class="docutils literal"><span class="pre">^</span></code>) - - -
literally, we must define an algebra for assertions, so that our logical
analysis is crystal clear.
We do this in a later chapter.</p>
<p>From the backwards proof, we can always rebuild the corresponding forwards proof.
Here it is, for the example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{  assert:  (x &gt; y  --&gt;  x &gt;= y) ^ (~(x &gt; y)  --&gt;  y &gt;= x)</span>
<span class="sd">           This holds true. }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="p">:</span>
   <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   {  assert:   the previous assertion  ^  x &gt; y</span>
<span class="sd">      implies:  x &gt;= y</span>
<span class="sd">      implies:  x &gt;= x  ^  x &gt;= y }</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="nb">max</span> <span class="o">=</span> <span class="n">x</span>
   <span class="sd">&quot;&quot;&quot;{ implies   max &gt;= x  ^  max &gt;= y }&quot;&quot;&quot;</span>
<span class="k">else</span> <span class="p">:</span>
   <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   {  assert:   the previous assertion  ^  ~(x &gt; y)</span>
<span class="sd">      implies:  y &gt;= x</span>
<span class="sd">      implies:  y &gt;= x  ^  y &gt;= y }</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="nb">max</span> <span class="o">=</span> <span class="n">y</span>
   <span class="sd">&quot;&quot;&quot;{  implies   max &gt;= x  ^  max &gt;= y }&quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{  assert: (max &gt;= x  ^  max &gt;= y)  v  (max &gt;= x  ^  max &gt;= y)</span>
<span class="sd">   implies:  max &gt;= x  ^  max &gt;= y  }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Here is an example where the desired goal is not always achieved:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">()</span>
<span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">x</span>
<span class="k">else</span> <span class="p">:</span>
    <span class="k">pass</span>
<span class="sd">&quot;&quot;&quot;{  goal: x &gt;= 0 }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Using backwards reasoning, we quickly deduce that</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">()</span>
<span class="sd">&quot;&quot;&quot;{  if&#39;s subgoal:  (x &gt; 0 --&gt; -x &gt; 0)  ^  (~(x &gt; 0) --&gt; x &gt;= 0) }&quot;&quot;&quot;</span>
<span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;{  subgoal: -x &gt;= 0 }&quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">x</span>
    <span class="sd">&quot;&quot;&quot;{  goal: x &gt;= 0 }&quot;&quot;&quot;</span>
<span class="k">else</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;{  subgoal: x &gt;= 0 }&quot;&quot;&quot;</span>
    <span class="k">pass</span>
    <span class="sd">&quot;&quot;&quot;{  goal: x &gt;= 0 }&quot;&quot;&quot;</span>
<span class="sd">&quot;&quot;&quot;{  goal: x &gt;= 0 }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>We see immediately there is <em>no way</em> that the if-subgoal holds true: clearly,
<code class="docutils literal"><span class="pre">(x</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">--&gt;</span> <span class="pre">-x</span> <span class="pre">&gt;</span> <span class="pre">0)</span></code> is false, and <code class="docutils literal"><span class="pre">~(x</span> <span class="pre">&gt;</span> <span class="pre">0)</span> <span class="pre">--&gt;</span> <span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> is false also
(for values of <code class="docutils literal"><span class="pre">x</span></code> that are negative).
So, we cannot prove that the program achieves its goal.
Forwards reasoning also fails:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">()</span>
<span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;{ x &gt; 0 }&quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">-</span><span class="n">x</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    { 1. x = 0 - x_old   premise</span>
<span class="sd">      2. x_old &gt; 0       premise</span>
<span class="sd">      3. x &lt; 0           algebra 2 }</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="k">else</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    { 1. ~( x &gt; 0)       premise</span>
<span class="sd">      2. x &lt;= 0          algebra 1 }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
    <span class="sd">&quot;&quot;&quot;{ 1. x &lt;= 0       premise }&quot;&quot;&quot;</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{  assert:  x &lt; 0  v  x &lt;= 0</span>
<span class="sd">   There is no way we can deduce  x &gt;= 0 ...  }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>In contrast, say that we consider this variation of the example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">x</span>
<span class="k">else</span> <span class="p">:</span>
    <span class="k">pass</span>
<span class="sd">&quot;&quot;&quot;{ goal: x &gt;= 0 }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>We can prove, using either forwards or backwards reasoning, that this particular
program achieves its goal (because we can deduce that the else-arm will be used).
The precise reasoning will be presented in a later chapter.</p>
<p>We of course use conditional commands to avoid error situations. Consider</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">()</span>
<span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">:</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">x</span>
<span class="k">else</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">print</span> <span class="n">r</span>
</pre></div>
</div>
<p>When the input number assigned to <code class="docutils literal"><span class="pre">x</span></code> is nonzero, then the output, <code class="docutils literal"><span class="pre">r</span></code>, will
be <code class="docutils literal"><span class="pre">x</span></code>&#8216;s reciprocal.
The forwards reasoning that asserts this fact goes as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">readInt</span><span class="p">()</span>
<span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;{ ~(x == 0) }&quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">x</span>
    <span class="sd">&quot;&quot;&quot;{ ~(x != 0)  ^  r = 1.0/x  }&quot;&quot;&quot;</span>
<span class="k">else</span>
    <span class="sd">&quot;&quot;&quot;{ x == 0 }&quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="sd">&quot;&quot;&quot;{ x == 0  ^  r == 0 }&quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;{ (~(x == 0)  ^  r = 1.0/x)  v  (x == 0  ^  r = 0) }&quot;&quot;&quot;</span>
<span class="k">print</span> <span class="n">r</span>
</pre></div>
</div>
<p>Once we learn better the deductive laws (the &#8220;algebra&#8221;) for <code class="docutils literal"><span class="pre">^</span></code>, <code class="docutils literal"><span class="pre">v</span></code> and
<code class="docutils literal"><span class="pre">--&gt;</span></code>, we can prove that:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>  <span class="o">^</span>  <span class="n">r</span> <span class="o">==</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>  <span class="n">v</span>  <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span>  <span class="o">^</span>  <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>says exactly the same thing as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">r</span> <span class="o">==</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>  <span class="o">^</span>   <span class="p">((</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>which reflects the strategy we had in mind when we wrote the conditional command.</p>
</div>
</div>
<div class="section" id="summary">
<h2>4.3. Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>Here are the two laws for reasoning about assignments:</p>
<div class="section" id="forwards-assignment-law">
<h3>4.3.1. Forwards Assignment Law<a class="headerlink" href="#forwards-assignment-law" title="Permalink to this headline">¶</a></h3>
<p>First, recall that the notation, <code class="docutils literal"><span class="pre">[a/b]E</span></code>, denotes phrase <code class="docutils literal"><span class="pre">E</span></code> with all
occurrences of <code class="docutils literal"><span class="pre">b</span></code> replaced by <code class="docutils literal"><span class="pre">a</span></code>.
(Example: <code class="docutils literal"><span class="pre">[3</span> <span class="pre">/</span> <span class="pre">x](2</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">x)</span></code> is <code class="docutils literal"><span class="pre">(2</span> <span class="pre">*</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">3)</span></code>.)</p>
<p>Here is the deduction law for an assignment command:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ ...</span>
<span class="sd">  m. P }</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">e</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">{ 1. x == [x_old/x]e      premise</span>
<span class="sd">  2. [x_old/x]P           premise</span>
<span class="sd">  ...</span>
<span class="sd">  n. Q    (where  Q  must _not_ mention  x_old }</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="backwards-assignment-law">
<h3>4.3.2. Backwards Assignment Law<a class="headerlink" href="#backwards-assignment-law" title="Permalink to this headline">¶</a></h3>
<p>Given a goal, <code class="docutils literal"><span class="pre">G</span></code>, we compute this subgoal:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;{ [e/x]G }&quot;&quot;&quot;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">e</span>
<span class="sd">&quot;&quot;&quot;{ G }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>That is, the subgoal (precondition) required to achieve (postcondition) <code class="docutils literal"><span class="pre">G</span></code>
with the assignment is <code class="docutils literal"><span class="pre">[e/x]G</span></code>.</p>
</div>
<div class="section" id="forwards-conditional-law">
<h3>4.3.3. Forwards Conditional Law<a class="headerlink" href="#forwards-conditional-law" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;{ ... P }&quot;&quot;&quot;</span>
<span class="k">if</span> <span class="n">B</span> <span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  { 1. B          premise</span>
<span class="sd">    2. P          premise</span>
<span class="sd">    ... }</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">C1</span>
  <span class="sd">&quot;&quot;&quot;{ ... Q1  }&quot;&quot;&quot;</span>
<span class="k">else</span> <span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  { 1. ~B         premise</span>
<span class="sd">    2. P          premise</span>
<span class="sd">    ... }</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">C2</span>
  <span class="sd">&quot;&quot;&quot;{ ... Q2 }&quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;{ 1. Q1 v Q2   premise }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>That is, if we deduce from precondition <code class="docutils literal"><span class="pre">B</span> <span class="pre">^</span> <span class="pre">P</span></code> and commands <code class="docutils literal"><span class="pre">C1</span></code> a
postcondition <code class="docutils literal"><span class="pre">Q1</span></code> (and do the same for <code class="docutils literal"><span class="pre">C2</span></code>, we can assemble the
postcondition <code class="docutils literal"><span class="pre">Q1</span> <span class="pre">v</span> <span class="pre">Q2</span></code> for the conditional.
(Of course, if <code class="docutils literal"><span class="pre">Q1</span></code> is identical to <code class="docutils literal"><span class="pre">Q2</span></code>, we can conclude just <code class="docutils literal"><span class="pre">Q1</span></code>.)</p>
</div>
<div class="section" id="backwards-conditional-law">
<h3>4.3.4. Backwards Conditional Law<a class="headerlink" href="#backwards-conditional-law" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;{ (B --&gt; S1)  ^  (~B --&gt; S2) }&quot;&quot;&quot;</span>
<span class="k">if</span> <span class="n">B</span> <span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;{ S1 }&quot;&quot;&quot;</span>
  <span class="n">C1</span>
  <span class="sd">&quot;&quot;&quot;{ G }&quot;&quot;&quot;</span>
<span class="k">else</span> <span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;{ S2 }&quot;&quot;&quot;</span>
  <span class="n">C2</span>
  <span class="sd">&quot;&quot;&quot;{ G }&quot;&quot;&quot;</span>
<span class="sd">&quot;&quot;&quot;{ G }&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>That is, if we deduce that <code class="docutils literal"><span class="pre">S1</span></code> is the subgoal required by <code class="docutils literal"><span class="pre">C1</span></code> to attain
goal <code class="docutils literal"><span class="pre">G</span></code> (similarly for <code class="docutils literal"><span class="pre">C2</span></code>), then the subgoal (precondition) needed to
attain the goal (postcondition) by the conditional is
<code class="docutils literal"><span class="pre">(B</span> <span class="pre">--&gt;</span> <span class="pre">S1)</span> <span class="pre">^</span> <span class="pre">(~B</span> <span class="pre">--&gt;</span> <span class="pre">S2)</span></code>.</p>
<hr class="docutils" />
<p align=right><small><em>
This note was adapted from David Schmidt's CIS 301, 2008,
<a href="http://people.cis.ksu.edu/~schmidt/301s14/Lectures/2assignifT.html">Chapter 2</a>
course note.
</em></small></p></div>
</div>
</div>


    </div>
      
  </div>
</div>

  </body>
</html>